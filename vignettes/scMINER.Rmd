######-
title: "Tutorial for scMINER"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial for scMINER}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
######-

*scMINER* is an R package for preprocessing, QC, clustering, and *hidden driver analysis* of single-cell RNA-seq data. scMINER enables mutual information-based cell clustering, cell-type-specific gene regulatory network (GRN) reverse engineering and protein activity inference, to identify hidden transcriptional factors (TFs) and signaling factors (SIGs) driving cellular lineage differentiation and tissue specific specification. 

scMINER software consists of three components: 

- [MICA](https://github.com/jyyulab/MICA) (Mutual Information based Clustering analysis) : perform clustering analysis

- [SJARACNe](https://github.com/jyyulab/SJARACNe) : generate cluster specific networks 

- [MINIE](https://github.com/jyyulab/scMINER/)(Mutual Information-based Network Inference Engine) : identify cell-type-specific hidden drivers


## Installation

Users need to install MICA, SJARACNe and scMINER(MINIE) to run the scMINER analysis. 
Using conda to create a virtual environment is strongly recommended. 


```bash
conda create -n scminer python=3.7.6        # Create a python virtual environment
source activate scminer                     # Activate the virtual environment
## install MICA
pip install setuptools==57.5.0              # install setuptools
pip install MICA                            # Install MICA and its dependencies
## install SJARACNE
# pip install SJARACNe                        # Install SJARACNe and its dependencies
git clone https://github.com/jyyulab/SJARACNe.git
cd SJARACNe/
python setup.py build     # build SJARACNe binary
python setup.py install
cd ../
## install scMINER(MINIE)
conda install -c -r r-base=4.0.3            # Install R (Bioconductor Version 3.12)
conda install -c conda-forge r-devtools     # Install R devtools
conda install -c conda-forge r-biocmanager  # Install R BiocManager
```

In R, you can install the current version of scMINER from [GitHub](https://github.com/) with:

``` r
devtools::install_github("jyyulab/scMINER")
```

### Example1: scMINER Guided Analysis on 14k PBMCs from 10x Genomics

This tutorial introduce you scMINER's basic analysis using a PBMC dataset with 10 sorted populations of 2k cells per population [Zheng et al., 2017](https://www.nature.com/articles/ncomms14049). We remove CD34+ cells, CD4+ helper T cells, and total CD8+ cytotoxic cells from the dataset because of low sorting purity or a significant overlap with other immune cells based on the sorting strategy, which creates a new dataset with seven known cell types and 14k cells in total. The original dataset is freely available under accession number [SRP073767](https://www.ncbi.nlm.nih.gov/sra?term=SRP073767) and [Zenodo](https://zenodo.org/record/3357167#.ZCKhxHZBxaS).

The purpose of scMINER is to identify cell-type specific hidden drivers from single-cell RNASeq dataset. 

The complete step-by-step demo script for this example can be found here: [Example1_PBMC14k.R](https://github.com/jyyulab/scMINER/tree/dev-sherry/demo_scripts/Example1_PBMC14k.R)

NOTE: for the dataSet size issue, the data in the demo is the down-sampled dataset from 14k PBMCs. 

##### Step0: Preparations

Make sure you have the MICA, SJARACNe, scMINER package installed. For this example, R package `openxlsx`, `anndata` are required. 

```{r,echo=FALSE}
library(scMINER)
library(openxlsx)
library(anndata)
```

We have designed a function, `scMINER.dir.create()` to handle the working directories so that the user can have a better data organization. This function require user to define the main working directory `project_main_dir` and the project name `project_name`. To prevent a previous project with the same `project_main_dir` and `project_name` from being rewritten, it is strongly suggested that you add a time tag to your project_name.

Create directories and folders to save and organize your analysis results.

```{r}
project_main_dir <- '../test'
project_name <- 'PBMC14KDS'
```

`scMINER.dir.create()` creates a main working directory with a subdirectory for the project. 
It also automatically creates subfolders within the project folder: 
DATA/, storing data files; 
SJAR/, storing files needed for running [SJAracne](https://github.com/jyyulab/SJARACNe).
MICA/, storing files needed for running [MICA](https://github.com/jyyulab/MICA).
QC/, storing quality control related plots; 
PLOT/, storing plot files;
It also returns a list object, here named scminer.par, with directory information wrapped inside. 

```{r}
# Create a hierarchical working directory and return a list contains the hierarchical working directory information
# This list object (scminer.par) is an ESSENTIAL variable in network reconstruction pipeline
scminer.par <- scMINER::scMINER.dir.create(project_main_dir = project_main_dir,
                                           project_name = project_name)
```

##### Data loading and preprocessing

###### Read 10x genomics data

We start by reading the downsampled 10x genomics data with function `readscRNAseqData()`. This function reads data from either 10x genomics standard output files (usually contains three individual files: matrix.mtx, barcodes.tsv, features.tsv) or other text files by passing arguments to `read.delim()`. The function creates a `SparseExpressionSet` object adapted from `ExpressionSet` class if set `CreateSparseEset=T`; otherwise, it creates a list object that stores expression data, feature data and sample data under three separate slots. If `add.meta=T`, then additional sample info such as total number of UMI will be calculated and stored in the object. The following command sets `is.10x=T`, `CreateSparseEset = T`, and `add.meta=T`.

To load data from standard 10x genomics files, creating a `SparseEset` directly is recommended.

```{r}
## Option1: load data from standard 10x genomics files
demo_dir <- base::system.file('PBMC14KDS_DemoDataSet/DATA/10X/',
                              package = "scMINER")
pbmc.14k.DS.eset <- scMINER::readscRNAseqData(file = demo_dir,
                                              is.10x = T,
                                              CreateSparseEset = T,
                                              add.meta = T)
```

The following code loads data that are not from standard 10x genomics files.

```r
## Option2: load data from plain matrix text file
demo_file <- 'PBMC_20k_MICA_input_filter_14k.txt'
pbmc.14k.DS <- scMINER::readscRNAseqData(file=demo_file,
                                is.10x = F,
                                CreateSparseEset = F,
                                add.meta = F,
                                sep='\t')
pbmc.14k.DS.eset <- scMINER::CreateSparseEset(data = t(as.matrix(pbmc.14k.DS)),
                                              add.meta = T)
```

The following code shows the demo to load data from Seurat.

```r
## Option3: load data from Seurat object file (seruat ######> SparseEset)
meta.data<-SeuratObject@meta.data
feature.data<-data.frame(rownames(SeuratObject@assays$RNA@data))
colnames(feature.data)<-"geneSymbol"
rownames(feature.data)<-feature.data$geneSymbol
pbmc.14k.DS.eset <- scMINER::CreateSparseEset(data=SeuratObject@assays$RNA@data,
                                              meta.data = meta.data,feature.data = feature.data,add.meta = F)
```

###### Quality control and data filtering

Quality control assessments can be performed using `draw.scRNAseq.QC()` function, which outputs a html report generated through Rmarkdown [PBMC14K_QC_report.html](../htmls/PBMC14k_scRNAseq_QC.html). The report includes three essential quality control figures at both gene and cell levels. Suggested cutoffs will be returned as a list if set `output.cutoff=TRUE`.


```{r}
cutoffs <- scMINER::draw.scRNAseq.QC(SparseEset = pbmc.14k.DS.eset,
                            project.name = project_name,
                            plot.dir = scminer.par$out.dir.QC,
                            group = "group",      # this indicate which meta data information will be use in x axis to group violin plots
                            output.cutoff = TRUE) # whether or not to output suggested cutoffs
```

The histogram plot visualizes a distribution of expressed genes among each cells. The blue vertical line shows the recommended cutoff (0.5% * number of cells) to filter lowly expressed cells. 
The violin plot visualizes the total UMI count and the total number of genes expressed in violin plots. Horizontal blue line indicates suggested high/low cutoffs. Suggested thresholds were computed based on Median Â± 3 * MAD (maximum absolute deviance). Suggested threshold numbers are also printed right above blue lines in labels.
The scatter plot shows mitochondrial gene expression percentage, and spike-in genes expression percentage (if spike-in genes exist) for each cell vs. the total number of UMIs. Cells with a high percentage of mitochondrial gene expression but a low total number of UMI counts are often considered as low quality cells (above the horizontal line).

We recommend using the thresholds in `cutoffs` list returned by `draw.scRNAseq.QC()` function. However, users can adjust the thresholds manually, e.g., `cutoffs$umi_cf_hi <- Inf` will not filter on outliers caused by a high total UMI values.

```{r}
pbmc.14k.DS.eset.filter <- scMINER::preMICA.filtering(SparseEset = pbmc.14k.DS.eset,
                                             cutoffs = cutoffs)
```

###### Normalization and transformation

We recommend count per million reads (CPM) normalization and log2 transformation (required) for performing MICA clustering analysis.

```{r}
norm_value <- 1e6
exp.norm <- sweep(exprs(pbmc.14k.DS.eset.filter), 2,
                  norm_value/unname(Matrix::colSums(exprs(pbmc.14k.DS.eset.filter))), '*') # normalization
exp.log2 <- log(exp.norm + 1, base = 2) # log transformation (required by MICA)

## save as SparseEset
pbmc.14k.DS.eset.log2 <- CreateSparseEset(data = exp.log2,
                                       meta.data = pData(pbmc.14k.DS.eset.filter),
                                       feature.data = fData(pbmc.14k.DS.eset.filter),
                                       add.meta = F)

```

Save essential files to working directory (suggested).

```{r}

scminer.par$out.dir.DATA_eset <- sprintf('%s/pbmc.14k.DS.eset.log2.RData',
                                         scminer.par$out.dir.DATA)
save(pbmc.14k.DS.eset.log2,file=scminer.par$out.dir.DATA_eset)
```

##### Perform clustering analysis via MICA

After reviewing all the QC plots and finishing filtering, it is ready to perform clustering analysis. 

###### Generate MICA input

`generateMICAinput()` function takes a log transformed expression matrix as input, and outputs a cell by gene matrix stored in .h5 (default) or .txt file as input to MICA.

```{r}
scminer.par$out.dir.MICA_input <- sprintf('%s/PBMC14KDS_MICA_input.h5ad',
                                          scminer.par$out.dir.MICA)
MICA.cmd <- generateMICAinput(eset = pbmc.14k.DS.eset.log2 ,
                              filepath = scminer.par$out.dir.MICA_input,
                              scminer.par = scminer.par)
scminer.par$MICA.cmd <- MICA.cmd
```

###### Run MICA from the command line

MICA is implemented in Python as a standalone command line tool. 
Here, the `generateMICAinput()` function will output a suggested command line.

```r
### Step4: Run MICA: mica mds -i ../test/PBMC14KDS/MICA//PBMC14KDS_MICA_input.h5ad -o ../test/PBMC14KDS/MICA/ -pn PBMC14KDS -nc 4 5 6 7 8 9 10 -dk 19
system(scminer.par$MICA.cmd)
### Save scminer.par
save(scminer.par,file=scminer.par$out.dir.DATA_par)
```

Pick a MICA command to run in a command line environment based on the number of cells of your dataset. For dataset with less than `5k` cells, MICA MDS mode is recommended.

``` bash
mica mds -i ../test/PBMC14KDS/MICA//PBMC14KDS_MICA_input.h5ad -o ../test/PBMC14KDS/MICA/ -pn PBMC14KDS -nc 4 5 6 7 8 9 10 -dk 19
```

Here, `-pn` specifies a project name for naming the output files; `-nc` is an array of integers delimited by a single space, where each integer specifies a `k` to perform a k-mean clustering; `-dk` can be an integer or an array of integers delimited by a single space (default is `19`), it specifies the number of dimensions used in k-mean clusterings. Use `mica mds -h` to see more options of MICA MDS mode.

For datasets with more than `5k` cells, MICA GE mode is recommended.

``` bash
mica ge -i ../test/PBMC14KDS/MICA//PBMC14KDS_MICA_input.h5ad -o ../test/PBMC14KDS/MICA/ -pn PBMC14KDS -ar 4.0 -ss 0.1 -nw 25 -nnm 80
```

Here, `-ar` determines the maximum size of the communities (default: `3.0`); `-ss` is the step size to sweep resolutions in a range (default: `0.2`); `-nw` specifies the number of workers to run in parallel (default: `1`); `-nnm` is the number of neighbors to build mutual information-based nearest neighbor graph (default `80`). Use `mica ge -h` to find more options of MICA GE mode.

A more detailed description of output files and important parameters can be found in [Mutual information-based clustering analysis (MICA)](https://jyyulab.github.io/scMINER/site/tutorials/MICA-advanced/) page.


###### Read MICA output

If re-open R-session, load the parameter object and RData from the project working directory:

```r
### Step0: load scminer.par into R session:
load("../test/PBMC14KDS/DATA/scminer.par.RData")

### Step1: Load MICA output clustering results
## load SparseEset RData
load(scminer.par$out.dir.DATA_eset) ## if re-start R-session
```

If the user only want to test the code in this section, load the RData from scMINER Package file. 

```r
# or load from R package
demo_file <- base::system.file('PBMC14KDS_DemoDataSet/DATA/pbmc.14k.DS.eset.log2.RData',
                         package = "scMINER")
load(demo_file)
```

User can choose a clustering result based on known cell type signatures or silhouette scores (provided by GE mode). 

```r
## read in MICA output file (choosing a clustering result based on known cell type signatures or silhouette scores), the file name can be modified
scminer.par$out.dir.MICA_output <- sprintf('%s/clustering_umap_euclidean_19.txt',
                                           scminer.par$out.dir.MICA)
```

Here, we use the demo file from scMINER package. 

```{r}
## or use file from R package
scminer.par$out.dir.MICA_output <- base::system.file('PBMC14KDS_DemoDataSet/MICA/clustering_umap_euclidean_19.txt',
             package = "scMINER")
```

Function `readMICAoutput()` adds MICA clustering results to the `SparseEset` object created before, which will be the major data structure for downstream analysis. **Note: All the functions for downstream analysis are compatible with both `expressionSet` and `SparseExpressionSet`**. The clustering labels can be saved to `eset$ClusterRes` by setting `load_ClusterRes` as TRUE.

```{r}
pbmc.14k.DS.eset.log2 <- scMINER::readMICAoutput(eset = pbmc.14k.DS.eset.log2,
                                                 load_ClusterRes = TRUE,
                                output_file = scminer.par$out.dir.MICA_output)
```

`MICAplot()` function can be used to visualize MICA clustering results using `ggplot`.

```{r,fig.width=15,fig.height=18}
## draw MICA results
scMINER::MICAplot(input_eset = pbmc.14k.DS.eset.log2, X = "X", Y = "Y",
                  color_by = "ClusterRes", pct = 0.5)
```
  
##### Cell type annotation after clustering

###### Marker gene visualization

To help with identifing the optimal number of clusters and annotating the clusters, selected marker genes can be visualized with UMAP/t-SNE scatterplots, violin plots or heatmap plots via function `feature_highlighting()`, `feature_vlnplot()` and `feature_heatmap()` respectively.

```{r,fig.width=15,fig.height=18}
genes_of_interest <-c("CD3D", "CD27", "IL7R",
                      "SELL", "CCR7", "IL32",
                      "GZMA", "GZMK", "DUSP2",
                      "CD8A", "GZMH", "GZMB",
                      "CD79A", "CD79B", "CD86", "CD14")
## UMAP scatter plot
scMINER::feature_highlighting(input_eset = pbmc.14k.DS.eset.log2,
                              target = genes_of_interest,
                              feature = "geneSymbol",
                              ylabel = "log2Exp",
                              x = "X", y = "Y",
                              pct.size = 0.5)
```


```{r,fig.width=15,fig.height=18}
scMINER::feature_vlnplot(input_eset = pbmc.14k.DS.eset.log2,
                         target = genes_of_interest,
                         feature = "geneSymbol",
                         group_by = "ClusterRes",
                         ylabel = "log2Exp", ncol = 4)
```  
  
  
```{r,fig.width=15,fig.height=18}
scMINER::feature_heatmap(input_eset = pbmc.14k.DS.eset.log2,
                         target = genes_of_interest,
                         group_name = "ClusterRes",
                         save_plot = FALSE,
                         width = 6, height = 6,
                         name = "log2Exp")

```  


###### Cell type annotation

With a pre-defined marker gene list, `marker_bbplot()` function calculates a cell type signature score (weighted mean using the given weights in the marker list) for each cluster, and visualize all the signature scores using a bubble plot. Here, we curated a list of well-known marker genes of 9 common immune cell types and use these genes to calculate a marker score for each of the predicted PBMC clusters. **Note: the pre-defined marker gene list has a required format. See `head(makers)` below**.

```{r,fig.width=15,fig.height=18}
markers_file <- base::system.file('PBMC14KDS_DemoDataSet/DATA/',
                  'Immune_signatures.xlsx',
                  package = "scMINER")
markers <- openxlsx::read.xlsx(markers_file)
head(markers)
draw.marker.bbp(ref = markers, input_eset = pbmc.14k.DS.eset.log2,
                width = 6, height = 4, feature = "geneSymbol",
                group_name = "ClusterRes", save_plot = FALSE)
```

Before diving into network generation section, assign the annotated cell types as factors in your expression set for keeping the current order of the clusters in following visualizations. **Please do not include "_" in your cell type names as it would cause mis-parsing in the following analysis.**.

```{r}
# give cell annotation
indx <- factor(x=c("Monocyte", "CD4TCM", "NK", "Bcell"),
               levels=c("Monocyte", "CD4TCM", "NK", "Bcell"))
pbmc.14k.DS.eset.log2$celltype <- indx[pbmc.14k.DS.eset.log2$ClusterRes]
```

Save updated SparseEset and parameter object. 

```{r}
## save updated SparseEset
save(pbmc.14k.DS.eset.log2,file=scminer.par$out.dir.DATA_eset)

### Save scminer.par
save(scminer.par,file=scminer.par$out.dir.DATA_par)
```

##### Network generation via SJARACNe

###### Generate SJARACNe input
`generateSJAracneInput()` functions uses the annotated cell type information stored in `pData([your_expressionSet])` to generate inputs for running SJARACNe from the command line. The function partitions the input expression matrix and performs essential filtering (filter out not expressed genes in a cluster) to ensure a reliable network construction. `funcType` is required to specify the type of the network. If set `funcType="TF"`, a reference transcription factor list will be loaded automatically without manual input. However, you do need to define species information for your data using under `ref`.

This function creates one directory containing the required inputs (filtered expression matrix in .exp format and filtered TF list in .txt format) for each cell type. 

```{r}
SJAR.cmd.tf <- generateSJARACNeInput(
  input_eset = pbmc.14k.DS.eset.log2,
  funcType = "TF",
  ref = "hg",  # human
  wd.src = scminer.par$out.dir.SJAR,  # output directory
  group_name = "celltype")
SJAR.cmd.sig <- generateSJARACNeInput(
  input_eset = pbmc.14k.DS.eset.log2,
  funcType = "SIG",
  ref = "hg",  # human
  wd.src = scminer.par$out.dir.SJAR,  # output directory
  group_name = "celltype")
scminer.par$SJAR.cmd.tf <- SJAR.cmd.tf
scminer.par$SJAR.cmd.sig <- SJAR.cmd.sig
scminer.par$SJAR.group.name <- "celltype"
```

###### Run SJARACNe from the command line

SJARACNe works as a separate module which was implemented in python and C++, refer to [SJARACNe](https://github.com/jyyulab/SJARACNe) github page for installation and basic usage. 

```r
## Step2: run SJARACNe
system(scminer.par$SJAR.cmd.tf$local)
system(scminer.par$SJAR.cmd.sig$local)
```

Save the updated parameter object.

```{r}
### Save scminer.par
save(scminer.par,file=scminer.par$out.dir.DATA_par)
```

##### Identify cell-type-specific hidden drivers via MINIE

Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight. 

###### Calculate activity

Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are integrated via function `GetActivityFromSJARACNe()`. This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set `save_network_files=TRUE`. **Please note that this function could only work if you used `generateSJARACNeInput()` to create SJARACNe input directory and files.**

Users can set the `scminer.par$out.dir.SJAR` to the demo output directory in the R package to testify the codes in this section.

```{r}
scminer.par$out.dir.SJAR <- base::system.file('PBMC14KDS_DemoDataSet/SJAR/',
             package = "scMINER")
```

Since scRNA-seq data is extremely sparse and noisy, please set `activity.method` as `'unweighted'`. 

```{r,fig.width=15,fig.height=18}
### Step1: Calculate activity from SJARACNe output
acs.14k.tf <- GetActivityFromSJARACNe(
  SJARACNe_output_path = scminer.par$out.dir.SJAR,
  SJARACNe_input_eset = pbmc.14k.DS.eset.log2,
  activity.method="unweighted", # we highly recommend using 'unweighted' as activity calculation method
  activity.norm=TRUE,
  group_name = scminer.par$SJAR.group.name, # which group was used to partition expression profiles
  save_network_file=TRUE, # whether or not save network for each group
  functype="tf",
  save_path=scminer.par$out.dir.SJAR)

acs.14k.sig <- GetActivityFromSJARACNe(
  SJARACNe_output_path = scminer.par$out.dir.SJAR,
  SJARACNe_input_eset = pbmc.14k.DS.eset.log2,
  activity.method="unweighted", # we highly recommend using 'unweighted' as activity calculation method
  activity.norm=TRUE,
  group_name = scminer.par$SJAR.group.name, # which group was used to partition expression profiles
  save_network_file=TRUE, # whether or not save network for each group
  functype="sig",
  save_path=scminer.par$out.dir.SJAR)

# save activity to RData file (optional)
scminer.par$out.dir.AC <- sprintf('%s/%s_Activity.RData',scminer.par$out.dir.DATA,
                                  scminer.par$SJAR.group.name)
AC_eset <- list(AC.TF=acs.14k.tf,AC.SIG=acs.14k.sig)
save(AC_eset,file=scminer.par$out.dir.AC)

```

###### Driver estimation by differential activity analysis
 
The function `get.DA()` was designed to perform differential activity analysis from SJARACNe inferred activity matrix. In this function, two-sided student's t-test will be performed to compare mean activity from one cell type V.S. the others. It will return a data frame that includes all TF occurred in original data. Statistics such as t.statistics, p-value, 95%CI, etc. are output to help identify hidden drivers. You can save it to file in order to check them manually. 


```{r,fig.width=15,fig.height=18}
### Step2: Driver estimation by differential activity analysis
DAG_result_tf <- get.DA(input_eset = acs.14k.tf,
                        group_name = scminer.par$SJAR.group.name)
DAG_result_sig <- get.DA(input_eset = acs.14k.sig,
                         group_name = scminer.par$SJAR.group.name)
```

We also offer a function called `get.Topdrivers()` to help picking top drivers for each cell type. You can specify `n` as maximum number of top drivers to pick, and `degree_filter` to restrict number of targets.

```{r,fig.width=15,fig.height=18}
celltype <- levels(pData(pbmc.14k.DS.eset.log2)[,scminer.par$SJAR.group.name])
TF_list <- get.Topdrivers(DAG_result = DAG_result_tf,
                          celltype = celltype,
                          # ensure cluster order
                          n = 5, degree_filter = c(50, 600))

### Step3: Check positive controls
p <- feature_vlnplot(input_eset = acs.14k.sig,
                     feature = "fn",
             target=c("CD27", "IL7R","CCR7",'GZMA','GZMK','DUSP2','GZMH','GZMB'),
                     ylabel = "Activity",
                     group_by = scminer.par$SJAR.group.name, ncol=2)
p
```

Finally, save parameter object for the project management.

```{r,fig.width=15,fig.height=18}
#### Step4: update parameter object
save(scminer.par,file=scminer.par$out.dir.DATA_par)
```

To perform more advanced network analysis utilizing SJARACNe generated cell type specific networks, please refer to pages [Network visualization](https://jyyulab.github.io/scMINER/site/tutorials/network-visualize/) and [Driver target function analysis](https://jyyulab.github.io/scMINER/site/tutorials/function-analysis/).
