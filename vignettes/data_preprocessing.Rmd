---
title: "Create SparseExpressionSet objects from multiple input formats"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{data_preprocessing}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE, warning=FALSE}
library(scMINER)
library(ggplot2)
library(dplyr)
```

# Introduction

This tutorial describes how to create the normalized SparseExpressionSet (sparse eSet) objects from multiple input formats. This vignette will walk through the basic workflow of data preprocessing with scMINER, including generation of gene expression matrix, creation of sparse eSet project, quality control, data filtration and normalization.


# Generating the gene expression matrix

In this section, we will generate the gene expression matrix, genes by cells, from **multiple input formats** commonly used in single-cell RNA sequencing. For demonstration purposes, scMINER embedded four datasets in `extdata/demoData_readInput`, with one for each input format. All of these four samples were generated by downsampling the real scRNA-seq data.

## From data directory generated by 10x Genomics 

This is the most popular input format of scRNA-seq data generated by 10x Genomics. Usually, the data directory contains three files:

- **matrix.mtx**: a sparse matrix format containing the raw UMI count per cell and gene combination
- **barcodes.tsv**: a tab-separated matrix containing the cell barcodes.
- **features.tsv**: a tab-separated matrix containing the features/genes and their annotations.

For more details about this format, please check out [here](https://www.10xgenomics.com/support/software/cell-ranger/latest/analysis/outputs/cr-outputs-mex-matrices).

```{r read-10x-data-from-directory}
data_dir <- system.file("extdata/demoData_readInput/cell_matrix_10x", package = "scMINER")
list.files(path = data_dir, full.names = FALSE)

demo1_mtx <- readInput_10x.dir(input_dir = data_dir, featureType = "gene_symbol", removeSuffix = TRUE, addPrefix = "demo1")

demo1_mtx[1:10,1:10]
```

The `readInput_10x.dir()` function can handle these conditions:

- Alternative file names for feature data: for the datasets generated by CellRanger 3.0 or earlier, the file name is **genes.tsv**;
- Compressed input files: one or more input files are compressed, usually in "**.gz**" format;
- Data with multiple modalities: like the single cell multiome data. In this case, `readInput_10x.dir()` only retains the data of "Gene Expression" by default.

## From HDF5 file generated by 10x Genomics 

This is another popular input format of scRNA-seq data generated by 10x Genomics. The Hierarchical Data Format version 5 (HDF5 or H5) is a binary format that can compress and access data much more efficiently than text formats. It's super useful when dealing with large datasets.

For more details about this format, please check out [here](https://www.10xgenomics.com/support/software/cell-ranger/latest/analysis/outputs/cr-outputs-h5-matrices).

```{r read-10x-data-from-h5}
h5_file <- system.file("extdata/demoData_readInput/hdf5_10x/Brain_Tumor_3p_LT_filtered_feature_bc_matrix.h5", package = "scMINER")
demo2_mtx <- readInput_10x.h5(h5_file = h5_file, featureType = "gene_symbol", removeSuffix = TRUE, addPrefix = "demo2")
demo2_mtx[1:10,1:10]
```

***NOTE:*** The `readInput_10x.h5()` function is developed exclusively for the HDF5 file generated by CellRanger of 10x Genomics. The HDF5 files from other source may have different hierarchical structures and can not be read by this function.

## From text-table file

This is definitely the most compatible text format for scRNA-seq data. which can be used by all single-cell RNA-seq technologies, like 10x Genomics, Smart-Seq, Drop-Seq and more. The commonly used text table file formats include **txt** (text file format), **csv** (comma-separated values) and **tsv** (tab-separated values).

```{r read-10x-data-from-table-file}
table_file <- system.file("extdata/demoData_readInput/table/demoData3.txt", package = "scMINER")
demo3_mtx <- readInput_table(table_file = table_file, sep = "\t", is.geneBYcell = TRUE, removeSuffix = TRUE, addPrefix = "demo3") # set is.geneBYcell = FALSE to read features in columns and cell in in rows
demo3_mtx[1:10,1:10]
```

***NOTE:*** A major concern to read the gene expression matrix from text-table files is that **the special characters in column names might be changed to dots (".")**, especially when the matrix is organized in cells by genes. This may cause failures in the identification of mitochondrial genes (usually defined by "MT-|mt-") or spike-in RNAs (usually defined by "ERCC-|Ercc-"). The `readInput_table()` function has set `check.names = FALSE` to avoid this issue. However, if this issue already exists in the source data, you will have to fix it manually.

## From H5AD file

The H5AD file is another well-used format for scRNA-seq data. Derived from HDF5 file format, the H5AD file is designed to store large amounts of data efficiently and to facilitate fast access to subsets of the data. Now it's getting more and more popular in scRNA-seq data analysis, visualization and sharing.

For more details about this format, please check out [here](https://anndata.dynverse.org/).

```{r read-10x-data-from-h5ad-file, eval=FALSE}
h5ad_file <- system.file("extdata/demoData_readInput/h5ad/demoData4.h5ad", package = "scMINER")
demo4_obj <- readInput_h5ad(h5ad_file = h5ad_file, removeSuffix = TRUE, addPrefix = "demo4") # set is.geneBYcell = FALSE to read features in columns and cell in in rows
t(demo4_obj$X)[1:10,1:10]
```

***NOTE:*** Unlike the other three readInput functions which return a gene expression matrx, the `readInput_h5ad()` returns an AnnData object. Here are the key components of an AnnData object:

- **X**: the primary data matrix, cells by genes;
- **obs**: observations (cells) metadata;
- **var**: variables (features/genes) metadata.


# Create sparse eSet object

In this section, we will **create the SparseExpressionSet object** from the gene expression matrix generated above. The demo dataset used in this section is the **PBMC14k** dataset, which contains 7 known cell types of 2,000 cell per cell type. This dataset was generated from a dataset with 10 sorted Peripheral Blood Mononuclear Cells (PBMCs) populations [[Zheng et al., 2017](./data-reference.md#[Zheng et al., 2017])]. The original dataset is freely available under accession number [SRP073767](https://www.ncbi.nlm.nih.gov/sra?term=SRP073767) and [Zenodo](https://zenodo.org/record/3357167#.YhQNF2RKj6V).

```{r load-the-pbmc14k-data}
data("pbmc14k_rawCount")
dim(pbmc14k_rawCount)
pbmc14k_rawCount[1:10,1:10]
```

<details>
<summary>**How was the PBMC14K dataset generated from the original dataset?**</summary>
```{r, eval = FALSE}
## Step 1: rectify the invalid gene symbols 
counts <- read.csv("./Filtered_DownSampled_SortedPBMC_data.csv", row.names = 1) # "Filtered_DownSampled_SortedPBMC_data.csv" is the raw count matrix directly downloaded from Zenodo
d <- t(counts); dim(d) # it includes 21592 genes and 20000 cells

officialGene <- read.table("./genesymbol_from_GTF_GRCh37.txt", header = T, sep = "\t", quote = "", stringsAsFactors = F); head(officialGene) # "genesymbol_from_GTF_GRCh37.txt" contains the official gene ids and symbols extracted from GTF file downloaded from https://ftp.ensembl.org/pub/grch37/current/gtf/homo_sapiens/
officialGene$dotted_symbol <- gsub("-", "\\.", officialGene$gene_name); officialGene$dotted_symbol <- make.unique(officialGene$dotted_symbol)
table(row.names(d) %in% officialGene$dotted_symbol); row.names(d)[! row.names(d) %in% officialGene$dotted_symbol] # two genes are not in: X7SK.1 and X7SK.2
row.names(d) <- gsub("X7SK.1", "7SK", row.names(d)); row.names(d) <- gsub("X7SK.2", "7SK.1", row.names(d))
table(row.names(d) %in% officialGene$dotted_symbol) # all true

row.names(officialGene) <- officialGene$dotted_symbol
officialGene <- officialGene[row.names(d),]
row.names(d) <- make.unique(officialGene$gene_name)
write.table(d, file = "./PBMC20K_rawCount.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE, append = FALSE) # 21592 genes, 20000 cells

celltype <- read.csv("./Labels.csv"); head(celltype); # "Labels.csv" contains the true label of cell types directly downloaded from Zenodo
table(celltype$x) # 2000 cells for each of 10 cell types: CD14+ Monocyte, CD19+ B, CD34+, CD4+ T Helper2, CD4+/CD25 T Reg, CD4+/CD45RA+/CD25- Naive T, CD4+/CD45RO+ Memory, CD56+ NK, CD8+ Cytotoxic T, CD8+/CD45RA+ Naive Cytotoxic
df <- data.frame(cell_barcode = colnames(d), cell_type = celltype$x); dim(df) ## 
write.table(df, file = "./PBMC20K_trueLabel.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE, append = FALSE)

## Step 2: extract 7 populations
df.14k <- df[df$cell_type %in% c("CD14+ Monocyte", "CD19+ B", "CD4+/CD25 T Reg", "CD4+/CD45RA+/CD25- Naive T", "CD4+/CD45RO+ Memory", "CD56+ NK", "CD8+/CD45RA+ Naive Cytotoxic"),]
write.table(df.14k, file = "./PBMC14K_trueLabel.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE, append = FALSE)

d.14k <- d[,df.14k$cell_barcode]
d.14k <- d.14k[rowSums(d.14k) > 0,]
write.table(d.14k, file = "./PBMC14K_rawCount.txt", sep = "\t", row.names = FALSE, col.names = TRUE, quote = FALSE, append = FALSE) # 17986 genes, 14000 cells
```
</details>
\

## Solely from the gene expression matrix

This is **the most commonly used way** to create the sparse eSet object with scMINER:
```{r create-sparse-eset-solely-from-matrix}
pbmc14k_raw.eset <- createSparseEset(input_matrix = pbmc14k_rawCount, projectID = "PBMC14k", addMetaData = TRUE)
pbmc14k_raw.eset
```
- **input_matrix**: it's usually but not limited to a sparse matrix of raw UMI count.
  - As for the data format, it accepts **`dgCMatrix`**, **`dgTMatrix`**, **`dgeMatrix`**, **`matrix`**, **`data.frame`**.
  - As for the type of quantification measures, it takes **raw counts**, normalized counts (e.g. **`CPM`** or **`CP10k`**), **`TPM`** (Transcripts Per Million), **`FPKM/RPKM`** (Fragments/Reads Per Kilobase of transcript per Million) and others.
  - **What if a data frame object is given to it?** When a non-matrix table is passed to `input_matrix` argument, the `createSparseEset()` function will automatically convert it to a matrix. And it the matrix, either converted from other format or directly passed from users, is not sparse. `createSparseEset()` will automatically convert it into sparse matrix, by default. This is controlled by another argument called `do.sparseConversion`, the default of which is `TRUE`. It's not recommended but the users can set it as `FALSE` to disable the conversion. Then `createSparseEset()` will create the eSet based on the regular matrix.
- **addMetaData**: when this argument is set `TRUE` (this is the default), `createSparseEset()` will automatically generate 5 statistics, 4 for cells and 1 for features, and add them into the `phenoData` and `featureData` slots. These 5 statistics will be used in quality control and data filtration.

```{r sparse-eset-metadata}
## check the phenoData: metadata of cells
head(pData(pbmc14k_raw.eset))

## check the featureData: metadata of features
head(fData(pbmc14k_raw.eset))
```

## Using self-customized meta data

In some cases, you may have more meta data of either cells (e.g. sample id, treatment condition) or features (e.g. gene full name, gene type, genome location) which will be used in downstream analysis and you do want to add them into the sparse eSet object. the `createSparseEset()` function provides another two arguments, **`cellData`** and **`featureData`**, to take the self-customized meta data. For the PBMC14k dataset, we have the true labels of cell type and would like to add them to the sparse eSet object.

```{r create-sparse-eset-solely-with-cutomized-matadata}
## read the true labels of cell type for PBMC14k dataset
true_label <- read.table(system.file("extdata/pbmc14k_projectSpace/PBMC14k_trueLabel.txt", package = "scMINER"), header = T, row.names = 1, sep = "\t", quote = "", stringsAsFactors = FALSE)
head(true_label)
table(true_label$cell_type)

## the true_label much cover all cells in the expression matrix
table(colnames(pbmc14k_rawCount) %in% row.names(true_label))

## create the sparse eSet object using the true_label
pbmc14k_raw.eset <- createSparseEset(input_matrix = pbmc14k_rawCount, cellData = true_label, featureData = NULL, projectID = "PBMC14k", addMetaData = TRUE)

## check the true labels of cell type from sparse eSet object
head(pData(pbmc14k_raw.eset))
table(pData(pbmc14k_raw.eset)$cell_type)
```

## From multiple samples

**What if you have multiple samples for one project?** Now it's pretty common to profile multiple samples of the same tissue but under different conditions (e.g. drug treatment) in one project. Analyzing these samples one by one is crucial, and analyzing them in a combined manner may give you more prospects. For this purpose, scMINER provides a function, `combineSparseEset()`, to easily combine the sparse eSet objects of multiple samples.

```{r combine-sparse-eset}
## create a sparse eSet object of each sample to combined
demo1_mtx <- readInput_10x.dir(input_dir = data_dir, featureType = "gene_symbol", removeSuffix = TRUE)
demo1.eset <- createSparseEset(input_matrix = demo1_mtx, projectID = "demo1", addMetaData = TRUE)

demo2_mtx <- readInput_10x.h5(h5_file = h5_file, featureType = "gene_symbol", removeSuffix = TRUE)
demo2.eset <- createSparseEset(input_matrix = demo2_mtx, projectID = "demo2", addMetaData = TRUE)

demo3_mtx <- readInput_table(table_file = table_file, sep = "\t", is.geneBYcell = TRUE, removeSuffix = TRUE)
demo3.eset <- createSparseEset(input_matrix = demo3_mtx, projectID = "demo3", addMetaData = TRUE)

demo4_obj <- readInput_h5ad(h5ad_file = h5ad_file, removeSuffix = TRUE)
demo4.eset <- createSparseEset(input_matrix = t(demo4_obj$X), projectID = "demo4", addMetaData = TRUE)

## combine the 4 sparse eSet objects
combined.eset <- combineSparseEset(eset_list = c(demo1.eset, demo2.eset, demo3.eset, demo4.eset),
                                   projectID = c("sample1", "sample2", "sample3", "sample4"),
                                   addPrefix = c("demo1", "demo2", "demo3", "demo4"),
                                   addSurfix = NULL, addMetaData = TRUE, imputeNA = TRUE)
dim(combined.eset)
```

A few questions you may have about the `combineSparseEset()` function:
- **What if the input eSets have different features?** `combineSparseEset()` ALWAYS keep all features from the input eSets, and generate NA values wherever the data is not available. By default, this function impute the NA values with the minimum value of the combined matrix, which is usually but not always zero. If this imputation method doesn't fit your study, you can set `imputeNA` to `FALSE` to disable it. If so, the NAs will retain in the eSet object, and you can manually impute them with your own method.
- **What if the input eSets have some same cell barcodes?** `combineSparseEset()` ALWAYS keep all cells from the input eSets, and will report an error when same barcodes are found in different input eSets. This function provides two arguments, `addPrefix` and `addSurfix`, to solve this issue. You can easily avoid the same barcodes of different input eSets by adding a eSet-specific prefix and/or surfix to the barcodes.
```{r show-barcodes-of-combined-eset}
head(pData(combined.eset))
```

- **I have some customized column in the phenoData and/or featureData slots. How does `combineSparseEset()` handle them?** `combineSparseEset()` only keep the columns of phenoData and featureData that shared by all input eSets. Your customized columns would be kept only when they are available in all input eSets.
- **Are the 5 meta data statistics in the combined eSet still same with those generated in each eSet?** No. By default, `combineSparseEset()` will update (add, if they are not available in input eSets) these 5 meta data statistics based on the combined matrix. It's not recommended but you can disable it by setting `addMataData` to `FALSE`.


# Quality control and filter the sparse eSet object

In this section, we will introduce you how scMINER assess the scRNA-seq data quality, estimate the cutoffs for filtration, and remove the cells and feature of low quality from the sparse eSet object. We will use the PBMC14k dataset to conduct the demo.

## QC metrics available in scMINER

As we mentioned before, scMINER can automatically generate 5 meta data statistics and add them to the sparse eSet object. These 5 meta data statistics are the metrics scMINER uses to assess the quality of cells and features:

- For cell quality assessment, scMINER provides 4 metrics that [commonly used by the community](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4758103/):
  - **nUMI**: number of total UMIs in each cell. Cells with abnormally high nUMI usually indicate doublets, while those with abnormally low nUMI usually indicate poorly sequenced cells or empty droplets.
  - **nFeature**: number of expressed features/genes in each cell. Similar to nUMI.
  - **pctMito**: percentage of UMIs of mitochondrial genes (defined by "^mt-|^MT-") in each cell. Cells with aberrantly high pctMito usually indicate dying cells.
  - **pctSpikeIn**: percentage of UMIs of spike-in RNAs (defined by "^ERCC-|^Ercc-")) in each cell. This is used to estimate the normalization factor. Cells with extremely high or low pctSpikeIn need to be removed.
  
- For feature quality assessment, scMINER provides one metrics:
  - **nCell**: number of cells expressing the features/genes. Genes with extremely low nCell are poorly sequenced and are usually of low variance.

## Generate the QC report

To help assess the data quality and determine the cutoffs for data filtration, scMINER provides a function, `drawSparseEsetQC()`, to generate a html-format quality control report:
```{r generateQCreport-eset, eval=FALSE}
## To generate the 
drawSparseEsetQC(input_eset = pbmc14k_raw.eset, output_html_file = "/Users/qpan/PBMC14k/PLOT/pbmc14k_rawCount.html", overwrite = TRUE)

## scMINER supports group-specific QC highlights
drawSparseEsetQC(input_eset = pbmc14k_raw.eset, output_html_file = "/Users/qpan/PBMC14k/PLOT/pbmc14k_rawCount.html", overwrite = FALSE, group_by = "true_label")
```

The qaulity control report consists of 4 parts:
- **Key Statistics**: it highlights 5 key statistics of given eset object, including `number of cells`, `number of genes`, mean of `genes per cell`, mean of `UMIs per cell` and mean of `cells per gene`.
- **Detailed statistics of key metrics**: it summarizes and visualizes the detailed statistics of 5 key metrics that scMINER uses for filtration: `nUMI`, `nFeature`, `pctMito`, `pctSpikeIn`, `nCell`.
- **Detailed statistics per cell and gene**: it lists the detailed statistics of each gene and cell.
- **Filtration cutoffs by scMINER**: it provides the cutoffs estimated automatically by scMINER based on Median ± 3 * MAD (maximum absolute deviance), and the pseudo-filtration statistics on both genes and cells with these cutoffs.


















