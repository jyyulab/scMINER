---
title: "QC report for sparse eset generated by scMINER"
output:
  html_document:
    toc: true
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
library(Biobase)
library(ggplot2)
library(plotly)

tmp.d <- as.matrix(Biobase::exprs(input_eset))
tmp.pd <- Biobase::pData(input_eset)
tmp.fd <- Biobase::fData(input_eset)

if (is.null(group_by) == TRUE) {
  groupID <- "unspecified"
  tmp.pd$unspecified <- "Combined"
} else {
  groupID <- group_by
}
grps <- unique(tmp.pd[, groupID])
```

## Part I: Key statistics

This part highlights 5 key statistics of the given eset object. 
```{r key_stats, echo= FALSE}
getKeyStatistics <- function(d) {
  d <- d[Matrix::rowSums(d) > 0,]
  d <- d[,Matrix::colSums(d) > 0]
  
  umis_per_cell <- Matrix::colSums(d)
  genes_per_cell <- Matrix::colSums(d != 0)
  cells_per_gene <- Matrix::rowSums(d != 0)
  
  return(c(ncol(d), nrow(d), round(mean(genes_per_cell)), round(mean(umis_per_cell)), round(mean(cells_per_gene))))
}

key_stats <- c(groupID, "Total cells", "Total genes", "Genes per cell (mean)", "UMIs per cell (mean)", "Cells per gene (mean)")
if (length(grps) > 1) {
  key_stats <- c(key_stats, "Combined", getKeyStatistics(tmp.d))
  
  for (i in 1:length(grps)) {
    tmp.d.sel <- tmp.d[, tmp.pd[, groupID] == grps[i]]
    key_stats <- c(key_stats, grps[i], getKeyStatistics(tmp.d.sel))
  }
} else {
  key_stats <- c(key_stats, grps[1], getKeyStatistics(tmp.d))
}

key_stats.table <- matrix(key_stats, ncol = 6, byrow = T)

if (nrow(key_stats.table) < 10) {
  key_stats.table %>% kableExtra::kable("html", align = "c") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 18, full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  key_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 18, full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}

```

## Part II: Detailed statistics of key metrics {.tabset}

This part summarizes the detailed statistics of 5 key metrics that scMINER uses for filtration:

1. **nUMI**: number of total UMI counts per cell
2. **nFeature**: number of non-zero features/genes per cell
3. **pctMito**: percentage of UMI counts of mitochondrial genes, defined by '^MT-|^Mt-'
4. **pctSpikeIn**: percentage of UMI of spike-in RNAs, defined by '^ERCC-|^Ercc-'
5. **nCell**: number of cells per gene

### 1. nUMI
```{r cell_stats_numi, echo=FALSE}
nUMI_stats <- c(groupID, "Mean", "Median", "Minimum", "1st Quantile", "3rd Quantile", "Maximum")
nUMI_master <- data.frame(cellID = colnames(tmp.d), group = tmp.pd[, groupID], nUMI = colSums(tmp.d))
nUMI_master <- nUMI_master[nUMI_master$nUMI > 0,]

getStatistics_nUMI <- function(numeric_vector) {
  res <- round(as.numeric(summary(numeric_vector)))
  return(res[c(4,3,1,2,5,6)])
}

if (length(grps) > 1) {
  nUMI_stats <- c(nUMI_stats, "Combined", getStatistics_nUMI(nUMI_master$nUMI))
  
  for (i in 1:length(grps)) {
    nUMI_master.sel <- nUMI_master[nUMI_master$group == grps[i],]
    nUMI_stats <- c(nUMI_stats, grps[i], getStatistics_nUMI(nUMI_master.sel$nUMI))
  }
} else {
  nUMI_stats <- c(nUMI_stats, grps[1], getStatistics_nUMI(nUMI_master$nUMI))
}

nUMI_stats.table <- matrix(nUMI_stats, ncol = 7, byrow = T)

if (nrow(nUMI_stats.table) < 10) {
  nUMI_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  nUMI_stats.table %>% kableExtra::kable("html", align = "c") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}

```

```{r, fig.align='center', echo=FALSE} 
p <- ggplot(nUMI_master, aes(x=group, y=nUMI, fill=group)) + geom_violin(trim = TRUE) +
  geom_jitter(height = 0, width = 0.3, size = 0.1) + labs(x = "", y = "Number of UMIs") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title = element_text(size = 10, face = "bold", hjust = 0.5, color = "black"),
        axis.text.x = element_text(size = 10, face = "bold", hjust = 1, color = "black", angle = 45),
        axis.text.y = element_text(size = 8, face = "bold", hjust = 1, color = "black")) +
  stat_summary(fun.data = mean_sdl, geom = "point", shape = 16, size = 2, color = "red")

if (length(grps) == 1) {
  plotly::ggplotly(p, height = 600, width = 300)
} else if (length(grps) > 1 & length(grps) < 5) {
  plotly::ggplotly(p, height = 600, width = 150*length(grps))
} else if (length(grps) > 5 & length(grps) < 10) {
  plotly::ggplotly(p, height = 600, width = 120*length(grps))
} else if (length(grps) > 10) {
  plotly::ggplotly(p, height = 600, width = 100*length(grps))
}
```

### 2. nFeature
```{r cell_stats_nfeature, echo = FALSE}
nFeature_stats <- c(groupID, "Mean", "Median", "Minimum", "1st Quantile", "3rd Quantile", "Maximum")

nFeature_master <- data.frame(cellID = colnames(tmp.d), group = tmp.pd[, groupID], nFeature = colSums(tmp.d>0))
nFeature_master <- nFeature_master[nFeature_master$nFeature > 0,]

getStatistics_nFeature <- function(numeric_vector) {
  res <- round(as.numeric(summary(numeric_vector)))
  return(res[c(4,3,1,2,5,6)])
}

if (length(grps) > 1) {
  nFeature_stats <- c(nFeature_stats, "Combined", getStatistics_nFeature(nFeature_master$nFeature))
  
  for (i in 1:length(grps)) {
    nFeature_master.sel <- nFeature_master[nFeature_master$group == grps[i],]
    nFeature_stats <- c(nFeature_stats, grps[i], getStatistics_nFeature(nFeature_master.sel$nFeature))
  }
} else {
  nFeature_stats <- c(nFeature_stats, grps[1], getStatistics_nFeature(nFeature_master$nFeature))
}

nFeature_stats.table <- matrix(nFeature_stats, ncol = 7, byrow = T)

if (nrow(nFeature_stats.table) < 10) {
  nFeature_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  nFeature_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}

```

```{r, fig.align='center', echo=FALSE} 
p <- ggplot(nFeature_master, aes(x=group, y=nFeature, fill=group)) + geom_violin(trim = TRUE) +
  geom_jitter(height = 0, width = 0.3, size = 0.1) + labs(x = "", y = "Number of UMIs") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title = element_text(size = 10, face = "bold", hjust = 0.5, color = "black"),
        axis.text.x = element_text(size = 10, face = "bold", hjust = 1, color = "black", angle = 45),
        axis.text.y = element_text(size = 8, face = "bold", hjust = 1, color = "black")) +
  stat_summary(fun.data = mean_sdl, geom = "point", shape = 16, size = 2, color = "red")

if (length(grps) == 1) {
  plotly::ggplotly(p, height = 600, width = 300)
} else if (length(grps) > 1 & length(grps) < 5) {
  plotly::ggplotly(p, height = 600, width = 150*length(grps))
} else if (length(grps) > 5 & length(grps) < 10) {
  plotly::ggplotly(p, height = 600, width = 120*length(grps))
} else if (length(grps) > 10) {
  plotly::ggplotly(p, height = 600, width = 100*length(grps))
}
```

### 3. pctMito
```{r cell_stats_pctmito, echo = FALSE}
mito_genes <- row.names(tmp.d)[grepl(pattern = "^mt-|^MT-", x = row.names(tmp.d))]
pctMito_master <- data.frame(cellID = colnames(tmp.d), group = tmp.pd[, groupID], pctMito = round(Matrix::colSums(tmp.d[mito_genes, ]) / Matrix::colSums(tmp.d), 4))

getStatistics_pctMito <- function(numeric_vector) {
  res <- round(as.numeric(summary(numeric_vector)),4)
  return(res[c(4,3,1,2,5,6)])
}

pctMito_stats <- c(groupID, "Mean", "Median", "Minimum", "1st Quantile", "3rd Quantile", "Maximum")
if (length(grps) > 1) {
  pctMito_stats <- c(pctMito_stats, "Combined", getStatistics_pctMito(pctMito_master$pctMito))
  
  for (i in 1:length(grps)) {
    pctMito_master.sel <- pctMito_master[pctMito_master$group == grps[i],]
    pctMito_stats <- c(pctMito_stats, grps[i], getStatistics_pctMito(pctMito_master.sel$pctMito))
  }
} else {
  pctMito_stats <- c(pctMito_stats, grps[1], getStatistics_pctMito(pctMito_master$pctMito))
}

pctMito_stats.table <- matrix(pctMito_stats, ncol = 7, byrow = T)

if (nrow(pctMito_stats.table) < 10) {
  pctMito_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  pctMito_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}

```

```{r, fig.align='center', echo=FALSE} 
p <- ggplot(pctMito_master, aes(x=group, y=pctMito, fill=group)) + geom_violin(trim = TRUE) +
  geom_jitter(height = 0, width = 0.3, size = 0.1) + labs(x = "", y = "Number of UMIs") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title = element_text(size = 10, face = "bold", hjust = 0.5, color = "black"),
        axis.text.x = element_text(size = 10, face = "bold", hjust = 1, color = "black", angle = 45),
        axis.text.y = element_text(size = 8, face = "bold", hjust = 1, color = "black")) +
  stat_summary(fun.data = mean_sdl, geom = "point", shape = 16, size = 2, color = "red")

if (length(grps) == 1) {
  plotly::ggplotly(p, height = 600, width = 300)
} else if (length(grps) > 1 & length(grps) < 5) {
  plotly::ggplotly(p, height = 600, width = 150*length(grps))
} else if (length(grps) > 5 & length(grps) < 10) {
  plotly::ggplotly(p, height = 600, width = 120*length(grps))
} else if (length(grps) > 10) {
  plotly::ggplotly(p, height = 600, width = 100*length(grps))
}
```

### 4. pctSpikeIn
```{r cell_stats_pctspikein, echo = FALSE}
spikeIn_genes <- row.names(tmp.d)[grepl(pattern = "^Ercc-|^ERCC-", x = row.names(tmp.d))]
pctSpikeIn_master <- data.frame(cellID = colnames(tmp.d), group = tmp.pd[, groupID], pctSpikeIn = round(Matrix::colSums(tmp.d[spikeIn_genes, ]) / Matrix::colSums(tmp.d), 4))

getStatistics_pctSpikeIn <- function(numeric_vector) {
  res <- round(as.numeric(summary(numeric_vector)),4)
  return(res[c(4,3,1,2,5,6)])
}

pctSpikeIn_stats <- c(groupID, "Mean", "Median", "Minimum", "1st Quantile", "3rd Quantile", "Maximum")
if (length(grps) > 1) {
  pctSpikeIn_stats <- c(pctSpikeIn_stats, "Combined", getStatistics_pctSpikeIn(pctSpikeIn_master$pctSpikeIn))
  
  for (i in 1:length(grps)) {
    pctSpikeIn_master.sel <- pctSpikeIn_master[pctSpikeIn_master$group == grps[i],]
    pctSpikeIn_stats <- c(pctSpikeIn_stats, grps[i], getStatistics_pctSpikeIn(pctSpikeIn_master.sel$pctSpikeIn))
  }
} else {
  pctSpikeIn_stats <- c(pctSpikeIn_stats, grps[1], getStatistics_pctSpikeIn(pctSpikeIn_master$pctSpikeIn))
}

pctSpikeIn_stats.table <- matrix(pctSpikeIn_stats, ncol = 7, byrow = T)

if (nrow(pctSpikeIn_stats.table) < 10) {
  pctSpikeIn_stats.table %>% kableExtra::kable("html", align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  pctSpikeIn_stats.table %>% kableExtra::kable("html", align = "c") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}

```

```{r, fig.align='center', echo=FALSE} 
p <- ggplot(pctSpikeIn_master, aes(x=group, y=pctSpikeIn, fill=group)) + geom_violin(trim = TRUE) +
  geom_jitter(height = 0, width = 0.3, size = 0.1) + labs(x = "", y = "Number of UMIs") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title = element_text(size = 10, face = "bold", hjust = 0.5, color = "black"),
        axis.text.x = element_text(size = 10, face = "bold", hjust = 1, color = "black", angle = 45),
        axis.text.y = element_text(size = 8, face = "bold", hjust = 1, color = "black")) +
  stat_summary(fun.data = mean_sdl, geom = "point", shape = 16, size = 2, color = "red")

if (length(grps) == 1) {
  plotly::ggplotly(p, height = 600, width = 300)
} else if (length(grps) > 1 & length(grps) < 5) {
  plotly::ggplotly(p, height = 600, width = 150*length(grps))
} else if (length(grps) > 5 & length(grps) < 10) {
  plotly::ggplotly(p, height = 600, width = 120*length(grps))
} else if (length(grps) > 10) {
  plotly::ggplotly(p, height = 600, width = 100*length(grps))
}
```

### 5. nCell
```{r gene_stats_ncell, echo = FALSE}
nCell_stats <- c(groupID, "Mean", "Median", "Minimum", "1st Quantile", "3rd Quantile", "Maximum")

getStatistics_nCell <- function(d) {
  d <- d[Matrix::rowSums(d) > 0,]
  d <- d[,Matrix::colSums(d) > 0]
  
  cells_per_gene <- Matrix::rowSums(d != 0)
  res <- round(as.numeric(summary(cells_per_gene)))
  return(res[c(4,3,1,2,5,6)])
}

if (length(grps) > 1) {
  nCell_stats <- c(nCell_stats, "Combined", getStatistics_nCell(tmp.d))
  
  for (i in 1:length(grps)) {
    tmp.d.sel <- tmp.d[, tmp.pd[, groupID] == grps[i]]
    nCell_stats <- c(nCell_stats, grps[i], getStatistics_nCell(tmp.d.sel))
  }
} else {
  nCell_stats <- c(nCell_stats, grps[1], getStatistics_nCell(tmp.d))
}

nCell_stats.table <- matrix(nCell_stats, ncol = 7, byrow = T)

if (nrow(nCell_stats.table) < 10) {
  nCell_stats.table %>% kableExtra::kable("html", align = "c") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  nCell_stats.table %>% kableExtra::kable("html", align = "c") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, fixed_thead = T, html_font = "Arial") %>%
    row_spec(1, bold = T) %>%
    row_spec(2, bold = T, color = "red", background = "lightgreen") %>%
    column_spec(1, bold = T) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}
```

```{r, fig.align='center', echo=FALSE}
nCell_master <- data.frame()
if (length(grps) > 1) {
  for (i in 1:length(grps)) {
    tmp.d.sel <- tmp.d[, tmp.pd[, groupID] == grps[i]]
    tmp.d.sel <- tmp.d.sel[Matrix::rowSums(tmp.d.sel) > 0,]
    tmp.d.sel <- tmp.d.sel[,Matrix::colSums(tmp.d.sel) > 0]

    cells_per_gene <- Matrix::rowSums(tmp.d.sel != 0)
    master.sel <- data.frame(geneSymbol = row.names(tmp.d.sel), group = grps[i], nCell = cells_per_gene)
    
    if (i == 1) {
      nCell_master <- master.sel
    } else {
      nCell_master <- rbind(nCell_master, master.sel)
    }
  }
} else {
  tmp.d.sel <- tmp.d.sel[Matrix::rowSums(tmp.d.sel) > 0,]
  tmp.d.sel <- tmp.d.sel[,Matrix::colSums(tmp.d.sel) > 0]
  
  cells_per_gene <- Matrix::rowSums(tmp.d.sel != 0)
  nCell_master <- data.frame(geneSymbol = row.names(tmp.d.sel), group = grps[1], nCell = cells_per_gene)
}

p <- ggplot(nCell_master, aes(x=group, y=nCell, fill=group)) + geom_violin(trim = TRUE) +
  geom_jitter(height = 0, width = 0.3, size = 0.1) + labs(x = "", y = "Number of cells per gene") +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"),
        legend.position = "none",
        axis.title = element_text(size = 10, face = "bold", hjust = 0.5, color = "black"),
        axis.text.x = element_text(size = 10, face = "bold", hjust = 1, color = "black", angle = 45),
        axis.text.y = element_text(size = 8, face = "bold", hjust = 1, color = "black"))

if (length(grps) == 1) {
  plotly::ggplotly(p, height = 600, width = 300)
} else if (length(grps) > 1 & length(grps) < 5) {
  plotly::ggplotly(p, height = 600, width = 150*length(grps))
} else if (length(grps) > 5 & length(grps) < 10) {
  plotly::ggplotly(p, height = 600, width = 120*length(grps))
} else if (length(grps) > 10) {
  plotly::ggplotly(p, height = 600, width = 100*length(grps))
}
```


## Part III: Detailed statistics per cell and gene 

This part provides the detailed statistics of each cell and gene.

<div class = "row">
<div class= "col-md-4">
```{r plot_gene_summary_table, echo = F}
fd_t <- data.frame(tmp.fd, pctCell = round(tmp.fd[, "nCell"] / ncol(tmp.d), 4))
fd_t %>% kableExtra::kable("html", align = "l", row.names = F, caption = "Stats per gene") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"), font_size = 14) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Arial") %>%
  kableExtra::scroll_box(width = "100%", height = "500px") %>%
  row_spec(1, bold = T)
```
</div>

<div class= "col-md-8">
```{r plot_cell_summary_table, echo = F}
pd_t <- tmp.pd
pd_t %>% kableExtra::kable("html", align = "l", row.names = F, caption = "Stats per cell") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"), font_size = 14) %>%
  kableExtra::kable_classic(full_width = F, html_font = "Arial") %>%
  kableExtra::scroll_box(width = "100%", height = "500px") %>%
  row_spec(1, bold = T)
```
</div>
</div>

## Part IV: Filtration cutoffs by scMINER

This part provides the cutoffs estimated automatically by scMINER based on Median Â± 3 * MAD (maximum absolute deviance), and the pseudo-filtration statistics on both genes and cells with these cutoffs.

```{r default_cutoff, echo=FALSE,results='asis'}
## calculate the default cutoffs
gene.nCell_min = max(floor(0.005 * dim(tmp.d)[2]), 1)
gene.nCell_max = Inf
cell.nUMI_min = max(floor(exp(median(log(tmp.pd$nUMI)) - 3 * mad(log(tmp.pd$nUMI)))), 100)
cell.nUMI_max = ceiling(exp(median(log(tmp.pd$nUMI)) + 3 * mad(log(tmp.pd$nUMI))))
cell.nFeature_min = max(floor(exp(median(log(tmp.pd$nFeature)) - 3 * mad(log(tmp.pd$nFeature)))), 50)
cell.nFeature_max = Inf
cell.pctMito_min = 0
cell.pctMito_max = round(median(tmp.pd$pctMito) + 3 * mad(tmp.pd$pctMito), 4)
cell.pctSpikeIn_min = 0
cell.pctSpikeIn_max = round(median(tmp.pd$pctSpikeIn) + 3 * mad(tmp.pd$pctSpikeIn), 4)

para_table <- matrix(c(gene.nCell_min, cell.nUMI_min, cell.nFeature_min, cell.pctMito_min, cell.pctSpikeIn_min, gene.nCell_max, cell.nUMI_max, cell.nFeature_max, cell.pctMito_max, cell.pctSpikeIn_max), ncol = 5, byrow = T)
rownames(para_table) <- c("Minimum", "Maximum")
colnames(para_table) <- c("# Cells per gene (nCell)", "# UMIs per cell (nUMI)", "# Features per cell (nFeature)", "% Mitochondrial genes (pctMito)", "% Spike-In RNAs (pctSpikeIn)")

## filtering: genes
fd_pre <- tmp.fd
gene_qualified <- row.names(fd_pre)[fd_pre$nCell >= gene.nCell_min & fd_pre$nCell <= gene.nCell_max]

gene_table <- matrix(c("Metrics", "Gene_total", "Gene_failed", "Gene_passed",
                       "nCell", nrow(tmp.d), paste0((nrow(tmp.d)-length(gene_qualified)),"(", round((nrow(tmp.d)-length(gene_qualified))/nrow(tmp.d)*100, 2), "%)"),
                       paste0(length(gene_qualified),"(", round(length(gene_qualified)/nrow(tmp.d)*100, 2), "%)")), ncol = 2, byrow = FALSE)

## filtering: cells
cell_qualified.nUMI <- which((tmp.pd$nUMI >= cell.nUMI_min) & (tmp.pd$nUMI <= cell.nUMI_max))
cell_qualified.nFeature <- which((tmp.pd$nFeature >= cell.nFeature_min) & (tmp.pd$nFeature <= cell.nFeature_max)); cell_qualified.combined <- intersect(cell_qualified.nUMI, cell_qualified.nFeature)
cell_qualified.pctMito <- which((tmp.pd$pctMito >= cell.pctMito_min) & (tmp.pd$pctMito <= cell.pctMito_max)); cell_qualified.combined <- intersect(cell_qualified.combined, cell_qualified.pctMito)
cell_qualified.pctSpikeIn <- which((tmp.pd$pctSpikeIn >= cell.pctSpikeIn_min) & (tmp.pd$pctSpikeIn <= cell.pctSpikeIn_max)); cell_qualified.combined <- intersect(cell_qualified.combined, cell_qualified.pctSpikeIn)
cell_qualified <- colnames(tmp.pd)[cell_qualified.combined]

cell_table <- matrix(c("Metrics", "Cell_total", "Cell_failed", "Cell_passed",
                       "Combined", ncol(tmp.d),
                       paste0((ncol(tmp.d)-length(cell_qualified.combined)), "(", round(((ncol(tmp.d)-length(cell_qualified.combined))/ncol(tmp.d)*100), 2), "%)"),
                       paste0(length(cell_qualified.combined), "(", round(length(cell_qualified.combined)/ncol(tmp.d)*100, 2), "%)"),
                       "nUMI", ncol(tmp.d),
                       paste0((ncol(tmp.d)-length(cell_qualified.nUMI)), "(", round(((ncol(tmp.d)-length(cell_qualified.nUMI))/ncol(tmp.d)*100), 2), "%)"),
                       paste0(length(cell_qualified.nUMI), "(", round(length(cell_qualified.nUMI)/ncol(tmp.d)*100, 2), "%)"),
                       "nFeature", ncol(tmp.d),
                       paste0((ncol(tmp.d)-length(cell_qualified.nFeature)), "(", round(((ncol(tmp.d)-length(cell_qualified.nFeature))/ncol(tmp.d)*100), 2), "%)"),
                       paste0(length(cell_qualified.nFeature), "(", round(length(cell_qualified.nFeature)/ncol(tmp.d)*100, 2), "%)"),
                       "pctMito", ncol(tmp.d),
                       paste0((ncol(tmp.d)-length(cell_qualified.pctMito)), "(", round(((ncol(tmp.d)-length(cell_qualified.pctMito))/ncol(tmp.d)*100), 2), "%)"),
                       paste0(length(cell_qualified.pctMito), "(", round(length(cell_qualified.pctMito)/ncol(tmp.d)*100, 2), "%)"),
                       "pctSpikeIn", ncol(tmp.d),
                       paste0((ncol(tmp.d)-length(cell_qualified.pctSpikeIn)), "(", round(((ncol(tmp.d)-length(cell_qualified.pctSpikeIn))/ncol(tmp.d)*100), 2), "%)"),
                       paste0(length(cell_qualified.pctSpikeIn), "(", round(length(cell_qualified.pctSpikeIn)/ncol(tmp.d)*100, 2), "%)")), ncol= 6, byrow = F)

para_table %>% kableExtra::kable("html", align = "l", caption = "<b>Filtration cutoffs estimicated by scMINER<\b>") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped"), font_size = 14) %>%
  kableExtra::kable_classic(full_width = T, html_font = "Arial") %>%
  kableExtra::column_spec(1, bold = T) %>%
  kableExtra::row_spec(1, bold = T)
```

<div class = "row">
<div class = "col-md-3">
```{r plot_gene_dist, echo = F}
gene_table %>% kable("html", align = "l", caption = "<b>Gene filtration statistics<\b>") %>%
  kableExtra::kable_styling(bootstrap_options = "striped", font_size = 14) %>%
  kableExtra::kable_classic(full_width = T, html_font = "Arial") %>%
  kableExtra::column_spec(2, bold = T, color = "red") %>%
  kableExtra::row_spec(1, bold = T)
```
</div>

<div class = "col-md-9">
```{r plot_gene_num, echo = F}
cell_table %>% kable("html", align = "l", caption = "<b>Cell filtration statistics<\b>") %>%
  kableExtra::kable_styling(bootstrap_options = "striped", font_size = 14) %>%
  kableExtra::kable_classic(full_width = T, html_font = "Arial") %>%
  kableExtra::column_spec(2, bold = T, color = "red") %>%
  kableExtra::row_spec(1, bold = T)
```
</div>
</div>
