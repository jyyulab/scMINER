---
title: "QC report for network generated by SJARACNe"
output: 
  html_document:
    toc: true
params:
    obj:
      value: x
---

```{r include=FALSE}
library(kableExtra)
library(igraph)
```

```{r echo=FALSE}
deg <- igraph::degree(obj, mode = "out")
source_list <- names(deg)[which(deg > 0)]
c1 <- igraph::components(obj)
if (weighted == TRUE) {edge_weight <- igraph::E(obj)$weight} else {edge_weight <- NULL}
```


## Part I: Basic statistics

This network is `r ifelse(directed == TRUE,'a directed','an undirected')` and `r ifelse(weighted == TRUE,'weighted','unweighted')` network, 
which contains `r length(V(obj))` nodes and `r length(E(obj))` edges.
This network contains `r c1$no` connected components, in which the largest component size is `r c1$csize`.
In total `r length(source_list)` nodes are possible drivers.


```{r include=FALSE}
net_statistic <- list() # graph level statistics
net_detail <- list() # node level statistics

## global network
net_statistic$graph_density <- igraph::edge_density(obj, loops = F);  # The density of a graph is the ratio of the number of edges and the number of possible edges.
net_statistic$graph_diameter <- igraph::diameter(obj, directed = directed, weights = NULL) #  The diameter of a graph is the length of the longest geodesic.
net_statistic$mean_distance <- igraph::mean_distance(obj, directed = directed, weights = NA) # This is the average length of the shortest paths between all pairs of vertices.
  
## nodes
# degree centrality: the number of edges for each vertex
dc_all <- igraph::centr_degree(obj, mode = "all", normalized = TRUE)
net_statistic$degreeCentrality_all <- dc_all$centralization
net_detail$degreeCentrality_all <- dc_all$res
if (directed == TRUE) {
  dc_out <- igraph::centr_degree(obj, mode = "out", normalized = TRUE)
  net_statistic$degreeCentrality_out <- dc_out$centralization
  net_detail$degreeCentrality_out <- dc_out$res
  
  dc_in <- igraph::centr_degree(obj, mode = "in", normalized = TRUE)
  net_statistic$degreeCentrality_in <- dc_in$centralization
  net_detail$degreeCentrality_in <- dc_in$res
}

# betweenness centrality: the number of the shortest paths that pass through the vertex
bc <- igraph::centr_betw(obj, directed = directed, normalized = TRUE)
net_statistic$betweennessCentrality <- bc$centralization
net_detail$betweennessCentrality <- bc$res

# closeness centrality: the average of the shortest path length from the node to every other node in the network
cc_all <- igraph::centr_clo(obj, mode = "all", normalized = TRUE)
net_statistic$closenessCentrality_all <- cc_all$centralization
net_detail$closenessCentrality_all <- cc_all$res
if (directed == TRUE) {
  cc_out <- igraph::centr_clo(obj, mode = "out", normalized = TRUE)
  net_statistic$closenessCentrality_out <- cc_out$centralization
  net_detail$closenessCentrality_out <- cc_out$res
  
  cc_in <- igraph::centr_clo(obj, mode = "in", normalized = TRUE)
  net_statistic$closenessCentrality_in <- cc_in$centralization
  net_detail$closenessCentrality_in <- cc_in$res
}

# eigenvector centrality: indicates the nodes near the most significant nodes or communityes, mainly for undirected networks
ec <- igraph::centr_eigen(obj, directed = directed, normalized = TRUE)
net_statistic$eigenVector_centrality <- ec$centralization
net_detail$eigenVector_centrality <- ec$vector

# hub score: indicates the nodes near the most significant nodes or communities, mainly for directed networks
hs <- igraph::hub_score(obj, weights = edge_weight)
net_statistic$hubScore_centrality <- hs$value
net_detail$hubScore_centrality <- hs$vector

# pagerank: indicates the nodes near the most significant nodes or communities, for both undirected and directed networks
pr <- igraph::page_rank(obj, directed = directed, weights = edge_weight)
net_statistic$pageRank_centrality <- pr$value
net_detail$pageRank_centrality <- pr$vector


dt <- as.data.frame(unlist(net_statistic))
colnames(dt) <- 'Value'
dt$Note <- NULL
if ('graph_density' %in% rownames(dt)) {dt['graph_density', 'Note'] <- 'the ratio between the edges present in a graph and the maximum number of edges that the graph can contain'}
if ('graph_diameter' %in% rownames(dt)) {dt['graph_diameter', 'Note'] <- 'the maximum distance between the pair of vertices'}
if ('mean_distance' %in% rownames(dt)) {dt['mean_distance', 'Note'] <- 'the average length of the shortest paths between all pairs of vertices (both ways for directed graphs)'}

if ('degreeCentrality_all' %in% rownames(dt)) {dt['degreeCentrality_all', 'Note'] <- 'the graph-level centrality index according to the all-degrees of vertices'}
if ('degreeCentrality_out' %in% rownames(dt)) {dt['degreeCentrality_out', 'Note'] <- 'the graph-level centrality index according to the out-egrees of vertices'}
if ('degreeCentrality_in' %in% rownames(dt)) {dt['degreeCentrality_in', 'Note'] <- 'the graph-level centrality index according to the in-degrees of vertices'}

if ('betweennessCentrality' %in% rownames(dt)) {dt['betweennessCentrality', 'Note'] <- 'the graph-level centrality index according to the betweenness of vertices'}

if ('closenessCentrality_all' %in% rownames(dt)) {dt['closenessCentrality_all', 'Note'] <- 'the graph-level centrality index according to the closeness of vertices (all mode)'}
if ('closenessCentrality_out' %in% rownames(dt)) {dt['closenessCentrality_out', 'Note'] <- 'the graph-level centrality index according to the closeness of vertices (out mode)'}
if ('closenessCentrality_in' %in% rownames(dt)) {dt['closenessCentrality_in', 'Note'] <- 'the graph-level centrality index according to the closeness of vertices (in mode)'}

if ('eigenVector_centrality' %in% rownames(dt)) {dt['eigenVector_centrality', 'Note'] <- 'the graph-level centrality index according to the eigenvector centrality of vertices'}
if ('hubScore_centrality' %in% rownames(dt)) {dt['hubScore_centrality', 'Note'] <- 'the corresponding eigenvalue of the calculated principal eigenvector'}
if ('pageRank_centrality' %in% rownames(dt)) {dt['pageRank_centrality', 'Note'] <- 'the eigenvalue corresponding to the eigenvector with the page rank scores. It should be exactly one.'}
```

```{r echo=FALSE}
kableExtra::kable(dt, align = "l") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  kableExtra::scroll_box(width = "100%", height = "100%")
```

## Part II: Detailed statistics for drivers

Detailed statistics for all `r length(source_list)` drivers. 

```{r echo=FALSE}
dt <- do.call(cbind, net_detail)
dt1 <- dt[source_list,]
if (nrow(dt1) < 20) {
  kableExtra::kable(dt1, align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
    kableExtra::scroll_box(width = "100%", height = "100%")
} else {
  kableExtra::kable(dt1, align = "c") %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
    kableExtra::scroll_box(width = "100%", height = "500px")
}

```

## Part III: Driver's target size checking

```{r echo=FALSE, fig.width=8, fig.height=8}
par(mar=c(6,6,6,8))
d_out <- igraph::degree(obj, mode = 'all')
a <- hist(d_out, breaks = 20, xlab = 'Degree', cex.lab = 1.2, cex.axis = 1.2, cex.main = 1.2,
     main = sprintf('Density plot of degree distribution for all nodes \n (network node:%d, network edge:%d)', length(V(obj)), length(E(obj))));
d1 <- density(d_out)
mm <- max(a$counts)/max(d1$y); mm1 <- seq(0, max(d1$y), length.out = 5); mm2 <- format(mm1, scientific = TRUE, digits = 3); mm2[1] <- '0';
lines(x = d1$x, y = d1$y*mm, col = grDevices::rgb(t(grDevices::col2rgb('red')/255), alpha = 0.5), lwd = 1.5)
axis(side = 4, at = mm*mm1, labels = mm2, las = 2);
mtext(side = 4, line = 6, 'Density', cex=1.2)
#
d_out <- igraph::degree(obj, mode = 'out')[source_list]
if(length(d_out)>10){
  a <- hist(d_out, breaks = 20, xlab = 'Degree', cex.lab = 1.2, cex.axis = 1.2, cex.main = 1.2,
            main = sprintf('Density plot of target size for all %s drivers \n (Size from %s to %s; mean Size: %s, median Size: %s )', length(source_list), min(d_out), max(d_out), format(mean(d_out), digits = 5), median(d_out)));
  d1 <- density(d_out)
  mm <- max(a$counts)/max(d1$y); mm1 <- seq(0, max(d1$y), length.out = 5); mm2 <- format(mm1, scientific = TRUE, digits = 3); mm2[1] <- '0';
  lines(x = d1$x, y = d1$y*mm, col = grDevices::rgb(t(grDevices::col2rgb('red')/255), alpha = 0.5), lwd = 1.5)
  axis(side = 4, at = mm*mm1, labels = mm2, las = 2);
  mtext(side = 4, line = 6, 'Density', cex = 1.2)
} else {
  print(d_out)
}
```

## Part IV: Scale free distribution checking

```{r echo=FALSE, fig.width=8, fig.height=8}
fp1 <- igraph::degree_distribution(obj)
dd <- as.data.frame(cbind(k = 1:max(igraph::degree(obj)), pk = fp1[-1]))
dd$pk <- dd$pk + 1 / length(V(obj))
r2 <- lm(log10(dd$pk) ~ log10(dd$k))
r3 <- summary(r2)$adj.r.squared
if (length(dd$k) > 100) {
  plot(pk ~ k, data = dd, log = 'xy', main = sprintf('R2:%s', format(r3, digits = 4)), pch = 16, col = grDevices::rgb(t(grDevices::col2rgb('dark grey')/255), alpha = 0.8), cex.lab = 1.4, cex.axis = 1.2)
} else {
  plot(pk ~ k, data = dd, log = 'xy', main = sprintf('R2:%s', format(r3, digits = 4)), pch = 16, col = grDevices::rgb(t(grDevices::col2rgb('black')/255), alpha = 0.8), cex.lab = 1.4, cex.axis = 1.2)
}
abline(a=r2$coefficients[1],b=r2$coefficients[2],col=grDevices::rgb(t(grDevices::col2rgb('red')/255),alpha=0.5),lwd=2)
```



