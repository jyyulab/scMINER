{
  "0": {
    "id": "0",
    "title": "Installation",
    "content": "#Installation Dependencies scMINER is depend on python3 and R, including three individual modules: scMINER R package, MICA and SJARACNe python package. Local installation: Install scMINER from github: #install dev_tool first install.packages(devtools) devtools::install_github(&quot;jyyulab/scMINER&quot;) #or devtools::install_local(&#39;scMINER_0.0.1.tar.gz&#39;) Install MICA from source: $ git clone https://github.com/jyyulab/MICA $ cd MICA $ python setup.py install Install SJARACNe from source: $ git clone https://github.com/jyyulab/SJARACNe $ cd SJARACNe $ python setup.py install",
    "url": "http://localhost:4000/docs/Installation.html",
    "relUrl": "/docs/Installation.html"
  },
  "1": {
    "id": "1",
    "title": "Clustering with MICA",
    "content": "Clustering Analysis with MICA MICA(Mutual Information based Clustering Analysis) is a nonlinear clustering analysis tool designed for scRNA-seq data. To install MIE (Mutual inforamtion estimator for distance matrix generation, module required for MICA) and MICA, please refer our MIE and MICA github page. Overview Preprocssing Basic usage On local host On LSF MICA Outputs Useful parameters Visualize with U-map or t-SNE Try other dimension reduction methods Try other distance matrix calculation methods Post-clustering analysis Overview MICA is a non-linear clustering analysis algorithm that incorporated: Fast mutual information estimation to construct cell-cell similarity matrix. Multidimensional scaling for stabilized dimension reduction. Consensus clustering from multiple individual runs of kmeans to generate robust clustering results. Preprocssing MICA module was implemented in python, which only includes clustering analysis. For preprocessing, MICA is compatitble with most published scRNA-seq preprocessing pipeline. However, we highly recommend users to follow our preprocessing framework utilizing scMINER R package.For detailed information, please see complementary tutorial in tab Step by step demo with PBMC data. MICA only takes cell by gene txt file as input, we strongly recommend using generateMICAinput function to convert your input data to MICA standard input text file in R. Basic usage MICA incorprated Common workflow languages for portablity and scalability purposes. We adopted cwltool as runner for local host and cwlexec for LSF platform. While it might introduce some differences for intermediate files, final results will not be affected. To ensure a user friendly interface, we designed function generate_MICA_rmd to help users generate complimentary commands for MICA execution. Below are two examples when running MICA on local or LSF host respectively. On local host To perform MICA on local host, you need to specify host= &quot;local&quot; scMINER::generate_MICA_cmd(save_sh_at, #path to save shell script input_file, #your MICA input file project_name, num_cluster, #a vector of numerical number output_path, #path to MICA output host=&quot;local&quot;, visualization=&quot;tsne&quot; #or &quot;umap&quot;) or, you can create your own shell script as: #!/usr/bin/env bash mica local -i ./test_data/inputs/PBMC_Demo_MICA_input_mini.txt -p &quot;test_local&quot; -k 3 4 -o ./test_data/outputs/test_local/ To execute your shell script locally, you can sh your_mica_cmd.sh On LSF To perform MICA on LSF, you have to specify host=&quot;lsf&quot;, which queue to submit your job queue=[your_queue], and also memory requested for MICA. scMINER::generateMICAcmd(save_sh_at, #path to save shell script input_file, #your MICA input file project_name, num_cluster, #a vector of numerical number output_path, host=&quot;lsf&quot;, #or local queue=NULL, #your queue to submit the job memory=NULL, #specify if you use LSF, a vector of 4 numerical number dim_reduction_method=&quot;MDS&quot;, visualization=&quot;tsne&quot;) Or, you can create your shell script as: #!/usr/bin/env bash mica LSF -i ./test_data/inputs/PBMC_Demo_MICA_input_mini.txt -r 8000 12000 12000 16000 -q [your queue] -p &quot;test_local&quot; -k 3 4 -o ./test_data/outputs/test_local/ To execute your shell script on LSF, we suggest bsub &lt; your_mica_cmd.sh MICA Outputs Each assigned number of k will output one folder containing following files: [Project_name]_k[number]_tsne.png –visualization of clustering result (default as tSNE) [Project_name]_dist.h5 – h5 file containing distance matrix calculated. [Project_name]_mds.pdf – pdf file of t-SNE visualization of mds transformed distance matrix, with perplexity set to 30 [Project_name]_tsne_ClusterMem.txt – txt file containing visualization coordinates and clustering labels Useful parameters Visualize with U-map or t-SNE MICA incorporate UMAP as optional clustering visualization, with min_dist parameter set to 0.25, this controls how points packed together. Low values of min_dist will result in clumpier embeddings. You can tune this parameter with : --min_dist 0.1 (or other number ranging from 0-1) tSNE visualization is our default visualization method in the pipeline, if you want to use t-SNE, just set : --visualization tsne (all lower cap, no &quot;-&quot;) and you can also set parameter (perplexity) for tsne using -pp 20 (or any other integers larger than 5) Try other dimension reduction methods MICA also incorporated other dimension reduction methods such as pca or lpl, you can use them via adding parameter: -dr PCA (or: MDS | PCA | LPL | LPCA) Try other distance matrix calculation methods MICA also incorporated other dimension reduction methods such as pca or lpl, you can use them via adding parameter: --dist MI (or: euclidean | spearman | pearson) Post-clustering analysis We offer a handful of useful functions in scMINER ranging from visualization to driver estimation, to help you explore your scRNA-seq data in a system biology way after clustering.",
    "url": "http://localhost:4000/docs/MICA.html",
    "relUrl": "/docs/MICA.html"
  },
  "2": {
    "id": "2",
    "title": "Advanced analysis",
    "content": "Advanced analysis Here we demonstrate our advanced downstream analysis pipeline using PBMC (10x genmomics) scRNA-seq data after completing driver estimation following tutorial under tab step by step demo with PBMC data Network visualization scMINER incorporates a handful of network visualization/exploration function adapted from NetBID2, a powerful tool for data-driven network-based bayesian Inference of drivers. scMINER also offered several wrapper of basic visualization functions in NetBID2 for better usability. Single network visualization In scMINER, you can visualize your driver and its targets by function draw.network. It was adapted from function draw.targetNet and draw.targetNet.TWO from NetBID2. This function can help visualize a driver’s targets as well as the relationship(edge) between source and target genes, by taking Mutual information as edge weight, and spearman correlation as direction. draw.network(net1 = net,src1 = &quot;LEF1&quot;, #driver name ifSymbol = TRUE, #if your source driver name is a Symbol ifWeighted = TRUE, #if plot edge with weight and direction pdf_name = &quot;LEF1.TF_in_NaiveT_network.pdf&quot;, n_layer=4) Subnetwork structure visualization between two networks You can also use draw.network function to visualize two networks and their subnetwork structure. This could be used for identify common targets from two top driver from the same network, or identify network rewiring event of same driver in different cell type network. Here below is an example for later case. draw.network(net1 = net1,net2 = net2, src1 = &quot;BATF&quot;,src2=&quot;BATF&quot;, source1_z=-3, source2_z=4, ifSymbol = TRUE,ifWeighted = TRUE, pdf_name = &quot;BATF.TF_in_2_network.pdf&quot;, n_layer=4) Biological function anlaysis for drivers Gene set overlap with targets visualized by bubble plot When picking candidate hidden drivers, it would be extremly helpful if we could identify the potential biological pathways this driver regulates. With SJARACNe infered network, we can assess as well as visualizethe overlap between knowledge-based gene sets and driver’s targets via function draw.bubblePlot. This function returns a bubble plot indiating results from Fisher exact test. TF_list &lt;- TopMasterRegulator(DAG_result = DAG_result, celltype=&quot;NaiveT&quot;, n = 10, degree_filter = c(50,800)) draw.bubblePlot(driver_list= TF_list, show_label=DAG_result[TF_list,&quot;geneSymbol&quot;], Z_val=DAG_result[TF_list,&quot;Z_NaiveT&quot;], driver_type=NULL, target_list=net1$target_list, transfer2symbol2type=tbl, bg_list=fData(eset.12k)$geneSymbol, min_gs_size=50,max_gs_size=600, top_geneset_number=8,top_driver_number=10,use_gs = c(&quot;H&quot;,&quot;C5&quot;,&quot;CP:KEGG&quot;), pdf_file = &#39;NaiveT_bubblePlot.pdf&#39;, main=&#39;Bubbleplot for top driver targets in NaiveT&#39;) ## R session info R version 3.5.0 (2018-04-23) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS High Sierra 10.13.6 Matrix products: default BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] parallel stats graphics grDevices utils datasets methods base other attached packages: [1] bindrcpp_0.2.2 Biobase_2.42.0 BiocGenerics_0.28.0 dplyr_0.7.8 [5] RColorBrewer_1.1-2 ggplot2_3.1.0 reshape2_1.4.3 loaded via a namespace (and not attached): [1] Rcpp_1.0.0 rstudioapi_0.8 bindr_0.1.1 magrittr_1.5 tidyselect_0.2.5 [6] munsell_0.5.0 colorspace_1.3-2 R6_2.3.0 rlang_0.3.0.1 stringr_1.3.1 [11] plyr_1.8.4 tools_3.5.0 grid_3.5.0 gtable_0.2.0 withr_2.1.2 [16] digest_0.6.18 yaml_2.2.0 lazyeval_0.2.1 assertthat_0.2.0 tibble_1.4.2 [21] crayon_1.3.4 zip_1.0.0 purrr_0.2.5 glue_1.3.0 labeling_0.3 [26] openxlsx_4.1.0 stringi_1.2.4 compiler_3.5.0 pillar_1.3.1 scales_1.0.0 [31] pkgconfig_2.0.2",
    "url": "http://localhost:4000/docs/PBMC-12k-network.html",
    "relUrl": "/docs/PBMC-12k-network.html"
  },
  "3": {
    "id": "3",
    "title": "Step by step user guidance",
    "content": "Analysis on PBMC(12k) scRNA-seq data via scMINER Demo data Step 1: Data preprocessing Read 10x genomics data Quality control and data filtering Normalization and transformation Step 2: Perform clustering analysis via MICA Generate MICA input and command Step 3: Cell type annotation after clustering Read MICA output Marker gene visualization Assign cell type to cluster Step 4: Network generation via SJARACNe Generate SJARACNe input Run SJARACNe Step 5: Identify cell type specific hidden driver Calculate activity Driver estimation by differential activity analysis R session Info Demo data Here we demonstrate our pipeline using PBMC (10x genmomics) scRNA-seq data. Full data contains 68k cells, in order to provide a quicker guidance, we’ve down sampled this data to 12k cells. Original data website can be downloaded here. Step 1: Data preprocessing Read 10x genomics data Read 10x genomics data with function in scMINER package. This function could help read either 10x genomics standard output, as well as other text files types by passing arguments to read.delim(). If set CreateSparseEset=T This will help create a Sparse matrix object using Expressionset prototype, otherwise, it will create a list Object that stores expression data, feature data and sample data in different slots. If add.meta=T, then corresponding sample info such as total number of UMI will be calcualated and outputed. Here, since data was downsampled and not in standard 10x genomics output format, we defined is.10x=F and add.meta=F. d.12k &lt;- readscRNAseqData(file=&quot;PBMC_demo_input.txt&quot;,is.10x = F,CreateSparseEset = FALSE, add.meta=F) After confriming your data was loaded properly, you can now create Sparse Matrix expression by using CreateSparseEsetfunction: eset.12k&lt;-CreateSparseEset(data=d.12k,feature.data = d.68k$feature.data,add.meta = T) Quality control and data filtering Quality control assessments could be done using draw.scRNAseq.QC step, this will output a html report generated through Rmarkdown, which includes essential figures at both gene and cell level. Suggested cutoff will be returned as a list if output.cutoff was set to be TRUE. cutoffs &lt;- draw.scRNAseq.QC(SparseEset=eset.12k, project.name = &quot;PBMC12k&quot;, plot.dir = &quot;./QC/&quot;, group = &quot;group&quot;, # this indicate which meta data information will be use in x axis to group violin plots output.cutoff = TRUE) The first plot is a histogram which helps visualize distribution of expressed genes among each cells. The second plot help visualize total UMI count, and total number of gene expressed in violin plots. Third plot visualizes mitochondria percentage, and spike-in percentage for each cell in scatter plot. Then you could run cell filtering with function preMICA.filtering, if input cutoffs was directly from the output of draw.scRNAseq.QC functon. You could also manually change cutoffs by re-assign thresholds in cutoffs list, e.g. set cutoffs$umi_cf_hi&lt;-Inf means do not do filtering on outliers which have high total UMI value. cutoffs$umi_cf_hi&lt;-Inf #only filter on low total number of UMI eset.sel&lt;-preMICA.filtering(SparseEset = eset.12k,cutoffs = cutoffs) Normalization and transformation In scMINER package, we don’t provide methods to conduct normalizaton. You can use your own prefered normalization method. However, we highly recommend to do CPM and log2 transformation for MICA input. norm = 1e6 exp.norm &lt;- sweep(exprs(eset.sel), 2, norm/unname(Matrix::colSums(exprs(eset.sel))), &#39;*&#39;) # log transformation # Required for MICA exp.log2 &lt;- log(exp.norm+1,base=2) # save as SparseEset eset.norm &lt;- CreateSparseEset(data=exp.log2,meta.data = pData(eset.sel),feature.data = fData(eset.sel),add.meta = F) Step 2: Perform clustering analysis via MICA MICA is implemented in Python. If you would like to install MICA, please refer to MICA github page. There are several parameters for you to choose when running MICA. A more comprehensive tutorial could be found here. Here we suggests saving your working directory prior to running MICA. Generate MICA input and command After reviewing all visualization and finished filtering, you can go ahead and generate clustering (MICA) input with function generateMICAinput. This function take a expression matrix as input, and outputs a cell by gene txt file. Please note that you should always feed MICA the log or log2 transformed data. generateMICAinput(data= exp.log2 ,filename=&quot;PBMC12k_MICA_input.txt&quot;) We also offer a function to generate MICA command without writing your own scripts. If you set host=lsf, then you need to define queue (required), and memory (optional). In num_cluster, you can input a vector of number of K to achieve clustering membership for different k simultaneously. generate_MICA_cmd(save_sh_at = &quot;./PBMC12k/&quot;, input_file = &quot;./PBMC12k/PBMC12k_MICA_input.txt&quot;, project_name = &quot;PBMC12k&quot;, num_cluster = c(8,9,10,12,13,14,15), host = &quot;lsf&quot;, queue = [your_queue_name], output_path = &quot;./&quot;,queue = &quot;standard&quot;) Step 3: Cell type annotation after clustering First, after clustering via MICA, you can load MICA output (in .txt) as well as input expression matrix in R under an expressionSet. This is going to be the major data structure we used for downstream analysis in R. Note: All functions are designed compatible for both expressionSet and SparseExpressionSet Read MICA output Users can start with one MICA membership and study your optimal number of cluster with cell type specific markers. eset.12k &lt;- readMICAoutput(Obj = d.sel,load_clust_label = TRUE, output_file = &quot;MICA/PBMC12k_k8_tsne_ClusterMem.txt&quot;) To visualize MICA label or other metadata, one can use function MICAplot. Users are required to specify X and Y cordinates in this function. This function will output a ggplot style visualization. Other meta data could also be visulized with this function, via changing label parameter. MICAplot(input_eset = eset.12k,visualize = &#39;tSNE&#39;,X = &quot;X&quot;,Y=&quot;Y&quot;,label = &quot;label&quot;,pct = 0.5) Marker gene visualization Picked marker genes could be visualized on t-SNE scatterplot, violin plot or heatmap via function feature_highlighting, feature_vlnplot and feature_heatmap. This will not only help cluster annotation, but also identify optimal number of clusters as well. gn.sel&lt;-c(&quot;CD3D&quot;,&quot;CD27&quot;,&quot;IL7R&quot;,&quot;SELL&quot;,&quot;CCR7&quot;,&quot;IL32&quot;,&quot;GZMA&quot;, &quot;GZMK&quot;,&quot;DUSP2&quot;,&quot;CD8A&quot;,&quot;GZMH&quot;,&quot;GZMB&quot;,&quot;CD79A&quot;,&quot;CD79B&quot;,&quot;CD86&quot;,&quot;CD14&quot;) p &lt;- feature_highlighting(input_eset = eset.12k,target = gn.sel, ylabel = &quot;log2Exp&quot;, x=&quot;X&quot;,y=&quot;Y&quot;,title.size = 12) p &lt;- feature_vlnplot(eset.12k,target=gn.sel,feature = &quot;geneSymbol&quot;, group_tag = &quot;label&quot;,ncol = 4,ylabel = &quot;log2Exp&quot;) feature_heatmap(eset = eset.12k,target = gn.sel,group_tag = &quot;label&quot;, save_plot = TRUE,width = 6,height = 6, name = &quot;log2_expression&quot;,plot_name=&quot;./GeneHeatmap.png&quot;) Assign cell type to cluster In order to help assign cell types to each cluster in a more systemmatic way, we introduced marker_bbplot function. This function calculated cell type scores for each clusters, and visualize scores using bubble plot, with color scale indicates marker score while circle(bubble) stand for sizes. However, this fucntion requires a pre-defined marker gene lists as input, here we curated a list of well-known marker genes of 9 common immune celltypes as ref. Users are required to follow below header format in order to run this function properly. ref &lt;- read.xlsx(&quot;Immune_signatures.xlsx&quot;) head(ref) &gt; head(ref) celltype markers weight 1 NaiveT SELL 1 2 NaiveT CCR7 1 3 Tmem IL7R 1 4 Tmem CD27 1 5 Tmem IL32 1 6 Tmem GZMA -1 p&lt;-marker_bbplot(ref=ref,eset=eset.12k) Before dive into next step, we recommend assign your celltype as factors in your expression set. indx&lt;-factor(x=c(&quot;NaiveT&quot;,&quot;Tmem&quot;,&quot;CD8em&quot;,&quot;CD8eff&quot;,&quot;Bcell&quot;,&quot;NK&quot;,&quot;DC&quot;,&quot;Mo&quot;), levels=c(&quot;NaiveT&quot;,&quot;Tmem&quot;,&quot;CD8em&quot;,&quot;CD8eff&quot;,&quot;Bcell&quot;,&quot;NK&quot;,&quot;DC&quot;,&quot;Mo&quot;)) eset.12k$celltype &lt;- indx[eset.12k$label] Step 4: Network generation via SJARACNe Generate SJARACNe input Prior to generate cell type/group/cluster specific network, group information should be stored under pData([your_expressionSet]). And R function generateSJAracneInput will help to partition input expression matrix and conduct essential filtering, (filter about 0 expressed genes in cluster) to ensure a reliable network construction. funcType is required to specify what kind of network to generate. A reference Transcription factor list will be loaded automatically without manual input. However, you do need to define your species using under ref. This function will help create one directory for each group, containing required input for SJARACNe such as filtered expression matrix in .exp format and filtered TF list in .txt format. generateSJARACNeInput( eset = eset.12k,funcType = &quot;TF&quot;, ref = &quot;hg&quot;, #human wd.src = &quot;SJARACNE&quot;, #Output directory group_tag = &quot;celltype&quot;) Run SJARACNe SJARACNe works as a separate module which implemented in python, please consult here for installation and basic usage. We strongly suggest saving your working directory before running SJARACNe. Here we provide an example to run SJARACNe for all celltypes/clusters. After SJARACNe was sucessfully completed, you will be able to get one network for each cell and functional type. indir=~/PBMC12K/SJARACNE_PBMC12K/ for i in $(ls -d */ | cut -f1 -d&#39;/&#39;);do sjaracne ${i} $indir/${i}/*.exp $indir/${i}/tf/*.txt $indir/${i}/tf/ --c_threshold 0.01; echo ${i} has been submitted!; done Step 5: Identify cell type specific hidden driver Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight. Calculate activity Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are intergrated via function GetActivityFromSJARACNe. This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set save_network_files=TRUE. Since scRNA-seq data are extremly sparse and noisy, we strongly recommend to set activity.method as &#39;unweighted&#39;. acs.12k &lt;- GetActivityFromSJARACNe( SJARACNe_output_path =&quot;SJARACNE/&quot;, SJARACNe_input_eset = eset.12k, activity.method=&quot;unweighted&quot;, # we highly recommend using &#39;unweighted&#39; as activity calculation method activity.norm=TRUE, group_tag = &quot;celltype&quot;, # which group was used to partition expression profiles save_network_file=TRUE, # whether or not save network for each group save_path=&quot;./networks/&quot;) #default as false, but recommended to be TRUE Driver estimation by differential activity analysis The function FindDAG was designed to identify highly differentiated TF from SJARACNe inferred activity matrix. In order to do so, we did two sided student’s t-test to compare mean acitivty from one cell type V.S. the others. DAG_result &lt;- FindDAG(eset = acs.demo,group_tag = &quot;celltype&quot;) This function will output a full matrix that contians all TF occurred in original dataset, statistics such as t.statistics, p-value, 95%CI, etc. are outputed to help idenify hidden drivers. You can save it in txt or xlsx for checking. We also offer a function called TopDriversfromDAG to help print top drivers in each cell type to console you specified. This function is helpful for downstream analysis. TF_list &lt;- TopDriversfromDAG(DAG_result = DAG_result, celltype=levels(acs.12k$celltype), # ensure cluster order n = 5, degree_filter = c(50,500)) In scMINER, we provide a handful of visualizations to compare driver activity from different cell type/ clusters. Here we demo 2 basic functions: feature_heatmap and feature_vlnplot. These functions could be used on either expression and activty matrix. feature_heatmap(eset = acs.12k,target = TF_list,group_tag = &quot;celltype&quot;,feature = &quot;geneSymbol&quot;, width = 6,height = 6, save_plot=TRUE, cluster_rows = FALSE, name = &quot;Activity&quot;,plot_name=&quot;./21_TopTFHeatmap.png&quot;) #check postive controls p &lt;- feature_vlnplot(eset=acs.12k,target=c(&quot;LEF1&quot;,&quot;TCF7&quot;,&quot;BATF&quot;,&quot;TCF7&quot;,&quot;TBX21&quot;,&quot;IRF8&quot;,&quot;SPIB&quot;,&quot;BATF3&quot;,&quot;CEBPA&quot;), ylabel = &quot;Activity&quot;, group_tag = &quot;celltype&quot;,feature=&quot;geneSymbol&quot;, ncol = 2) ![](./plots/4_2_Known_MR_vlnplot.png) In order to conduct more advanced network analysis utilizing SJARACNe generated cell type specific networks, please infer Advanced analysis tab. R session Info &gt; sessionInfo() R version 3.5.2 (2018-12-20) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.3 Matrix products: default BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] grid parallel stats graphics grDevices utils datasets methods base other attached packages: [1] scMINER_0.1.0 kableExtra_1.1.0 knitr_1.24 rmarkdown_1.14 cowplot_1.0.0 [6] dplyr_0.8.3 pheatmap_1.0.12 ComplexHeatmap_1.20.0 scales_1.0.0 RColorBrewer_1.1-2 [11] ggplot2_3.2.1 reshape2_1.4.3 Biobase_2.42.0 BiocGenerics_0.28.0 Matrix_1.2-17 loaded via a namespace (and not attached): [1] Rcpp_1.0.2 pillar_1.4.2 compiler_3.5.2 plyr_1.8.4 tools_3.5.2 zeallot_0.1.0 [7] digest_0.6.20 viridisLite_0.3.0 evaluate_0.14 tibble_2.1.3 gtable_0.3.0 lattice_0.20-38 [13] pkgconfig_2.0.2 rlang_0.4.0 rstudioapi_0.10 xfun_0.8 xml2_1.2.2 httr_1.4.1 [19] withr_2.1.2 stringr_1.4.0 vctrs_0.2.0 hms_0.5.0 GlobalOptions_0.1.0 webshot_0.5.1 [25] tidyselect_0.2.5 glue_1.3.1 R6_2.4.0 GetoptLong_0.1.7 readr_1.3.1 purrr_0.3.2 [31] magrittr_1.5 backports_1.1.4 htmltools_0.3.6 rvest_0.3.4 assertthat_0.2.1 shape_1.4.4 [37] circlize_0.4.6 colorspace_1.4-1 stringi_1.4.3 lazyeval_0.2.2 munsell_0.5.0 crayon_1.3.4 [43] rjson_0.2.20",
    "url": "http://localhost:4000/docs/PBMC-12k.html",
    "relUrl": "/docs/PBMC-12k.html"
  },
  "4": {
    "id": "4",
    "title": "",
    "content": "Text can be bold, italic, or strikethrough. Link to another page. There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project. Header 1 This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere. Header 2 This is a blockquote following a header. When something is important enough, you do it even if the odds are not in your favor. Header 3 // Javascript code with syntax highlighting. var fun = function lang(l) { dateformat.i18n = require(&#39;./lang/&#39; + l) return true; } # Ruby code with syntax highlighting GitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, &quot;= #{version}&quot;) end Header 4 This is an unordered list following a header. This is an unordered list following a header. This is an unordered list following a header. Header 5 This is an ordered list following a header. This is an ordered list following a header. This is an ordered list following a header. Header 6 head1 head two three ok good swedish fish nice out of stock good and plenty nice ok good oreos hmm ok good zoute drop yumm There’s a horizontal rule below this. Here is an unordered list: Item foo Item bar Item baz Item zip And an ordered list: Item one Item two Item three Item four And a nested list: level 1 item level 2 item level 2 item level 3 item level 3 item level 1 item level 2 item level 2 item level 2 item level 1 item level 2 item level 2 item level 1 item And a task list Hello, this is a TODO item Hello, this is another TODO item Goodbye, this item is done Small image Large image Definition lists can be used with HTML syntax. Name Godzilla Born 1952 Birthplace Japan Color Green Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. The final element.",
    "url": "http://localhost:4000/docs/index-test.html",
    "relUrl": "/docs/index-test.html"
  },
  "5": {
    "id": "5",
    "title": "Welcome",
    "content": "scMINER: Single Cell Mutual Information-based Network Engineering ranger) scMINER is a system biology analysis frame work for high-throughput single cell RNA-seq data, implemented primarily in R and python. This package offers a combination of several individual tools including but not limit to MICA (Mutual Information based Clustering analysis) and SJARACNe. Installation instructions for each individual tools are available on github through links above. Get started now View it on GitHub Overview",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  
}
