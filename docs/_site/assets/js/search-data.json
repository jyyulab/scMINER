{
  
  "0": {
    "title": "About",
    "content": "About the project . For more studies utilizing scMINER, please check Yu lab website. . Contact . Email: . chenxi.qian@stjude.org | liang.ding@stjude.org | jiyang.yu@stjude.org | . License . Apache.2.0 .",
    "url": "http://localhost:4000/docs/About.html",
    "relUrl": "/docs/About.html"
  }
  ,"1": {
    "title": "Installation",
    "content": "Installation . Dependencies . The entry point of scMINER is a R package, which includes some of the major functions such as QC, … etc. It has been throughly tested in R 3.5.1. So it is highly recommended to have R version 3.5.1 or higher in your environment. scMINER also includes two independent python packages MICA and SJARACNe, for which python 3.6.1 or higher is required. . Installing scMINER . Install scMINER R package from github . #install dev_tool first install.packages(devtools) devtools::install_github(&quot;jyyulab/scMINER&quot;) #or devtools::install_local(&#39;scMINER_0.0.1.tar.gz&#39;) . Install MICA . Installing the official package from PyPi: pip install MICA . | Or you can install from source: git clone https://github.com/jyyulab/MICA cd MICA python setup.py install . | . Install SJARACNe . Installing the official package from PyPi: pip install SJARACNe . | Or you can install from source: git clone https://github.com/jyyulab/SJARACNe cd SJARACNe python setup.py build python setup.py install . | .",
    "url": "http://localhost:4000/docs/Installation.html",
    "relUrl": "/docs/Installation.html"
  }
  ,"2": {
    "title": "Clustering with MICA",
    "content": "Clustering Analysis with MICA . MICA(Mutual Information based Clustering Analysis) is a nonlinear clustering analysis tool designed for scRNA-seq data. Here we provide a user guide to perform MICA clustering on both local node or LSF platform. To install, please infer our MICA github page. . . Overview | Preprocssing | Basic usage On local host | On LSF | | MICA Outputs | Useful parameters Visualize with U-map or t-SNE | Try other dimension reduction methods | Try other distance matrix calculation methods | | Post-clustering analysis | . Overview . . MICA is a non-linear clustering analysis algorithm that incorporated: . Fast mutual information estimation to construct cell-cell similarity matrix. | Multidimensional scaling for stabilized dimension reduction. | Consensus clustering from multiple individual runs of kmeans to generate robust clustering results. | Preprocssing . MICA module was implemented in python, which only includes clustering analysis. For preprocessing, MICA is compatitble with most published scRNA-seq preprocessing pipeline. However, we highly recommend users to follow our preprocessing framework using scMINER R package. For detailed information, please see complementary tutorial in tab Step by step user guide. . MICA only takes cell by gene txt file as input, we strongly recommend using generateMICAinput function to convert your input data to MICA standard input text file in R. . Basic usage . MICA incorprated Common workflow languages for portablity and scalability purposes. We adopted cwltool as runner for local host and cwlexec for LSF platform. While it might introduce some differences for intermediate files, final results will not be affected. . To ensure a user friendly interface, we designed function generate_MICA_rmd to help users generate complimentary commands for MICA execution. Below are two examples when running MICA on local or LSF host respectively. . On local host . To perform MICA on local host, you need to specify host= &quot;local&quot; . scMINER::generate_MICA_cmd(save_sh_at, #path to save shell script input_file, #your MICA input file project_name, num_cluster, #a vector of numerical number output_path, #path to MICA output host=&quot;local&quot;, visualization=&quot;tsne&quot; #or &quot;umap&quot;) . or, you can create your own shell script as: . #!/usr/bin/env bash mica local -i ./test_data/inputs/PBMC_Demo_MICA_input_mini.txt -p &quot;test_local&quot; -k 3 4 -o ./test_data/outputs/test_local/ . To execute your shell script locally, you can . sh your_mica_cmd.sh . On LSF . To perform MICA on LSF, you have to specify host=&quot;lsf&quot;, which queue to submit your job queue=[your_queue], and also memory requested for MICA. . scMINER::generateMICAcmd(save_sh_at, #path to save shell script input_file, #your MICA input file project_name, num_cluster, #a vector of numerical number output_path, host=&quot;lsf&quot;, #or local queue=NULL, #your queue to submit the job memory=NULL, #specify if you use LSF, a vector of 4 numerical number dim_reduction_method=&quot;MDS&quot;, visualization=&quot;tsne&quot;) . Or, you can create your shell script as: . #!/usr/bin/env bash mica LSF -i ./test_data/inputs/PBMC_Demo_MICA_input_mini.txt -r 8000 12000 12000 16000 -q [your queue] -p &quot;test_local&quot; -k 3 4 -o ./test_data/outputs/test_local/ . To execute your shell script on LSF, we suggest . bsub &lt; your_mica_cmd.sh . MICA Outputs . Each assigned number of k will output one folder containing following files: . [Project_name]_k[number]_tsne.png –visualization of clustering result (default as tSNE) | . [Project_name]_dist.h5 – h5 file containing distance matrix calculated. | [Project_name]_mds.pdf – pdf file of t-SNE visualization of mds transformed distance matrix, with perplexity set to 30 | [Project_name]_tsne_ClusterMem.txt – txt file containing visualization coordinates and clustering labels | Useful parameters . Visualize with U-map or t-SNE . tSNE visualization is our default visualization method in the pipeline, however MICA also incorporate UMAP as optional clustering visualization. You can set visualization method to umap by . --visualization umap #(all lower cap, no &quot;-&quot;) . Also umap parameter could be tuned with --min_dist as below. It controls how points packed together. Low values of min_dist will result in clumpier embeddings: . --min_dist 0.1 (or other number ranging from 0-1) . and you can also set parameter (perplexity) for tsne visualization using . -pp 20 (or any other integers larger than 5) . Try other dimension reduction methods . MICA also incorporated other dimension reduction methods such as Principle component analysis(PCA) or Laplace transform (lpl), you can use them via adding parameter: . -dr PCA # or: MDS | PCA | LPL | LPCA . Try other distance matrix calculation methods . We integrated other distance matrix calculation methods as optional, such as euclidean distance, spearman correlation and pearson correlation. You can use them via adding parameter, default is MI(mutual information): . --dist MI # or: euclidean | spearman | pearson . Post-clustering analysis . We offer a handful of useful functions in scMINER ranging from visualization to driver estimation, to help you explore your scRNA-seq data in a system biology way after clustering. .",
    "url": "http://localhost:4000/docs/MICA.html",
    "relUrl": "/docs/MICA.html"
  }
  ,"3": {
    "title": "Advanced analysis",
    "content": "Advanced analysis . Here we demonstrate our advanced downstream analysis pipeline using PBMC (10x genmomics) scRNA-seq data after following driver estimation tutorial under step by step user guide. . Network visualization . scMINER incorporates a handful of network visualization/exploration function adapted from NetBID2, a powerful tool for data-driven network-based bayesian Inference of drivers. scMINER also offered several wrappers of basic visualization functions in NetBID2 for better usability. . Load networks . You can retrieve your network and store them in a network structure with function NetBID2::get.SJAracne.network. . net1 &lt;- NetBID2::get.SJAracne.network(&#39;SJARACNE/NaiveT_8469_8468_4421/tf/SJARACNE_NaiveT_8469_8468_4421/SJARACNE_out.final/consensus_network_ncol_.txt&#39;) net2 &lt;- NetBID2::get.SJAracne.network(&#39;SJARACNE/Tmem_8489_8488_2482/tf/SJARACNE_Tmem_8489_8488_2482/SJARACNE_out.final/consensus_network_ncol_.txt&#39;) . Or, if you followed our analysis pipeline under step by step user guide, you should be able to load your network files under ./networks folder: . load(&quot;./networks/NaiveT_TF.network&quot;) . Single network visualization . In scMINER, you can visualize your driver and its targets by function draw.network. It was adapted from function draw.targetNet and draw.targetNet.TWO from NetBID2. This function can help visualize a driver’s targets as well as the relationship(edge) between source and target genes, by taking Mutual information as edge weight, and spearman correlation as direction. . draw.network(net1 = net,src1 = &quot;LEF1&quot;, #driver name ifSymbol = TRUE, #if your source driver name is a Symbol ifWeighted = TRUE, #if plot edge with weight and direction pdf_name = &quot;LEF1.TF_in_NaiveT_network.pdf&quot;, n_layer=4) . Subnetwork structure visualization between two networks . You can also use draw.network function to visualize two networks and their subnetwork structure. This could be used for: . Identify common targets from two top driver from the same network | Identify network rewiring event of same driver in different cell type network. | . Here below is an example for later case: . draw.network(net1 = net1,net2 = net2, src1 = &quot;BATF&quot;,src2=&quot;BATF&quot;, source1_z=-3, source2_z=4, ifSymbol = TRUE,ifWeighted = TRUE, pdf_name = &quot;BATF.TF_in_2_network.pdf&quot;, n_layer=4) . Biological function anlaysis for drivers . Gene set overlap with targets visualized by bubble plot . When picking candidate hidden drivers, it would be extremly helpful if we could identify the potential biological pathways this driver regulates. With SJARACNe infered network, we can assess as well as visualizethe overlap between knowledge-based gene sets and driver’s targets via function draw.bubblePlot. This function returns a bubble plot indiating results from Fisher exact test. . Before usingdraw.bubblePlot function, you have to load genesets in your working environment by function gs.preload() . gs.preload(use_spe=&#39;Homo sapiens&#39;,update=FALSE) . Then you can use function TopMasterRegulator to pull out top hidden driver candidates from your Differential activity analysis results. Or write your own fucntions to hand pick candidate to visualize. Here we provide an example of using function TopMasterRegulator. . TF_list &lt;- TopMasterRegulator(DAG_result = DAG_result, celltype=&quot;NaiveT&quot;, n = 10, degree_filter = c(50,800)) . Next generate your ID to symbol conversion table, since all gene sets are curated at gene symbol level. Here in our data, we used ensembl_id as our default ID for network construction. In order to match your ID with gene symbols, you can use function: . tbl &lt;- get_IDtransfer2symbol2type(from_type = &quot;ensembl_gene_id&quot;, use_genes = rownames(eset.12k),ignore_version = TRUE) . Here we provide an example for ploting overlap between target list of top drivers in Naive T cells, and knowledge based gene sets from “Hallmark”,”KEGG” and “GO”. . draw.bubblePlot(driver_list = TF_list, show_label = DAG_result[TF_list,&quot;geneSymbol&quot;], Z_val = DAG_result[TF_list,&quot;Z_NaiveT&quot;], driver_type = NULL, target_list = net1$target_list, transfer2symbol2type = tbl, bg_list = fData(eset.12k)$geneSymbol, min_gs_size = 50, max_gs_size = 600, top_geneset_number=8,top_driver_number=10,use_gs = c(&quot;H&quot;,&quot;C5&quot;,&quot;CP:KEGG&quot;), pdf_file = &#39;NaiveT_bubblePlot.pdf&#39;, main =&#39;Bubbleplot for top driver targets in NaiveT&#39;) . . &gt; sessionInfo() R version 3.6.1 (2019-07-05) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.3 Matrix products: default BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] stats4 grid parallel stats graphics grDevices utils datasets methods base other attached packages: [1] scMINER_0.1.0 NetBID2_2.0.1 openxlsx_4.1.0.1 msigdbr_7.0.1 GSVA_1.32.0 biomaRt_2.40.4 [7] reshape_0.8.8 arm_1.10-1 MASS_7.3-51.4 MCMCglmm_2.29 ape_5.3 coda_0.19-3 [13] ordinal_2019.4-25 umap_0.2.3.1 plotrix_3.7-6 plot3D_1.1.1 igraph_1.2.4.1 aricode_0.1.2 [19] ConsensusClusterPlus_1.48.0 DESeq2_1.24.0 tximport_1.12.3 impute_1.58.0 limma_3.40.6 GEOquery_2.52.0 [25] lme4_1.1-21 SummarizedExperiment_1.14.1 DelayedArray_0.10.0 BiocParallel_1.18.1 matrixStats_0.55.0 GenomicRanges_1.36.1 [31] GenomeInfoDb_1.20.0 IRanges_2.18.3 S4Vectors_0.22.1 kableExtra_1.1.0 knitr_1.25 Matrix_1.2-17 [37] rmarkdown_1.16 cowplot_1.0.0 dplyr_0.8.3 pheatmap_1.0.12 ComplexHeatmap_2.0.0 scales_1.0.0 [43] RColorBrewer_1.1-2 ggplot2_3.2.1 reshape2_1.4.3 Biobase_2.44.0 BiocGenerics_0.30.0 BiocManager_1.30.4 loaded via a namespace (and not attached): [1] backports_1.1.4 circlize_0.4.8 Hmisc_4.2-0 plyr_1.8.4 lazyeval_0.2.2 GSEABase_1.46.0 splines_3.6.1 digest_0.6.21 [9] htmltools_0.3.6 magrittr_1.5 checkmate_1.9.4 memoise_1.1.0 cluster_2.1.0 readr_1.3.1 annotate_1.62.0 askpass_1.1 [17] prettyunits_1.0.2 colorspace_1.4-1 blob_1.2.0 rvest_0.3.4 xfun_0.10 jsonlite_1.6 crayon_1.3.4 RCurl_1.95-4.12 [25] graph_1.62.0 genefilter_1.66.0 zeallot_0.1.0 survival_2.44-1.1 glue_1.3.1 gtable_0.3.0 zlibbioc_1.30.0 XVector_0.24.0 [33] webshot_0.5.1 GetoptLong_0.1.7 Rhdf5lib_1.6.1 shape_1.4.4 abind_1.4-5 DBI_1.0.0 Rcpp_1.0.2 viridisLite_0.3.0 [41] xtable_1.8-4 progress_1.2.2 htmlTable_1.13.2 clue_0.3-57 reticulate_1.13 foreign_0.8-72 bit_1.1-14 Formula_1.2-3 [49] htmlwidgets_1.3 httr_1.4.1 acepack_1.4.1 pkgconfig_2.0.3 XML_3.98-1.20 nnet_7.3-12 locfit_1.5-9.1 tidyselect_0.2.5 [57] rlang_0.4.0 later_0.8.0 AnnotationDbi_1.46.1 munsell_0.5.0 tools_3.6.1 RSQLite_2.1.2 evaluate_0.14 stringr_1.4.0 [65] bit64_0.9-7 zip_2.0.4 purrr_0.3.2 nlme_3.1-141 mime_0.7 xml2_1.2.2 compiler_3.6.1 shinythemes_1.1.2 [73] rstudioapi_0.10 png_0.1-7 tibble_2.1.3 geneplotter_1.62.0 stringi_1.4.3 cubature_2.0.3 lattice_0.20-38 nloptr_1.2.1 [81] tensorA_0.36.1 vctrs_0.2.0 pillar_1.4.2 lifecycle_0.1.0 GlobalOptions_0.1.1 ucminf_1.1-4 data.table_1.12.2 bitops_1.0-6 [89] corpcor_1.6.9 httpuv_1.5.2 R6_2.4.0 latticeExtra_0.6-28 promises_1.0.1 gridExtra_2.3 boot_1.3-23 assertthat_0.2.1 [97] rhdf5_2.28.0 openssl_1.4.1 rjson_0.2.20 withr_2.1.2 GenomeInfoDbData_1.2.1 hms_0.5.1 rpart_4.1-15 tidyr_1.0.0 [105] minqa_1.2.4 misc3d_0.8-4 numDeriv_2016.8-1.1 shiny_1.3.2 base64enc_0.1-3 . .",
    "url": "http://localhost:4000/docs/PBMC-12k-network.html",
    "relUrl": "/docs/PBMC-12k-network.html"
  }
  ,"4": {
    "title": "Step by step user guidance",
    "content": "Analysis on PBMC(12k) scRNA-seq data via scMINER . . Demo data | Step 1: Data preprocessing Read 10x genomics data | Quality control and data filtering | Normalization and transformation | | Step 2: Perform clustering analysis via MICA Generate MICA input and command | | Step 3: Cell type annotation after clustering Read MICA output | Marker gene visualization | Assign cell type to cluster | | Step 4: Network generation via SJARACNe Generate SJARACNe input | Run SJARACNe | | Step 5: Identify cell type specific hidden driver Calculate activity | Driver estimation by differential activity analysis | | R session Info | . Demo data . Here we demonstrate our pipeline using PBMC (10x genmomics) scRNA-seq data. Full data contains 68k cells, in order to provide a faster guidance, we’ve down sampled this data to 12k cells. Original data can be downloaded here. . Step 1: Data preprocessing . Read 10x genomics data . Read 10x genomics data with function readscRNAseqData in scMINER package. This function could help read data from either 10x genomics standard output(usually contains three individual files: matrix.mtx, barcodes.tsv, features.tsv), or other text files by passing arguments to read.delim(). . This function helps create a Sparse matrix object using Expressionset prototype, If set CreateSparseEset=T. Otherwise, it will create a list object that stores expression data, feature data and sample data under three separate slots. If add.meta=T, then additional sample info such as total number of UMI will be calcualated and outputed in sample data. Here, we defined is.10x=T,CreateSparseEset = F, and add.meta=F. . d.12k &lt;- readscRNAseqData(file=&quot;../PBMC12k_input/&quot;,is.10x = T,CreateSparseEset = F, add.meta=F) . After loading data to environment properly, you can now create Sparse Matrix expression by using CreateSparseEsetfunction: . eset.12k &lt;- CreateSparseEset(data=d.12k, add.meta = T) . Quality control and data filtering . Quality control assessments could be done using draw.scRNAseq.QC function, which outputs a html report generated through Rmarkdown(PBMC12K_QC_report.html). The report includes three essential quality control figures at both gene and cell level. Suggested cutoff will be returned as a list if set output.cutoff=TRUE. . cutoffs &lt;- draw.scRNAseq.QC(SparseEset=eset.12k, project.name = &quot;PBMC12k&quot;, plot.dir = &quot;./QC/&quot;, group = &quot;group&quot;, # this indicate which meta data information will be use in x axis to group violin plots output.cutoff = TRUE) . The first plot is a histogram which helps visualize distribution of expressed genes among each cells. Blue veritcal line shows the recommended cutoff. Genes expressed lower number of cells than threshold should be filtered. . The second plot helps visualize total UMI count, and total number of gene expressed in violin plots. Horizontal blue line indicates suggested high/low cutoffs. Suggested thresholds were computed based on Median ± 3 * MAD (Maximum absolute deviance). Actual threshold numbers are also printed right above blue lines in green labels. . The third plot visualizes mitochondrial gene expression percentage, and spike-in genes expression percentage for each cell V.S. total number of UMI in scatter plots. Cells with high percentage of mitochondrial gene expression but low total number of UMI count are often considered as low quality. . Then you could perform filtering with function preMICA.filtering. We recommend to input cutoffs using thresholds list which directly outputted from draw.scRNAseq.QC functon. You could also manually change cutoffs by re-assign thresholds in cutoffs list, e.g. cutoffs$umi_cf_hi &lt;- Inf means not doing filtering on outliers caused by high total UMI value. . cutoffs$umi_cf_hi &lt;- Inf # only filter on low total number of UMI eset.sel &lt;- preMICA.filtering(SparseEset = eset.12k, cutoffs = cutoffs) . Normalization and transformation . In scMINER package, we don’t provide methods to perform data normalizaton. You can use your own prefered normalization method. However, we highly recommend to do CPM and log2 transformation for MICA input. . norm = 1e6 exp.norm &lt;- sweep(exprs(eset.sel), 2, norm/unname(Matrix::colSums(exprs(eset.sel))), &#39;*&#39;) # log transformation # Required for MICA exp.log2 &lt;- log(exp.norm+1,base=2) # save as SparseEset eset.log2 &lt;- CreateSparseEset(data=exp.log2, meta.data = pData(eset.sel), feature.data = fData(eset.sel), add.meta = F) . Step 2: Perform clustering analysis via MICA . MICA was implemented in Python. If you would like to install MICA, please refer to MICA github page. There are several handlers for you to choose in MICA for better visualization. A more comprehensive tutorial could be found under Clustering with MICA tab . Here we suggest saving your working directory prior to running MICA. . Generate MICA input and command . After reviewing all visualizations and finished filtering, you can go ahead and generate clustering (MICA) input with function generateMICAinput. This function takes an expression matrix as input, and outputs a cell by gene .txt file. Please note that you should always feed MICA the log or log2 transformed data. . generateMICAinput(data= exp.log2 ,filename=&quot;PBMC12k_MICA_input.txt&quot;) . We also offer a function called generate_MICA_cmd to help write MICA command in a shell script. In order to run MICA on LSF, you need to set host=lsf, define queue = [your queue] (required), and memory (optional). In num_cluster, you can specify a vector of number of K to perform clustering analysis for different number of cluster simultaneously. . generate_MICA_cmd(save_sh_at = &quot;./PBMC12k/&quot;, input_file = &quot;./PBMC12k/PBMC12k_MICA_input.txt&quot;, project_name = &quot;PBMC12k&quot;, num_cluster = c(8,9,10,12,13,14,15), host = &quot;lsf&quot;, queue = [your_queue], memory = c(8000, 12000, 16000, 16000), output_path = &quot;./&quot;,queue = &quot;standard&quot;) . Step 3: Cell type annotation after clustering . Read MICA output . After clustering via MICA, with function readMICAoutput, you can load MICA output (in .txt) as well as your input expression matrix in R to an expressionSet object. ExpressionSet is the major data structure we used for downstream analysis in R. . Note: All functions are designed compatible for both expressionSet and SparseExpressionSet . Users shall start with one particular MICA membership and study your optimal number of cluster with cell type signatures. By setting load_ClusterRes as TRUE, clustering label will be saved under eset$ClusterRes. . eset &lt;- readMICAoutput(eset = eset.norm, load_ClusterRes = TRUE, output_file = &quot;MICA/PBMC12k_k8_tsne_ClusterMem.txt&quot;) . In order to visualize MICA labels or other metadata on tSNE/UMAP coordinates, your can use function MICAplot. Users are required to specify X and Y coordinates in this function. Other meta data could also be visualized by changing label handler. This function outputs a ggplot object. . MICAplot(input_eset = eset,visualize = &#39;tSNE&#39;,X = &quot;X&quot;, Y=&quot;Y&quot;,label = &quot;label&quot;,pct = 0.5) . Marker gene visualization . Picked marker genes could be visualized on t-SNE scatterplot, violin plot or heatmap via function feature_highlighting, feature_vlnplot and feature_heatmap. This will not only help cluster annotation, but also identify optimal number of clusters as well. . gn.sel&lt;-c(&quot;CD3D&quot;,&quot;CD27&quot;,&quot;IL7R&quot;,&quot;SELL&quot;,&quot;CCR7&quot;,&quot;IL32&quot;,&quot;GZMA&quot;, &quot;GZMK&quot;,&quot;DUSP2&quot;,&quot;CD8A&quot;,&quot;GZMH&quot;,&quot;GZMB&quot;,&quot;CD79A&quot;,&quot;CD79B&quot;,&quot;CD86&quot;,&quot;CD14&quot;) p &lt;- feature_highlighting(input_eset = eset, target = gn.sel, feature=&quot;geneSymbol&quot;,ylabel = &quot;log2Exp&quot;, x=&quot;X&quot;,y=&quot;Y&quot;,pct.size = 0.5) . p &lt;- feature_vlnplot(input_eset=eset,target=gn.sel,feature = &quot;geneSymbol&quot;, group_tag = &quot;ClusterRes&quot;,ylabel = &quot;log2Exp&quot;,ncol = 4) . feature_heatmap(eset = eset, target = gn.sel,group_tag = &quot;ClusterRes&quot;, save_plot = TRUE,width = 6,height = 6, name = &quot;log2_expression&quot;,plot_name=&quot;./GeneHeatmap.png&quot;) . Assign cell type to cluster . In order to help assign cell types to each cluster in a more systemmatic way, we introduced marker_bbplot function. This function calculated cell type scores for each clusters, and visualize scores using bubble plot, with color scale indicates marker score while circle(bubble) stand for sizes. However, this fucntion requires a pre-defined marker gene lists as input, here we curated a list of well-known marker genes of 9 common immune celltypes as ref. Users are required to follow below header format in order to run this function properly. . ref &lt;- read.xlsx(&quot;Immune_signatures.xlsx&quot;) head(ref) &gt; head(ref) celltype markers weight 1 NaiveT SELL 1 2 NaiveT CCR7 1 3 Tmem IL7R 1 4 Tmem CD27 1 5 Tmem IL32 1 6 Tmem GZMA -1 marker_bbplot(ref=ref,eset=eset,width = 6,height=4, feature = &quot;geneSymbol&quot;,group_tag = &quot;ClusterRes&quot;, save_plot = TRUE, plot_name = &quot;plots/MICA_cluster_score.png&quot;) . Before diving into network generation section, please assign your celltype as factors in your expression set. Please do not include “_” in your cell type names since it will cause mis-parsing in later analysis. . indx&lt;-factor(x=c(&quot;NaiveT&quot;,&quot;Tmem&quot;,&quot;CD8em&quot;,&quot;CD8eff&quot;,&quot;NK&quot;,&quot;Bcell&quot;,&quot;DC&quot;,&quot;Mo&quot;), levels=c(&quot;NaiveT&quot;,&quot;Tmem&quot;,&quot;CD8em&quot;,&quot;CD8eff&quot;,&quot;NK&quot;,&quot;Bcell&quot;,&quot;DC&quot;,&quot;Mo&quot;)) eset$celltype &lt;- indx[eset$ClusterRes] . Step 4: Network generation via SJARACNe . Generate SJARACNe input . Before generating cell type/group/cluster specific network, group information should be stored under pData([your_expressionSet]). An R function called generateSJAracneInput will help to partition input expression matrix and perform essential filtering(filter out 0 expressed genes in cluster) to ensure a reliable network construction. funcType is required to specify what kind of network to generate. If set funcType=&quot;TF&quot;, a reference transcription factor list will be loaded automatically without manual input. However, you do need to define species information for your data using under ref. . This function will help create one directory for each group/cell type, containing required input for SJARACNe such as filtered expression matrix in .exp format and filtered TF list in .txt format. . generateSJARACNeInput( eset = eset.12k,funcType = &quot;TF&quot;, ref = &quot;hg&quot;, #human wd.src = &quot;SJARACNE&quot;, #Output directory group_tag = &quot;celltype&quot;) . Run SJARACNe . SJARACNe works as a separate module which was implemented in python, please refer to SJARACNe github page for installation and basic usage. Please save your working directory before running SJARACNe. . Here we provide an example to run SJARACNe for all celltypes/clusters. After SJARACNe was sucessfully completed, you will be able to get one network for each cell and functional type. . indir = ~/PBMC12K/SJARACNE_PBMC12K/ for i in $(ls -d */ | cut -f1 -d&#39;/&#39;);do sjaracne ${i} $indir/${i}/*.exp $indir/${i}/tf/*.txt $indir/${i}/tf/ --c_threshold 0.01; echo ${i} has been submitted!; done . Step 5: Identify cell type specific hidden driver . Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight. . Calculate activity . Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are intergrated via function GetActivityFromSJARACNe. This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set save_network_files=TRUE. . Since scRNA-seq data are extremly sparse and noisy, please set activity.method as &#39;unweighted&#39;. . acs.12k &lt;- GetActivityFromSJARACNe( SJARACNe_output_path =&quot;SJARACNE/&quot;, SJARACNe_input_eset = eset.12k, activity.method=&quot;unweighted&quot;, # we highly recommend using &#39;unweighted&#39; as activity calculation method activity.norm=TRUE, group_tag = &quot;celltype&quot;, # which group was used to partition expression profiles save_network_file=TRUE, # whether or not save network for each group save_path=&quot;./networks/&quot;) #default as false, but recommended to be TRUE . Driver estimation by differential activity analysis . The function FindDAG was designed to perform differnetial activity analysis from SJARACNe inferred activity matrix. In this function, two-sided student’s t-test will be performed to compare mean activity from one cell type V.S. the others. It will return a data frame that includes all TF occurred in original data. Statistics such as t.statistics, p-value, 95%CI, etc. are outputed to help identify hidden drivers. You can save it to file in order to check them manually. . DAG_result &lt;- FindDAG(eset = acs.demo,group_tag = &quot;celltype&quot;) . We also offer a function called TopDriversfromDAG to help picking top drivers for each cell type. You can specify n as maximum number of top drivers to pick, and degree_filter to restrict number of targets. . TF_list &lt;- TopDriversfromDAG(DAG_result = DAG_result, celltype = levels(acs.12k$celltype), # ensure cluster order n = 5, degree_filter = c(50,600)) . In scMINER, we provide a handful of visualizations to compare driver activity from different cell type/clusters. Here we demo two basic functions: feature_heatmap and feature_vlnplot. These functions could be used on either expression and activty matrix. . feature_heatmap(input_eset = acs.12k,target = TF_list,group_tag = &quot;celltype&quot;,feature = &quot;geneSymbol&quot;, width = 6,height = 6, save_plot=TRUE, cluster_rows = FALSE, name = &quot;Activity&quot;,plot_name=&quot;./21_TopTFHeatmap.png&quot;) . #check postive controls p&lt;-feature_vlnplot(input_eset = acs.12k,feature = &quot;geneSymbol&quot;,target=c(&quot;LEF1&quot;,&quot;TCF7&quot;,&quot;BATF&quot;,&quot;TBX21&quot;,&quot;IRF8&quot;,&quot;SPIB&quot;,&quot;BATF3&quot;,&quot;CEBPA&quot;), ylabel = &quot;Activity&quot;,group_tag = &quot;celltype&quot;,ncol=2) . In order to perform more advanced network analysis utilizing SJARACNe generated cell type specific networks, please infer detailed guidance under Advanced analysis tab. . . R session Info . &gt; sessionInfo() R version 3.6.1 (2019-07-05) Platform: x86_64-apple-darwin15.6.0 (64-bit) Running under: macOS Mojave 10.14.3 Matrix products: default BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] stats4 grid parallel stats graphics grDevices utils datasets methods base other attached packages: [1] scMINER_0.1.0 NetBID2_2.0.1 openxlsx_4.1.0.1 msigdbr_7.0.1 GSVA_1.32.0 biomaRt_2.40.4 [7] reshape_0.8.8 arm_1.10-1 MASS_7.3-51.4 MCMCglmm_2.29 ape_5.3 coda_0.19-3 [13] ordinal_2019.4-25 umap_0.2.3.1 plotrix_3.7-6 plot3D_1.1.1 igraph_1.2.4.1 aricode_0.1.2 [19] ConsensusClusterPlus_1.48.0 DESeq2_1.24.0 tximport_1.12.3 impute_1.58.0 limma_3.40.6 GEOquery_2.52.0 [25] lme4_1.1-21 SummarizedExperiment_1.14.1 DelayedArray_0.10.0 BiocParallel_1.18.1 matrixStats_0.55.0 GenomicRanges_1.36.1 [31] GenomeInfoDb_1.20.0 IRanges_2.18.3 S4Vectors_0.22.1 kableExtra_1.1.0 knitr_1.25 Matrix_1.2-17 [37] rmarkdown_1.16 cowplot_1.0.0 dplyr_0.8.3 pheatmap_1.0.12 ComplexHeatmap_2.0.0 scales_1.0.0 [43] RColorBrewer_1.1-2 ggplot2_3.2.1 reshape2_1.4.3 Biobase_2.44.0 BiocGenerics_0.30.0 BiocManager_1.30.4 loaded via a namespace (and not attached): [1] backports_1.1.4 circlize_0.4.8 Hmisc_4.2-0 plyr_1.8.4 lazyeval_0.2.2 GSEABase_1.46.0 splines_3.6.1 digest_0.6.21 [9] htmltools_0.3.6 magrittr_1.5 checkmate_1.9.4 memoise_1.1.0 cluster_2.1.0 readr_1.3.1 annotate_1.62.0 askpass_1.1 [17] prettyunits_1.0.2 colorspace_1.4-1 blob_1.2.0 rvest_0.3.4 xfun_0.10 jsonlite_1.6 crayon_1.3.4 RCurl_1.95-4.12 [25] graph_1.62.0 genefilter_1.66.0 zeallot_0.1.0 survival_2.44-1.1 glue_1.3.1 gtable_0.3.0 zlibbioc_1.30.0 XVector_0.24.0 [33] webshot_0.5.1 GetoptLong_0.1.7 Rhdf5lib_1.6.1 shape_1.4.4 abind_1.4-5 DBI_1.0.0 Rcpp_1.0.2 viridisLite_0.3.0 [41] xtable_1.8-4 progress_1.2.2 htmlTable_1.13.2 clue_0.3-57 reticulate_1.13 foreign_0.8-72 bit_1.1-14 Formula_1.2-3 [49] htmlwidgets_1.3 httr_1.4.1 acepack_1.4.1 pkgconfig_2.0.3 XML_3.98-1.20 nnet_7.3-12 locfit_1.5-9.1 tidyselect_0.2.5 [57] rlang_0.4.0 later_0.8.0 AnnotationDbi_1.46.1 munsell_0.5.0 tools_3.6.1 RSQLite_2.1.2 evaluate_0.14 stringr_1.4.0 [65] bit64_0.9-7 zip_2.0.4 purrr_0.3.2 nlme_3.1-141 mime_0.7 xml2_1.2.2 compiler_3.6.1 shinythemes_1.1.2 [73] rstudioapi_0.10 png_0.1-7 tibble_2.1.3 geneplotter_1.62.0 stringi_1.4.3 cubature_2.0.3 lattice_0.20-38 nloptr_1.2.1 [81] tensorA_0.36.1 vctrs_0.2.0 pillar_1.4.2 lifecycle_0.1.0 GlobalOptions_0.1.1 ucminf_1.1-4 data.table_1.12.2 bitops_1.0-6 [89] corpcor_1.6.9 httpuv_1.5.2 R6_2.4.0 latticeExtra_0.6-28 promises_1.0.1 gridExtra_2.3 boot_1.3-23 assertthat_0.2.1 [97] rhdf5_2.28.0 openssl_1.4.1 rjson_0.2.20 withr_2.1.2 GenomeInfoDbData_1.2.1 hms_0.5.1 rpart_4.1-15 tidyr_1.0.0 [105] minqa_1.2.4 misc3d_0.8-4 numDeriv_2016.8-1.1 shiny_1.3.2 base64enc_0.1-3 .",
    "url": "http://localhost:4000/docs/PBMC-12k.html",
    "relUrl": "/docs/PBMC-12k.html"
  }
  ,"5": {
    "title": "",
    "content": "Text can be bold, italic, or strikethrough. . Link to another page. . There should be whitespace between paragraphs. . There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project. . Header 1 . This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere. . Header 2 . This is a blockquote following a header. . When something is important enough, you do it even if the odds are not in your favor. . Header 3 . // Javascript code with syntax highlighting. var fun = function lang(l) { dateformat.i18n = require(&#39;./lang/&#39; + l) return true; } . # Ruby code with syntax highlighting GitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, &quot;= #{version}&quot;) end . Header 4 . This is an unordered list following a header. | This is an unordered list following a header. | This is an unordered list following a header. | . Header 5 . This is an ordered list following a header. | This is an ordered list following a header. | This is an ordered list following a header. | Header 6 . head1 head two three . ok | good swedish fish | nice | . out of stock | good and plenty | nice | . ok | good oreos | hmm | . ok | good zoute drop | yumm | . There’s a horizontal rule below this. . . Here is an unordered list: . Item foo | Item bar | Item baz | Item zip | . And an ordered list: . Item one | Item two | Item three | Item four | And a nested list: . level 1 item level 2 item | level 2 item level 3 item | level 3 item | . | . | level 1 item level 2 item | level 2 item | level 2 item | . | level 1 item level 2 item | level 2 item | . | level 1 item | . And a task list . Hello, this is a TODO item | Hello, this is another TODO item | Goodbye, this item is done | . Small image . . Large image . . Definition lists can be used with HTML syntax. . Name Godzilla Born 1952 Birthplace Japan Color Green Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. . The final element. .",
    "url": "http://localhost:4000/docs/index-test.html",
    "relUrl": "/docs/index-test.html"
  }
  ,"6": {
    "title": "Home",
    "content": ". Single-Cell Mutual Information-based Network Engineering Ranger . Get started now View it on GitHub . . Overview . scMINER is a systems biology toolkit for QC and analysis of high-throughput single cell RNA-seq data. For the better understanding of the sources of heterogeneity from single-cell RNA-seq data, scMINER enable users to identify and interpret cell type-specific hidden drivers, where the drivers can be either transcription factors (TF) or signaling factors (SIG). . scMINER also includes new mutual information based approach MICA for classifying cells and improved scalable version of SJARACNe for cell type-specific gene network reverse engineering. . . Citing scMINER . If scMINER is useful to your work, please cite the following paper: . scMINER bioRxiv version first? . Contact . The scMINER software is developed by Yu Lab at St. Jude Children’s Research Hospital. . We’re very interested to hear feedback about using scMINER in your analysis. If you find any issues/bugs, or have any suggestions, please don’t hesitate to create issues in GitHub, or contact us directly. .",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  
}