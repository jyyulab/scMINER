{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to scMINER Documentation! Overview We are excited to release scMINER v1.0 , an R package designed for preprocessing, QC, clustering, and hidden driver analysis of single-cell RNA-seq data. scMINER enables mutual information-based cell clustering, cell-type-specific gene regulatory network (GRN) reverse engineering and protein activity inference, to identify hidden transcriptional factors (TFs) and signaling factors (SIGs) driving cellular lineage differentiation and tissue specific specification. scMINER is also integrated with a suite of downstream analysis and visualization functions. Manuscript The scMINER software is developed and maintained by the Yu Laboratory @ St. Jude and is released under the Apache License (Version 2.0). Please consider citing [paper] if you find scMINER useful in your research. Why use scMINER? scMINER includes the following key functions: Build SparseEset object for efficiently storing large-scale single-cell RNAseq data. Integrated quality control with a comprehensive html report. MICA stands for M utual I nformation-based C lustering A nalysis. MICA is a command line tool implemented in python for scalable clustering analysis and superior clustering purity. MINIE stands for M utual I nformation-based N etwork I nference E ngine. MINIE includes functions for GRN reverse engineering and protein activity inference for hidden drive analysis. With inferred protein activities, MINIE enables differential activity analysis. Get started with scMINER If you are new to scMINER, make sure to install scMINER following the installation guide and go though the basic tutorial which contains a step-by-step analysis of 14K Human Blood Mononuclear Cells (PBMCs). For a more advanced or ad_hoc analysis, please refer to other guided analysis or scMINER's high-level API. Support We welcome your feedback! Feel free to open an issue , send us an email if you encounter a bug, need our help or just want to make a comment/suggestion.","title":"Home"},{"location":"#welcome-to-scminer-documentation","text":"","title":"Welcome to scMINER Documentation!"},{"location":"#overview","text":"We are excited to release scMINER v1.0 , an R package designed for preprocessing, QC, clustering, and hidden driver analysis of single-cell RNA-seq data. scMINER enables mutual information-based cell clustering, cell-type-specific gene regulatory network (GRN) reverse engineering and protein activity inference, to identify hidden transcriptional factors (TFs) and signaling factors (SIGs) driving cellular lineage differentiation and tissue specific specification. scMINER is also integrated with a suite of downstream analysis and visualization functions.","title":"Overview"},{"location":"#manuscript","text":"The scMINER software is developed and maintained by the Yu Laboratory @ St. Jude and is released under the Apache License (Version 2.0). Please consider citing [paper] if you find scMINER useful in your research.","title":"Manuscript"},{"location":"#why-use-scminer","text":"scMINER includes the following key functions: Build SparseEset object for efficiently storing large-scale single-cell RNAseq data. Integrated quality control with a comprehensive html report. MICA stands for M utual I nformation-based C lustering A nalysis. MICA is a command line tool implemented in python for scalable clustering analysis and superior clustering purity. MINIE stands for M utual I nformation-based N etwork I nference E ngine. MINIE includes functions for GRN reverse engineering and protein activity inference for hidden drive analysis. With inferred protein activities, MINIE enables differential activity analysis.","title":"Why use scMINER?"},{"location":"#get-started-with-scminer","text":"If you are new to scMINER, make sure to install scMINER following the installation guide and go though the basic tutorial which contains a step-by-step analysis of 14K Human Blood Mononuclear Cells (PBMCs). For a more advanced or ad_hoc analysis, please refer to other guided analysis or scMINER's high-level API.","title":"Get started with scMINER"},{"location":"#support","text":"We welcome your feedback! Feel free to open an issue , send us an email if you encounter a bug, need our help or just want to make a comment/suggestion.","title":"Support"},{"location":"contact/","text":"Contact us The scMINER software is developed and maintained by Liang (Adam) Ding and Hao Shi in Yu Laboratory at St. Jude Children's Research Hospital . Please consider citing [paper] if you find scMINER useful in your research. We're very interested to hear others' feedback about using scMINER for their projects. To this end, scMINER is actively developed on GitHub and we interact regularly with users on GitHub issues. Please report any bugs or feature requests via the GitHub issue tracker .","title":"Contact"},{"location":"contact/#contact-us","text":"The scMINER software is developed and maintained by Liang (Adam) Ding and Hao Shi in Yu Laboratory at St. Jude Children's Research Hospital . Please consider citing [paper] if you find scMINER useful in your research. We're very interested to hear others' feedback about using scMINER for their projects. To this end, scMINER is actively developed on GitHub and we interact regularly with users on GitHub issues. Please report any bugs or feature requests via the GitHub issue tracker .","title":"Contact us"},{"location":"install/","text":"Installation Dependencies scMINER requires R version >= 4.0.5 and Python version == 3.7.6 to run. We recommend using Miniconda to create and manage the environments. Installing scMINER Install scMINER R package To install from GitHub master branch install.packages('devtools') # install devtools package first devtools::install_github(\"jyyulab/scMINER\", ref='master', dependencies='Depends') or to clone from https://github.com/jyyulab/scMINER/ and install from source files: devtools::install(pkg='.',dependencies=TRUE) # Install the package with dependencies. devtools::install_deps(pkg = \".\", dependencies = TRUE) # Install package dependencies if needed. or to download the released tar.gz file is under project space, you can install via: devtools::install(pkg='scMINER_0.1.0.tar.gz', dependencies=TRUE) Install MICA python package To install the package from PyPI: pip install MICA or to install from source: git clone https://github.com/jyyulab/MICA cd MICA python setup.py install Install SJARACNe python package As the core SJARACNe functions were implemented in C++ which requires compiling, we recommend using installing from source: git clone https://github.com/jyyulab/SJARACNe cd SJARACNe python setup.py build python setup.py install R session info > sessionInfo() R version 4.1.1 (2021-08-10) Platform: x86_64-apple-darwin17.0 (64-bit) Running under: macOS Monterey 12.2.1 Matrix products: default LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] grid stats4 parallel stats graphics grDevices utils datasets methods base other attached packages: [1] NetBID2_2.0.3 plotly_4.9.4.1 rhdf5_2.36.0 openxlsx_4.2.4 [5] msigdbr_7.4.1 GSVA_1.40.1 biomaRt_2.48.3 reshape_0.8.8 [9] arm_1.11-2 MASS_7.3-54 MCMCglmm_2.32 ape_5.5 [13] coda_0.19-4 ordinal_2019.12-10 ComplexHeatmap_2.8.0 umap_0.2.7.0 [17] plotrix_3.8-2 plot3D_1.4 igraph_1.2.6 aricode_1.0.0 [21] ConsensusClusterPlus_1.56.0 DESeq2_1.32.0 tximport_1.20.0 impute_1.66.0 [25] GEOquery_2.60.0 lme4_1.1-27.1 SummarizedExperiment_1.22.0 GenomicRanges_1.44.0 [29] GenomeInfoDb_1.28.4 IRanges_2.26.0 S4Vectors_0.30.2 MatrixGenerics_1.4.3 [33] matrixStats_0.61.0 Matrix_1.3-4 scMINER_0.1.0 limma_3.48.3 [37] scales_1.1.1 knitr_1.34 dplyr_1.0.7 kableExtra_1.3.4 [41] rmarkdown_2.11 reshape2_1.4.4 RColorBrewer_1.1-2 ggplot2_3.3.5 [45] Biobase_2.52.0 BiocGenerics_0.38.0 loaded via a namespace (and not attached): [1] utf8_1.2.2 reticulate_1.22 tidyselect_1.1.1 RSQLite_2.2.8 [5] AnnotationDbi_1.54.1 htmlwidgets_1.5.4 BiocParallel_1.26.2 ScaledMatrix_1.0.0 [9] munsell_0.5.0 codetools_0.2-18 misc3d_0.9-0 withr_2.4.2 [13] colorspace_2.0-2 filelock_1.0.2 rstudioapi_0.13 SingleCellExperiment_1.14.1 [17] GenomeInfoDbData_1.2.6 bit64_4.0.5 vctrs_0.3.8 generics_0.1.0 [21] xfun_0.26 BiocFileCache_2.0.0 R6_2.5.1 doParallel_1.0.16 [25] clue_0.3-59 rsvd_1.0.5 locfit_1.5-9.4 bitops_1.0-7 [29] rhdf5filters_1.4.0 cachem_1.0.6 DelayedArray_0.18.0 assertthat_0.2.1 [33] nnet_7.3-16 gtable_0.3.0 beachmat_2.8.1 Cairo_1.5-12.2 [37] rlang_0.4.11 genefilter_1.74.0 systemfonts_1.0.4 GlobalOptions_0.1.2 [41] splines_4.1.1 lazyeval_0.2.2 checkmate_2.0.0 abind_1.4-5 [45] backports_1.2.1 Hmisc_4.5-0 tensorA_0.36.2 tools_4.1.1 [49] tcltk_4.1.1 cubature_2.0.4.2 ellipsis_0.3.2 Rcpp_1.0.8 [53] plyr_1.8.6 sparseMatrixStats_1.4.2 base64enc_0.1-3 progress_1.2.2 [57] zlibbioc_1.38.0 purrr_0.3.4 RCurl_1.98-1.5 prettyunits_1.1.1 [61] rpart_4.1-15 openssl_1.4.5 GetoptLong_1.0.5 cluster_2.1.2 [65] magrittr_2.0.1 data.table_1.14.2 RSpectra_0.16-0 circlize_0.4.13 [69] hms_1.1.1 evaluate_0.14 xtable_1.8-4 XML_3.99-0.8 [73] jpeg_0.1-9 gridExtra_2.3 shape_1.4.6 compiler_4.1.1 [77] tibble_3.1.5 crayon_1.4.1 minqa_1.2.4 htmltools_0.5.2 [81] corpcor_1.6.10 tzdb_0.1.2 Formula_1.2-4 tidyr_1.1.4 [85] geneplotter_1.70.0 DBI_1.1.1 dbplyr_2.1.1 rappdirs_0.3.3 [89] boot_1.3-28 babelgene_21.4 readr_2.0.1 pkgconfig_2.0.3 [93] numDeriv_2016.8-1.1 foreign_0.8-81 xml2_1.3.2 foreach_1.5.1 [97] svglite_2.0.0 annotate_1.70.0 webshot_0.5.2 XVector_0.32.0 [101] rvest_1.0.1 stringr_1.4.0 digest_0.6.28 graph_1.70.0 [105] Biostrings_2.60.2 htmlTable_2.2.1 DelayedMatrixStats_1.14.3 GSEABase_1.54.0 [109] curl_4.3.2 rjson_0.2.20 nloptr_1.2.2.2 lifecycle_1.0.1 [113] nlme_3.1-152 jsonlite_1.7.2 Rhdf5lib_1.14.2 viridisLite_0.4.0 [117] askpass_1.1 fansi_0.5.0 pillar_1.6.3 lattice_0.20-44 [121] KEGGREST_1.32.0 fastmap_1.1.0 httr_1.4.2 survival_3.2-11 [125] glue_1.4.2 zip_2.2.0 png_0.1-7 iterators_1.0.13 [129] bit_4.0.4 HDF5Array_1.20.0 stringi_1.7.4 blob_1.2.2 [133] BiocSingular_1.8.1 latticeExtra_0.6-29 memoise_2.0.0 ucminf_1.1-4 [137] irlba_2.3.3 Python session info >>> import MICA >>> import session_info >>> session_info.show() ----- MICA NA session_info 1.0.0 ----- Python 3.8.10 | packaged by conda-forge | (default, Sep 13 2021, 21:46:58) [GCC 9.4.0] Linux-3.10.0-1160.15.2.el7.x86_64-x86_64-with-glibc2.10 ----- Session information updated at 2022-02-15 11:56","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#dependencies","text":"scMINER requires R version >= 4.0.5 and Python version == 3.7.6 to run. We recommend using Miniconda to create and manage the environments.","title":"Dependencies"},{"location":"install/#installing-scminer","text":"","title":"Installing scMINER"},{"location":"install/#install-scminer-r-package","text":"To install from GitHub master branch install.packages('devtools') # install devtools package first devtools::install_github(\"jyyulab/scMINER\", ref='master', dependencies='Depends') or to clone from https://github.com/jyyulab/scMINER/ and install from source files: devtools::install(pkg='.',dependencies=TRUE) # Install the package with dependencies. devtools::install_deps(pkg = \".\", dependencies = TRUE) # Install package dependencies if needed. or to download the released tar.gz file is under project space, you can install via: devtools::install(pkg='scMINER_0.1.0.tar.gz', dependencies=TRUE)","title":"Install scMINER R package"},{"location":"install/#install-mica-python-package","text":"To install the package from PyPI: pip install MICA or to install from source: git clone https://github.com/jyyulab/MICA cd MICA python setup.py install","title":"Install MICA python package"},{"location":"install/#install-sjaracne-python-package","text":"As the core SJARACNe functions were implemented in C++ which requires compiling, we recommend using installing from source: git clone https://github.com/jyyulab/SJARACNe cd SJARACNe python setup.py build python setup.py install","title":"Install SJARACNe python package"},{"location":"install/#r-session-info","text":"> sessionInfo() R version 4.1.1 (2021-08-10) Platform: x86_64-apple-darwin17.0 (64-bit) Running under: macOS Monterey 12.2.1 Matrix products: default LAPACK: /Library/Frameworks/R.framework/Versions/4.1/Resources/lib/libRlapack.dylib locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 attached base packages: [1] grid stats4 parallel stats graphics grDevices utils datasets methods base other attached packages: [1] NetBID2_2.0.3 plotly_4.9.4.1 rhdf5_2.36.0 openxlsx_4.2.4 [5] msigdbr_7.4.1 GSVA_1.40.1 biomaRt_2.48.3 reshape_0.8.8 [9] arm_1.11-2 MASS_7.3-54 MCMCglmm_2.32 ape_5.5 [13] coda_0.19-4 ordinal_2019.12-10 ComplexHeatmap_2.8.0 umap_0.2.7.0 [17] plotrix_3.8-2 plot3D_1.4 igraph_1.2.6 aricode_1.0.0 [21] ConsensusClusterPlus_1.56.0 DESeq2_1.32.0 tximport_1.20.0 impute_1.66.0 [25] GEOquery_2.60.0 lme4_1.1-27.1 SummarizedExperiment_1.22.0 GenomicRanges_1.44.0 [29] GenomeInfoDb_1.28.4 IRanges_2.26.0 S4Vectors_0.30.2 MatrixGenerics_1.4.3 [33] matrixStats_0.61.0 Matrix_1.3-4 scMINER_0.1.0 limma_3.48.3 [37] scales_1.1.1 knitr_1.34 dplyr_1.0.7 kableExtra_1.3.4 [41] rmarkdown_2.11 reshape2_1.4.4 RColorBrewer_1.1-2 ggplot2_3.3.5 [45] Biobase_2.52.0 BiocGenerics_0.38.0 loaded via a namespace (and not attached): [1] utf8_1.2.2 reticulate_1.22 tidyselect_1.1.1 RSQLite_2.2.8 [5] AnnotationDbi_1.54.1 htmlwidgets_1.5.4 BiocParallel_1.26.2 ScaledMatrix_1.0.0 [9] munsell_0.5.0 codetools_0.2-18 misc3d_0.9-0 withr_2.4.2 [13] colorspace_2.0-2 filelock_1.0.2 rstudioapi_0.13 SingleCellExperiment_1.14.1 [17] GenomeInfoDbData_1.2.6 bit64_4.0.5 vctrs_0.3.8 generics_0.1.0 [21] xfun_0.26 BiocFileCache_2.0.0 R6_2.5.1 doParallel_1.0.16 [25] clue_0.3-59 rsvd_1.0.5 locfit_1.5-9.4 bitops_1.0-7 [29] rhdf5filters_1.4.0 cachem_1.0.6 DelayedArray_0.18.0 assertthat_0.2.1 [33] nnet_7.3-16 gtable_0.3.0 beachmat_2.8.1 Cairo_1.5-12.2 [37] rlang_0.4.11 genefilter_1.74.0 systemfonts_1.0.4 GlobalOptions_0.1.2 [41] splines_4.1.1 lazyeval_0.2.2 checkmate_2.0.0 abind_1.4-5 [45] backports_1.2.1 Hmisc_4.5-0 tensorA_0.36.2 tools_4.1.1 [49] tcltk_4.1.1 cubature_2.0.4.2 ellipsis_0.3.2 Rcpp_1.0.8 [53] plyr_1.8.6 sparseMatrixStats_1.4.2 base64enc_0.1-3 progress_1.2.2 [57] zlibbioc_1.38.0 purrr_0.3.4 RCurl_1.98-1.5 prettyunits_1.1.1 [61] rpart_4.1-15 openssl_1.4.5 GetoptLong_1.0.5 cluster_2.1.2 [65] magrittr_2.0.1 data.table_1.14.2 RSpectra_0.16-0 circlize_0.4.13 [69] hms_1.1.1 evaluate_0.14 xtable_1.8-4 XML_3.99-0.8 [73] jpeg_0.1-9 gridExtra_2.3 shape_1.4.6 compiler_4.1.1 [77] tibble_3.1.5 crayon_1.4.1 minqa_1.2.4 htmltools_0.5.2 [81] corpcor_1.6.10 tzdb_0.1.2 Formula_1.2-4 tidyr_1.1.4 [85] geneplotter_1.70.0 DBI_1.1.1 dbplyr_2.1.1 rappdirs_0.3.3 [89] boot_1.3-28 babelgene_21.4 readr_2.0.1 pkgconfig_2.0.3 [93] numDeriv_2016.8-1.1 foreign_0.8-81 xml2_1.3.2 foreach_1.5.1 [97] svglite_2.0.0 annotate_1.70.0 webshot_0.5.2 XVector_0.32.0 [101] rvest_1.0.1 stringr_1.4.0 digest_0.6.28 graph_1.70.0 [105] Biostrings_2.60.2 htmlTable_2.2.1 DelayedMatrixStats_1.14.3 GSEABase_1.54.0 [109] curl_4.3.2 rjson_0.2.20 nloptr_1.2.2.2 lifecycle_1.0.1 [113] nlme_3.1-152 jsonlite_1.7.2 Rhdf5lib_1.14.2 viridisLite_0.4.0 [117] askpass_1.1 fansi_0.5.0 pillar_1.6.3 lattice_0.20-44 [121] KEGGREST_1.32.0 fastmap_1.1.0 httr_1.4.2 survival_3.2-11 [125] glue_1.4.2 zip_2.2.0 png_0.1-7 iterators_1.0.13 [129] bit_4.0.4 HDF5Array_1.20.0 stringi_1.7.4 blob_1.2.2 [133] BiocSingular_1.8.1 latticeExtra_0.6-29 memoise_2.0.0 ucminf_1.1-4 [137] irlba_2.3.3","title":"R session info"},{"location":"install/#python-session-info","text":">>> import MICA >>> import session_info >>> session_info.show() ----- MICA NA session_info 1.0.0 ----- Python 3.8.10 | packaged by conda-forge | (default, Sep 13 2021, 21:46:58) [GCC 9.4.0] Linux-3.10.0-1160.15.2.el7.x86_64-x86_64-with-glibc2.10 ----- Session information updated at 2022-02-15 11:56","title":"Python session info"},{"location":"tutorials/CD8T/","text":"scMINER Guided Analysis on WT and KO CD8+ T cell in chronic infection model TOX is a master transcription factor for CD8+ T cell exhaustion during chronic infection. This tutorial introduce you scMINER's basic analysis using a WT and TOX KO CD8+ T dataset (GSE119940) [ Yao et al., Nat Immunol 2019 ]. Data loading and preprocessing Read 10x genomics data We start by reading WT and KO data with function readscRNAseqData() . This function reads data from either 10x genomics standard output files (usually contains three individual files: matrix.mtx, barcodes.tsv, features.tsv) or other text files by passing arguments to read.delim() . The function creates a SparseExpressionSet object adapted from ExpressionSet class if set CreateSparseEset=T ; otherwise, it creates a list object that stores expression data, feature data and sample data under three separate slots. If add.meta=T , then additional sample info such as total number of UMI will be calculated and stored in the object. The following command sets is.10x=T , CreateSparseEset = F , and add.meta=F . # Create a SparseExpressionSet object with meta info d.WT <- readscRNAseqData(file = \"./D7WT/\", is.10x = T, CreateSparseEset = F, add.meta = F) d.KO <- readscRNAseqData(file = \"./D7TOXKO/\", is.10x = T, CreateSparseEset =F, add.meta = F) Then a merged WT and KO SparseEset object can be created by using CreateSparseEset() function. # merge WT and KO dataset colnames(d.WT$raw.data)<-paste0(\"WT_\",colnames(d.WT$raw.data)) colnames(d.KO$raw.data)<-paste0(\"KO_\",colnames(d.KO$raw.data)) mat<-cbind(d.WT$raw.data,d.KO$raw.data) meta.data.WT<-d.WT$meta.data meta.data.WT$group<-'WT' meta.data.KO<-d.KO$meta.data meta.data.KO$group<-'KO' rownames(meta.data.WT)<-paste0(\"WT_\",rownames(meta.data.WT)) rownames(meta.data.KO)<-paste0(\"KO_\",rownames(meta.data.KO)) meta.data<-rbind(meta.data.WT,meta.data.KO) # Set add.meta=T to run the quality control and store the info in the object eset.raw<-CreateSparseEset(data=mat,meta.data = meta.data,feature.data = d.WT$feature.data,add.meta = T) Quality control and data filtering Quality control assessments can be performed using draw.scRNAseq.QC() function, which outputs a html report generated through Rmarkdown CD8T_scRNAseq_QC.html . The report includes three essential quality control figures at both gene and cell levels. Suggested cutoffs will be returned as a list if set output.cutoff=TRUE . cfs<-draw.scRNAseq.QC(SparseEset = eset.raw,project.name = \"CD8T\",plot.dir = \"./\") The histogram plot visualizes a distribution of expressed genes among each cells. The blue vertical line shows the recommended cutoff (0.5% * number of cells) to filter lowly expressed cells. The violin plot visualizes the total UMI count and the total number of genes expressed in violin plots. Horizontal blue line indicates suggested high/low cutoffs. Suggested thresholds were computed based on Median \u00b1 3 * MAD (maximum absolute deviance). Suggested threshold numbers are also printed right above blue lines in labels. The scatter plot shows mitochondrial gene expression percentage, and spike-in genes expression percentage (if spike-in genes exist) for each cell vs. the total number of UMIs. Cells with a high percentage of mitochondrial gene expression but a low total number of UMI counts are often considered as low quality cells (above the horizontal line). We recommend using the thresholds in cutoffs list returned by draw.scRNAseq.QC() function. # Perform the actual filtering eset.sel <- preMICA.filtering(SparseEset = eset.raw, cutoffs = cfs) Normalization and transformation We recommend count per million reads (CPM) normalization and log2 transformation (required) for performing MICA clustering analysis. norm = 1e6 exp.norm <- sweep(exprs(eset.sel), 2, norm/unname(Matrix::colSums(exprs(eset.sel))), '*') # log transformation (required by MICA) exp.log2 <- log(exp.norm + 1, base = 2) # save as SparseEset eset.log2 <- CreateSparseEset(data=exp.log2, meta.data = pData(eset.sel), feature.data = fData(eset.sel), add.meta = F) Perform clustering analysis via MICA After reviewing all the QC plots and finishing filtering, it is ready to perform clustering analysis. MICA is implemented in Python as a standalone command line tool. Thus we suggest saving your working directory and R session prior to running MICA. Generate MICA input generateMICAinput() function takes a log transformed expression matrix as input, and outputs a cell by gene matrix stored in .h5 (default) or .txt file as input to MICA. # Prepare MICA input generateMICAinput(d= exp.log2 ,filename=\"../MICA/CD8T_MICA_input.txt\") # (optional) Clean working environment rm(exp.log2) rm(exp.norm) Run MICA from the command line Pick a MICA command to run in a command line environment based on the number of cells of your dataset. For dataset with less than 5k cells, MICA MDS mode is recommended. mica lsf -j config_cwlexec.json -i ./MICA/CD8T_MICA_input.txt -p TOXKO -k 2 3 4 5 6 7 8 9 10 -o ./MICA/ -b 10 -dr MDS -v umap -d 0.01 -sn 1000 Here, -p specifies a project name for naming the output files; -k is an array of integers delimited by a single space, where each integer specifies a k to perform a k-mean clustering; Read MICA output Function readMICAoutput() adds MICA clustering results to the SparseEset object created before, which will be the major data structure for downstream analysis. Note: All the functions for downstream analysis are compatible with both expressionSet and SparseExpressionSet . After choosing a clustering result based on known cell type signatures or silhouette scores (provided by GE mode). The clustering labels can be saved to eset$ClusterRes by setting load_ClusterRes as TRUE. # Load clustering results eset.CD8T <- readMICAoutput(eset = eset.log2, load_ClusterRes = TRUE, output_file = \"MICA/TOXKO_k2_umap_ClusterMem.txt\") MICAplot() function can be used to visualize MICA clustering results using ggplot . # X, Y, color_by specify coordinate and clustering label entries in the eset phenoData; # pct is the size of the point eset.CD8T$genotype<-factor(eset.CD8T$group,levels = c(\"KO\",\"WT\")) MICAplot(input_eset = eset.CD8T, # label to print on x or y axis X = \"X\", Y=\"Y\", # which meta variable was treated as x or y coordinates color_by = \"genotype\", pct = 0.6,show_label = F,label.size = 4)+ theme( axis.title = element_text(size=18, face=\"bold\"), axis.text = element_text(size=18),legend.title = element_blank() )+xlab(\"UMAP_1\")+ylab(\"UMAP_2\") WT and KO cell network generation via SJARACNe Generate SJARACNe input generateSJAracneInput() functions uses the annotated cell type information stored in pData([your_expressionSet]) to generate inputs for running SJARACNe from the command line. The function partitions the input expression matrix and performs essential filtering (filter out not expressed genes in a cluster) to ensure a reliable network construction. funcType is required to specify the type of the network. If set funcType=\"TF\" , a reference transcription factor list will be loaded automatically without manual input. However, you do need to define species information for your data using under ref . This function creates one directory containing the required inputs (filtered expression matrix in .exp format and filtered TF list in .txt format) for each cell type. generateSJARACNeInput( input_eset = eset.CD8T, funcType = \"TF\", ref = \"mm\", #mouse wd.src = \"SJAR_CD8T/SJAR_TF\", #Output directory group_tag = \"genotype\") generateSJARACNeInput( input_eset = eset.CD8T, funcType = \"SIG\", ref = \"mm\", #mouse wd.src = \"SJAR_CD8T/SJAR_SIG\", #Output directory group_tag = \"genotype\") Run SJARACNe from the command line SJARACNe works as a separate module which was implemented in python and C++, refer to SJARACNe github page for installation and basic usage. Please save your working directory before running SJARACNe. Here we provide an example to print SJARACNe commands for IBM LSF platform. indir = ./SJARACNe cd $indir for i in $(ls -d */ | cut -f1 -d'/'); do echo sjaracne lsf -j $indir/config_cwlexec.json -e $indir/${i}/*.exp -g $indir/${i}/tf/*.txt -n 100 -o $indir/${i}/tf -pc 0.01; done Identify genotype-specific hidden drivers via MINIE Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight. Calculate activity Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are integrated via function GetActivityFromSJARACNe() . This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set save_network_files=TRUE . Please note that this function could only work if you used generateSJARACNeInput to create SJARACNe input directory and files. Since scRNA-seq data is extremely sparse and noisy, please set activity.method as 'unweighted' . acs.CD8T_tf <- GetActivityFromSJARACNe( SJARACNe_output_path =\"./\", SJARACNe_input_eset = eset.CD8T, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"genotype\", # which group was used to partition expression profiles save_network_file=TRUE, functype=\"tf\",# whether or not save network for each group save_path=\"./networks_tf/\") acs.CD8T_sig <- GetActivityFromSJARACNe( SJARACNe_output_path =\"./\", SJARACNe_input_eset = eset.CD8T, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"genotype\", # which group was used to partition expression profiles save_network_file=TRUE, functype=\"tf\",# whether or not save network for each group save_path=\"./networks_sig/\") Driver estimation by differential activity analysis The function get.DA() was designed to perform differential activity analysis from SJARACNe inferred activity matrix. In this function, two-sided student's t-test will be performed to compare mean activity from one cell type V.S. the others. It will return a data frame that includes all TF occurred in original data. Statistics such as t.statistics, p-value, 95%CI, etc. are output to help identify hidden drivers. You can save it to file in order to check them manually. DAG_result_tf <- get.DA(input_eset = acs.CD8T_tf, group_tag = \"genotype\") DAG_result_sig <- get.DA(input_eset = acs.CD8T_sig, group_tag = \"genotype\") We also offer a function called get.Topdrivers to help picking top drivers for each cell type. You can specify n as maximum number of top drivers to pick, and degree_filter to restrict number of targets. TF_list <- get.Topdrivers(DAG_result = DAG_result_tf, celltype = levels(acs.CD8T_tf$genotype), # ensure cluster order n = 5, degree_filter = c(50,600)) #check postive controls p <- feature_vlnplot(input_eset = acs.CD8T_tf, feature = \"geneSymbol\", target=c(\"TOX\",\"TCF7\"), ylabel = \"Activity\", group_by = \"genotype\", ncol=2) To perform more advanced network analysis utilizing SJARACNe generated cell type specific networks, please refer to pages Network visualization and Driver target function analysis .","title":"KO vs. WT analysis on CD8+ T cells"},{"location":"tutorials/CD8T/#scminer-guided-analysis-on-wt-and-ko-cd8-t-cell-in-chronic-infection-model","text":"TOX is a master transcription factor for CD8+ T cell exhaustion during chronic infection. This tutorial introduce you scMINER's basic analysis using a WT and TOX KO CD8+ T dataset (GSE119940) [ Yao et al., Nat Immunol 2019 ].","title":"scMINER Guided Analysis on WT and KO CD8+ T cell in chronic infection model"},{"location":"tutorials/CD8T/#data-loading-and-preprocessing","text":"","title":"Data loading and preprocessing"},{"location":"tutorials/CD8T/#read-10x-genomics-data","text":"We start by reading WT and KO data with function readscRNAseqData() . This function reads data from either 10x genomics standard output files (usually contains three individual files: matrix.mtx, barcodes.tsv, features.tsv) or other text files by passing arguments to read.delim() . The function creates a SparseExpressionSet object adapted from ExpressionSet class if set CreateSparseEset=T ; otherwise, it creates a list object that stores expression data, feature data and sample data under three separate slots. If add.meta=T , then additional sample info such as total number of UMI will be calculated and stored in the object. The following command sets is.10x=T , CreateSparseEset = F , and add.meta=F . # Create a SparseExpressionSet object with meta info d.WT <- readscRNAseqData(file = \"./D7WT/\", is.10x = T, CreateSparseEset = F, add.meta = F) d.KO <- readscRNAseqData(file = \"./D7TOXKO/\", is.10x = T, CreateSparseEset =F, add.meta = F) Then a merged WT and KO SparseEset object can be created by using CreateSparseEset() function. # merge WT and KO dataset colnames(d.WT$raw.data)<-paste0(\"WT_\",colnames(d.WT$raw.data)) colnames(d.KO$raw.data)<-paste0(\"KO_\",colnames(d.KO$raw.data)) mat<-cbind(d.WT$raw.data,d.KO$raw.data) meta.data.WT<-d.WT$meta.data meta.data.WT$group<-'WT' meta.data.KO<-d.KO$meta.data meta.data.KO$group<-'KO' rownames(meta.data.WT)<-paste0(\"WT_\",rownames(meta.data.WT)) rownames(meta.data.KO)<-paste0(\"KO_\",rownames(meta.data.KO)) meta.data<-rbind(meta.data.WT,meta.data.KO) # Set add.meta=T to run the quality control and store the info in the object eset.raw<-CreateSparseEset(data=mat,meta.data = meta.data,feature.data = d.WT$feature.data,add.meta = T)","title":"Read 10x genomics data"},{"location":"tutorials/CD8T/#quality-control-and-data-filtering","text":"Quality control assessments can be performed using draw.scRNAseq.QC() function, which outputs a html report generated through Rmarkdown CD8T_scRNAseq_QC.html . The report includes three essential quality control figures at both gene and cell levels. Suggested cutoffs will be returned as a list if set output.cutoff=TRUE . cfs<-draw.scRNAseq.QC(SparseEset = eset.raw,project.name = \"CD8T\",plot.dir = \"./\") The histogram plot visualizes a distribution of expressed genes among each cells. The blue vertical line shows the recommended cutoff (0.5% * number of cells) to filter lowly expressed cells. The violin plot visualizes the total UMI count and the total number of genes expressed in violin plots. Horizontal blue line indicates suggested high/low cutoffs. Suggested thresholds were computed based on Median \u00b1 3 * MAD (maximum absolute deviance). Suggested threshold numbers are also printed right above blue lines in labels. The scatter plot shows mitochondrial gene expression percentage, and spike-in genes expression percentage (if spike-in genes exist) for each cell vs. the total number of UMIs. Cells with a high percentage of mitochondrial gene expression but a low total number of UMI counts are often considered as low quality cells (above the horizontal line). We recommend using the thresholds in cutoffs list returned by draw.scRNAseq.QC() function. # Perform the actual filtering eset.sel <- preMICA.filtering(SparseEset = eset.raw, cutoffs = cfs)","title":"Quality control and data filtering"},{"location":"tutorials/CD8T/#normalization-and-transformation","text":"We recommend count per million reads (CPM) normalization and log2 transformation (required) for performing MICA clustering analysis. norm = 1e6 exp.norm <- sweep(exprs(eset.sel), 2, norm/unname(Matrix::colSums(exprs(eset.sel))), '*') # log transformation (required by MICA) exp.log2 <- log(exp.norm + 1, base = 2) # save as SparseEset eset.log2 <- CreateSparseEset(data=exp.log2, meta.data = pData(eset.sel), feature.data = fData(eset.sel), add.meta = F)","title":"Normalization and transformation"},{"location":"tutorials/CD8T/#perform-clustering-analysis-via-mica","text":"After reviewing all the QC plots and finishing filtering, it is ready to perform clustering analysis. MICA is implemented in Python as a standalone command line tool. Thus we suggest saving your working directory and R session prior to running MICA.","title":"Perform clustering analysis via MICA"},{"location":"tutorials/CD8T/#generate-mica-input","text":"generateMICAinput() function takes a log transformed expression matrix as input, and outputs a cell by gene matrix stored in .h5 (default) or .txt file as input to MICA. # Prepare MICA input generateMICAinput(d= exp.log2 ,filename=\"../MICA/CD8T_MICA_input.txt\") # (optional) Clean working environment rm(exp.log2) rm(exp.norm)","title":"Generate MICA input"},{"location":"tutorials/CD8T/#run-mica-from-the-command-line","text":"Pick a MICA command to run in a command line environment based on the number of cells of your dataset. For dataset with less than 5k cells, MICA MDS mode is recommended. mica lsf -j config_cwlexec.json -i ./MICA/CD8T_MICA_input.txt -p TOXKO -k 2 3 4 5 6 7 8 9 10 -o ./MICA/ -b 10 -dr MDS -v umap -d 0.01 -sn 1000 Here, -p specifies a project name for naming the output files; -k is an array of integers delimited by a single space, where each integer specifies a k to perform a k-mean clustering;","title":"Run MICA from the command line"},{"location":"tutorials/CD8T/#read-mica-output","text":"Function readMICAoutput() adds MICA clustering results to the SparseEset object created before, which will be the major data structure for downstream analysis. Note: All the functions for downstream analysis are compatible with both expressionSet and SparseExpressionSet . After choosing a clustering result based on known cell type signatures or silhouette scores (provided by GE mode). The clustering labels can be saved to eset$ClusterRes by setting load_ClusterRes as TRUE. # Load clustering results eset.CD8T <- readMICAoutput(eset = eset.log2, load_ClusterRes = TRUE, output_file = \"MICA/TOXKO_k2_umap_ClusterMem.txt\") MICAplot() function can be used to visualize MICA clustering results using ggplot . # X, Y, color_by specify coordinate and clustering label entries in the eset phenoData; # pct is the size of the point eset.CD8T$genotype<-factor(eset.CD8T$group,levels = c(\"KO\",\"WT\")) MICAplot(input_eset = eset.CD8T, # label to print on x or y axis X = \"X\", Y=\"Y\", # which meta variable was treated as x or y coordinates color_by = \"genotype\", pct = 0.6,show_label = F,label.size = 4)+ theme( axis.title = element_text(size=18, face=\"bold\"), axis.text = element_text(size=18),legend.title = element_blank() )+xlab(\"UMAP_1\")+ylab(\"UMAP_2\")","title":"Read MICA output"},{"location":"tutorials/CD8T/#wt-and-ko-cell-network-generation-via-sjaracne","text":"","title":"WT and KO cell network generation via SJARACNe"},{"location":"tutorials/CD8T/#generate-sjaracne-input","text":"generateSJAracneInput() functions uses the annotated cell type information stored in pData([your_expressionSet]) to generate inputs for running SJARACNe from the command line. The function partitions the input expression matrix and performs essential filtering (filter out not expressed genes in a cluster) to ensure a reliable network construction. funcType is required to specify the type of the network. If set funcType=\"TF\" , a reference transcription factor list will be loaded automatically without manual input. However, you do need to define species information for your data using under ref . This function creates one directory containing the required inputs (filtered expression matrix in .exp format and filtered TF list in .txt format) for each cell type. generateSJARACNeInput( input_eset = eset.CD8T, funcType = \"TF\", ref = \"mm\", #mouse wd.src = \"SJAR_CD8T/SJAR_TF\", #Output directory group_tag = \"genotype\") generateSJARACNeInput( input_eset = eset.CD8T, funcType = \"SIG\", ref = \"mm\", #mouse wd.src = \"SJAR_CD8T/SJAR_SIG\", #Output directory group_tag = \"genotype\")","title":"Generate SJARACNe input"},{"location":"tutorials/CD8T/#run-sjaracne-from-the-command-line","text":"SJARACNe works as a separate module which was implemented in python and C++, refer to SJARACNe github page for installation and basic usage. Please save your working directory before running SJARACNe. Here we provide an example to print SJARACNe commands for IBM LSF platform. indir = ./SJARACNe cd $indir for i in $(ls -d */ | cut -f1 -d'/'); do echo sjaracne lsf -j $indir/config_cwlexec.json -e $indir/${i}/*.exp -g $indir/${i}/tf/*.txt -n 100 -o $indir/${i}/tf -pc 0.01; done","title":"Run SJARACNe from the command line"},{"location":"tutorials/CD8T/#identify-genotype-specific-hidden-drivers-via-minie","text":"Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight.","title":"Identify genotype-specific hidden drivers via MINIE"},{"location":"tutorials/CD8T/#calculate-activity","text":"Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are integrated via function GetActivityFromSJARACNe() . This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set save_network_files=TRUE . Please note that this function could only work if you used generateSJARACNeInput to create SJARACNe input directory and files. Since scRNA-seq data is extremely sparse and noisy, please set activity.method as 'unweighted' . acs.CD8T_tf <- GetActivityFromSJARACNe( SJARACNe_output_path =\"./\", SJARACNe_input_eset = eset.CD8T, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"genotype\", # which group was used to partition expression profiles save_network_file=TRUE, functype=\"tf\",# whether or not save network for each group save_path=\"./networks_tf/\") acs.CD8T_sig <- GetActivityFromSJARACNe( SJARACNe_output_path =\"./\", SJARACNe_input_eset = eset.CD8T, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"genotype\", # which group was used to partition expression profiles save_network_file=TRUE, functype=\"tf\",# whether or not save network for each group save_path=\"./networks_sig/\")","title":"Calculate activity"},{"location":"tutorials/CD8T/#driver-estimation-by-differential-activity-analysis","text":"The function get.DA() was designed to perform differential activity analysis from SJARACNe inferred activity matrix. In this function, two-sided student's t-test will be performed to compare mean activity from one cell type V.S. the others. It will return a data frame that includes all TF occurred in original data. Statistics such as t.statistics, p-value, 95%CI, etc. are output to help identify hidden drivers. You can save it to file in order to check them manually. DAG_result_tf <- get.DA(input_eset = acs.CD8T_tf, group_tag = \"genotype\") DAG_result_sig <- get.DA(input_eset = acs.CD8T_sig, group_tag = \"genotype\") We also offer a function called get.Topdrivers to help picking top drivers for each cell type. You can specify n as maximum number of top drivers to pick, and degree_filter to restrict number of targets. TF_list <- get.Topdrivers(DAG_result = DAG_result_tf, celltype = levels(acs.CD8T_tf$genotype), # ensure cluster order n = 5, degree_filter = c(50,600)) #check postive controls p <- feature_vlnplot(input_eset = acs.CD8T_tf, feature = \"geneSymbol\", target=c(\"TOX\",\"TCF7\"), ylabel = \"Activity\", group_by = \"genotype\", ncol=2) To perform more advanced network analysis utilizing SJARACNe generated cell type specific networks, please refer to pages Network visualization and Driver target function analysis .","title":"Driver estimation by differential activity analysis"},{"location":"tutorials/MICA-advanced/","text":"Mutual information-based clustering analysis (MICA) MICA is a clustering tool for single-cell RNA-seq data. MICA takes a preprocessed gene expression matrix as input and efficiently cluster the cells. MICA consists of the following main components: Mutual information estimation for cell-cell distance quantification Dimension reduction on the non-linear mutual information-based distance space Consensus clustering on dimension reduced spaces Clustering visualization and cell type annotation Using MICA MICA consists of two modes named by the dimension reduction techniques: multi-dimensional scaling ( MICA MDS ) mode and graph embedding ( MICA GE ) mode. The MICA MDS mode is more robust for small datasets (less than 5000 cells by default) due to its global dimension reduction nature; the MICA GE mode works better for large datasets (more than 5000 cells) using a graph embedding approach to explore distant neighbor cells. MICA GE mode As mentioned above, the MICA GE mode reduces the dimensionality using the graph embedding method. It sweeps a range of resolutions to perform Louvain clustering for each resolution in the range. It also performs silouette analysis as an reference for the selecting of the optimal number of clusters. MICA GE commands The simplest way to MICA GE mode is to provide mica ge a preprocessed expression matrix file in either .h5ad or .txt format, and a path to an output directory. mica ge -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs The default number of workers to run in parallel is 1 . To increase the number of workers (recommended), use -nw option. mica ge -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs -nw 25 To increase the upper limit of the range of resolutions to 4.0 , use -ar option; to decrease the step size for sweeping resolutions to 0.1 , use -ss option. mica ge -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs -nw 25 -ar 4.0 -ss 0.1 See below the description of other parameters. Description of output files Typical MICA GE mode output files include: clustered.h5ad : a .h5ad file with preprocessed gene expression matrix, cell and gene meta information and clustering results included. silhouette_avg.txt : a .txt file with four columns dimension, resolution, num_clusters and silhouette_avg. silhouette_avg is the average silhouette scores of all the cells. In theory, a higher silhouette_avg value indicates a purer clustering result. However, the peak silhouette_avg value is usually biased towards fewer number of clusters. It is recommended to check a few clustering results whose silhouette_avg values are close to the peak silhouette_avg value. For example, the peak silhouette_avg value for the PBMC14k dataset corresponds to the clustering results with 4 clusters; the clustering results with 7 clusters (known 7 sorted populations) have relatively smaller silhouette_avg values. dimension resolution num_clusters silhouette_avg 24 2.71828 7 0.5391235947608948 24 3.00417 7 0.539175271987915 24 3.32012 6 0.5465611219406128 24 3.6693 6 0.5463876128196716 24 4.0552 6 0.5127292275428772 24 4.48169 6 0.512337863445282 24 4.95303 6 0.5124161839485168 24 5.47395 5 0.4783124029636383 24 6.04965 5 0.5457172393798828 24 6.68589 5 0.5456818342208862 24 7.38906 5 0.54740309715271 24 8.16617 4 0.6289374232292175 24 9.02501 4 0.6288570761680603 For each Louvain clustering resolution, MICA GE generates three output files. clustering_UMAP_euclidean_24_3.6693.txt : a tab-delimited text file with four columns ID (cell barcode ID), X , Y (UMAP or tSNE coordinates), label (predicted clustering label). euclidean in the file name indicates the distance function used for the clustering on the embedded space, 24 is the number of reduced dimensions, 3.6693 is the Louvain clustering resolution. ID X Y label CACTTTGACGCAAT -4.6490397 14.635475 1 GTTACGGAAACGAA -4.099431 11.762381 1 AGTCACGACAGGAG -4.75394 3.9216163 4 TTCGAGGACCAGTA -5.1016173 4.8917494 4 CACTTATGAGTCGT -3.1518545 15.187379 1 GCATGTGATTCTGT -3.6067667 14.740933 1 TAGAATACGTATCG -4.634878 12.530589 1 clustering_UMAP_euclidean_24_3.6693.pdf : an UMAP plot file whose name schema is the same as above clustering label file. silhouette_2_6_3.6693.pdf : a silhouette plot file, where 2 is the number of UMAP dimensions, 6 is the number of clusters. Description of important parameters MICA GE exposes a number of useful optional command-line parameters to the user. The particularly important ones are explained here, but you can always run mica ge -h to see them all. --num-neighbors-mi Number of neighbors to build mutual information-based nearest neighbor graph. The default value is 80 . This parameter has a significant impact on the clustering performance and run time. --num-walks Number of workers to run in parallel. The default value is 1 . We suggest using 25 . The parallelizable steps are MI-based kNN, dimension reduction and UMAP visualization. --num-neighbor-euclidean Number of neighbors to build euclidean distance-based nearest neighbor graph after dimension reduction. The default value is 20 . This parameter affects clustering performance and maximum memory usage. --num-walks Number of random walks per source for the node2vec graph embedding. The default value is 110. --window-size Context window size of a random walk for the node2vec graph embedding. The default value is 10. --hyper-p Hyperparameter p controls the likelihood of immediately traveling back to a node recently traversed of a random walk. The default value is 2.8. --hyper-q Hyperparameter q controls the likelihood of walking away from the previous node of a random walk. The default value is 0.4. Note : all the parameter tunings with respect to clustering performance, run time and maximum memory usage are based on PBMC20k dataset. Total running time PBMC20k (20,000 cells) Step Time (s) MI-kNN 2,278 node2vec 418 clustering 60 UMAP 710 silhouette 319 total 3,785 (1.05h) Human Motor Cortex (76,533 cells) Step Time (s) MI-kNN 12,233 node2vec 1,553 clustering 401 UMAP 3,235 silhouette 4,005 total 21,427 (5.95h) MICA MDS mode The MICA MDS mode performs stable on small datasets (including bulk datasets) but the memory usage grows quadratically as the number of cells increases. k -mean is the default clustering method, which requires users to specify the number of clusters ( k in k -mean clustering). Due to the memory limitation, the workflow is implemented using common workflow language (CWL) for the scattering and gathering on the expression matrix. MICA MDS commands The simplest way to MICA MDS mode is to provide mica mds a preprocessed expression matrix file in either .h5ad or .txt format, a path to an output directory, a project name, and the number of estimated clusters (a number or a space-delimited list) of your dataset. mica mds -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs -pn PBMC3k -nc 8 9 10 Description of output files Typical MICA MDS mode output files include: project_name_k10_umap_ClusterMem.txt : a tab-delimited text file with four columns ID (cell barcode ID), X , Y (UMAP or tSNE coordinates), label (predicted clustering label). project_name in the file name is given by the parameter -p , 10 is the number of clusters. project_name_k10_umap.png : an UMAP plot file whose name schema is the same as above clustering label file. project_name_dist.h5 : a .h5ad file with the merged distance matrix. project_name_reduced.h5 : a .h5ad file with the MDS reduced matrix. Description of Important Parameters MICA MDS exposes a number of useful optional command-line parameters to the user. The particularly important ones are explained here, but you can always run mica mds -h to see them all. -dk The number of reduced dimensions used in k -mean clustering, array inputs are supported. The default value is [19] . --platform Computing platform to run the CWL workflow. Can be local (cwltool) or lsf (cwlexec). The default value is local . --config-json LSF-specific configuration file in JSON format to be used for the CWL workflow execution. Required if use lsf platform. --bootstrap The maximum number of iterations per dimension to perform k -mean clustering. The default value is 10 . --thread-number Number of workers used for multiple k -means iterations, usually equals to --bootstrap . The default value is 10 . --slice-size The number of cells per sliced matrix for scattering and gathering parallelism. The default value is 1000 .","title":"Mutual information-based clustering analysis (MICA)"},{"location":"tutorials/MICA-advanced/#mutual-information-based-clustering-analysis-mica","text":"MICA is a clustering tool for single-cell RNA-seq data. MICA takes a preprocessed gene expression matrix as input and efficiently cluster the cells. MICA consists of the following main components: Mutual information estimation for cell-cell distance quantification Dimension reduction on the non-linear mutual information-based distance space Consensus clustering on dimension reduced spaces Clustering visualization and cell type annotation","title":"Mutual information-based clustering analysis (MICA)"},{"location":"tutorials/MICA-advanced/#using-mica","text":"MICA consists of two modes named by the dimension reduction techniques: multi-dimensional scaling ( MICA MDS ) mode and graph embedding ( MICA GE ) mode. The MICA MDS mode is more robust for small datasets (less than 5000 cells by default) due to its global dimension reduction nature; the MICA GE mode works better for large datasets (more than 5000 cells) using a graph embedding approach to explore distant neighbor cells.","title":"Using MICA"},{"location":"tutorials/MICA-advanced/#mica-ge-mode","text":"As mentioned above, the MICA GE mode reduces the dimensionality using the graph embedding method. It sweeps a range of resolutions to perform Louvain clustering for each resolution in the range. It also performs silouette analysis as an reference for the selecting of the optimal number of clusters.","title":"MICA GE mode"},{"location":"tutorials/MICA-advanced/#mica-ge-commands","text":"The simplest way to MICA GE mode is to provide mica ge a preprocessed expression matrix file in either .h5ad or .txt format, and a path to an output directory. mica ge -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs The default number of workers to run in parallel is 1 . To increase the number of workers (recommended), use -nw option. mica ge -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs -nw 25 To increase the upper limit of the range of resolutions to 4.0 , use -ar option; to decrease the step size for sweeping resolutions to 0.1 , use -ss option. mica ge -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs -nw 25 -ar 4.0 -ss 0.1 See below the description of other parameters.","title":"MICA GE commands"},{"location":"tutorials/MICA-advanced/#description-of-output-files","text":"Typical MICA GE mode output files include: clustered.h5ad : a .h5ad file with preprocessed gene expression matrix, cell and gene meta information and clustering results included. silhouette_avg.txt : a .txt file with four columns dimension, resolution, num_clusters and silhouette_avg. silhouette_avg is the average silhouette scores of all the cells. In theory, a higher silhouette_avg value indicates a purer clustering result. However, the peak silhouette_avg value is usually biased towards fewer number of clusters. It is recommended to check a few clustering results whose silhouette_avg values are close to the peak silhouette_avg value. For example, the peak silhouette_avg value for the PBMC14k dataset corresponds to the clustering results with 4 clusters; the clustering results with 7 clusters (known 7 sorted populations) have relatively smaller silhouette_avg values. dimension resolution num_clusters silhouette_avg 24 2.71828 7 0.5391235947608948 24 3.00417 7 0.539175271987915 24 3.32012 6 0.5465611219406128 24 3.6693 6 0.5463876128196716 24 4.0552 6 0.5127292275428772 24 4.48169 6 0.512337863445282 24 4.95303 6 0.5124161839485168 24 5.47395 5 0.4783124029636383 24 6.04965 5 0.5457172393798828 24 6.68589 5 0.5456818342208862 24 7.38906 5 0.54740309715271 24 8.16617 4 0.6289374232292175 24 9.02501 4 0.6288570761680603 For each Louvain clustering resolution, MICA GE generates three output files. clustering_UMAP_euclidean_24_3.6693.txt : a tab-delimited text file with four columns ID (cell barcode ID), X , Y (UMAP or tSNE coordinates), label (predicted clustering label). euclidean in the file name indicates the distance function used for the clustering on the embedded space, 24 is the number of reduced dimensions, 3.6693 is the Louvain clustering resolution. ID X Y label CACTTTGACGCAAT -4.6490397 14.635475 1 GTTACGGAAACGAA -4.099431 11.762381 1 AGTCACGACAGGAG -4.75394 3.9216163 4 TTCGAGGACCAGTA -5.1016173 4.8917494 4 CACTTATGAGTCGT -3.1518545 15.187379 1 GCATGTGATTCTGT -3.6067667 14.740933 1 TAGAATACGTATCG -4.634878 12.530589 1 clustering_UMAP_euclidean_24_3.6693.pdf : an UMAP plot file whose name schema is the same as above clustering label file. silhouette_2_6_3.6693.pdf : a silhouette plot file, where 2 is the number of UMAP dimensions, 6 is the number of clusters.","title":"Description of output files"},{"location":"tutorials/MICA-advanced/#description-of-important-parameters","text":"MICA GE exposes a number of useful optional command-line parameters to the user. The particularly important ones are explained here, but you can always run mica ge -h to see them all. --num-neighbors-mi Number of neighbors to build mutual information-based nearest neighbor graph. The default value is 80 . This parameter has a significant impact on the clustering performance and run time. --num-walks Number of workers to run in parallel. The default value is 1 . We suggest using 25 . The parallelizable steps are MI-based kNN, dimension reduction and UMAP visualization. --num-neighbor-euclidean Number of neighbors to build euclidean distance-based nearest neighbor graph after dimension reduction. The default value is 20 . This parameter affects clustering performance and maximum memory usage. --num-walks Number of random walks per source for the node2vec graph embedding. The default value is 110. --window-size Context window size of a random walk for the node2vec graph embedding. The default value is 10. --hyper-p Hyperparameter p controls the likelihood of immediately traveling back to a node recently traversed of a random walk. The default value is 2.8. --hyper-q Hyperparameter q controls the likelihood of walking away from the previous node of a random walk. The default value is 0.4. Note : all the parameter tunings with respect to clustering performance, run time and maximum memory usage are based on PBMC20k dataset.","title":"Description of important parameters"},{"location":"tutorials/MICA-advanced/#total-running-time","text":"","title":"Total running time"},{"location":"tutorials/MICA-advanced/#pbmc20k-20000-cells","text":"Step Time (s) MI-kNN 2,278 node2vec 418 clustering 60 UMAP 710 silhouette 319 total 3,785 (1.05h)","title":"PBMC20k (20,000 cells)"},{"location":"tutorials/MICA-advanced/#human-motor-cortex-76533-cells","text":"Step Time (s) MI-kNN 12,233 node2vec 1,553 clustering 401 UMAP 3,235 silhouette 4,005 total 21,427 (5.95h)","title":"Human Motor Cortex (76,533 cells)"},{"location":"tutorials/MICA-advanced/#mica-mds-mode","text":"The MICA MDS mode performs stable on small datasets (including bulk datasets) but the memory usage grows quadratically as the number of cells increases. k -mean is the default clustering method, which requires users to specify the number of clusters ( k in k -mean clustering). Due to the memory limitation, the workflow is implemented using common workflow language (CWL) for the scattering and gathering on the expression matrix.","title":"MICA MDS mode"},{"location":"tutorials/MICA-advanced/#mica-mds-commands","text":"The simplest way to MICA MDS mode is to provide mica mds a preprocessed expression matrix file in either .h5ad or .txt format, a path to an output directory, a project name, and the number of estimated clusters (a number or a space-delimited list) of your dataset. mica mds -i ./test_data/inputs/10x/PBMC/3k/pre-processed/pbmc3k_preprocessed.h5ad -o ./test_data/outputs -pn PBMC3k -nc 8 9 10","title":"MICA MDS commands"},{"location":"tutorials/MICA-advanced/#description-of-output-files_1","text":"Typical MICA MDS mode output files include: project_name_k10_umap_ClusterMem.txt : a tab-delimited text file with four columns ID (cell barcode ID), X , Y (UMAP or tSNE coordinates), label (predicted clustering label). project_name in the file name is given by the parameter -p , 10 is the number of clusters. project_name_k10_umap.png : an UMAP plot file whose name schema is the same as above clustering label file. project_name_dist.h5 : a .h5ad file with the merged distance matrix. project_name_reduced.h5 : a .h5ad file with the MDS reduced matrix.","title":"Description of output files"},{"location":"tutorials/MICA-advanced/#description-of-important-parameters_1","text":"MICA MDS exposes a number of useful optional command-line parameters to the user. The particularly important ones are explained here, but you can always run mica mds -h to see them all. -dk The number of reduced dimensions used in k -mean clustering, array inputs are supported. The default value is [19] . --platform Computing platform to run the CWL workflow. Can be local (cwltool) or lsf (cwlexec). The default value is local . --config-json LSF-specific configuration file in JSON format to be used for the CWL workflow execution. Required if use lsf platform. --bootstrap The maximum number of iterations per dimension to perform k -mean clustering. The default value is 10 . --thread-number Number of workers used for multiple k -means iterations, usually equals to --bootstrap . The default value is 10 . --slice-size The number of cells per sliced matrix for scattering and gathering parallelism. The default value is 1000 .","title":"Description of Important Parameters"},{"location":"tutorials/PBMC-14k/","text":"scMINER Guided Analysis on 14k PBMCs from 10x Genomics This tutorial introduce you scMINER's basic analysis using a PBMC dataset with 10 sorted populations of 2k cells per population [ Zheng et al., 2017 ]. We remove CD34+ cells, CD4+ helper T cells, and total CD8+ cytotoxic cells from the dataset because of low sorting purity or a significant overlap with other immune cells based on the sorting strategy, which creates a new dataset with seven known cell types and 14k cells in total. The original dataset is freely available under accession number SRP073767 and Zenodo . Data loading and preprocessing Read 10x genomics data We start by reading the downsampled 10x genomics data with function readscRNAseqData() . This function reads data from either 10x genomics standard output files (usually contains three individual files: matrix.mtx, barcodes.tsv, features.tsv) or other text files by passing arguments to read.delim() . The function creates a SparseExpressionSet object adapted from ExpressionSet class if set CreateSparseEset=T ; otherwise, it creates a list object that stores expression data, feature data and sample data under three separate slots. If add.meta=T , then additional sample info such as total number of UMI will be calculated and stored in the object. The following command sets is.10x=T , CreateSparseEset = T , and add.meta=T . To load data from standard 10x genomics files, creating a SparseEset directly is recommended. # Create a SparseExpressionSet object with meta info pbmc.14k.eset <- readscRNAseqData(file = \"./PBMC14k_input/\", is.10x = T, CreateSparseEset = T, add.meta = T) The following code loads data that are not from standard 10x genomics files. # Read the data as a data.frame (not create SparseExpressionSet object or add meta info) pbmc.14k <- readscRNAseqData(file=\"./PBMC14k_input/PBMC_20k_MICA_input_filter_14k.txt\", is.10x = F, CreateSparseEset = F, add.meta = F, sep='\\t') Then a SparseEset object can be created by using CreateSparseEset() function. # Set add.meta=T to run the quality control and store the info in the object pbmc.14k.eset <- CreateSparseEset(data = t(as.matrix(pbmc.14k)), add.meta = T) # (Optional) Define your group information. If there is no additional sample info available, # just put a character here pbmc.14k.eset$group <- sapply(strsplit(pbmc.14k.eset$cellName, \"-\"), \"[\",2) Quality control and data filtering Quality control assessments can be performed using draw.scRNAseq.QC() function, which outputs a html report generated through Rmarkdown PBMC14K_QC_report.html . The report includes three essential quality control figures at both gene and cell levels. Suggested cutoffs will be returned as a list if set output.cutoff=TRUE . cutoffs <- draw.scRNAseq.QC(SparseEset = eset.14k, project.name = \"PBMC14k\", plot.dir = \"./QC/\", group = \"group\", # the meta info to group violin plots output.cutoff = TRUE) # Output suggested cutoffs The histogram plot visualizes a distribution of expressed genes among each cells. The blue vertical line shows the recommended cutoff (0.5% * number of cells) to filter lowly expressed cells. The violin plot visualizes the total UMI count and the total number of genes expressed in violin plots. Horizontal blue line indicates suggested high/low cutoffs. Suggested thresholds were computed based on Median \u00b1 3 * MAD (maximum absolute deviance). Suggested threshold numbers are also printed right above blue lines in labels. The scatter plot shows mitochondrial gene expression percentage, and spike-in genes expression percentage (if spike-in genes exist) for each cell vs. the total number of UMIs. Cells with a high percentage of mitochondrial gene expression but a low total number of UMI counts are often considered as low quality cells (above the horizontal line). We recommend using the thresholds in cutoffs list returned by draw.scRNAseq.QC() function. However, users can adjust the thresholds manually, e.g., cutoffs$umi_cf_hi <- Inf will not filter on outliers caused by a high total UMI values. # Perform the actual filtering pbmc.14k.eset.filter <- preMICA.filtering(SparseEset = pbmc.14k.eset, cutoffs = cutoffs) Normalization and transformation We recommend count per million reads (CPM) normalization and log2 transformation (required) for performing MICA clustering analysis. norm = 1e6 exp.norm <- sweep(exprs(pbmc.14k.eset.filter), 2, norm/unname(Matrix::colSums(exprs(pbmc.14k.eset.filter))), '*') # log transformation (required by MICA) exp.log2 <- log(exp.norm + 1, base = 2) # save as SparseEset pbmc.14k.eset.log2 <- CreateSparseEset(data = exp.log2, meta.data = pData(pbmc.14k.eset.filter), feature.data = fData(pbmc.14k.eset.filter), add.meta = F) Perform clustering analysis via MICA After reviewing all the QC plots and finishing filtering, it is ready to perform clustering analysis. MICA is implemented in Python as a standalone command line tool. Thus we suggest saving your working directory and R session prior to running MICA. Generate MICA input generateMICAinput() function takes a log transformed expression matrix as input, and outputs a cell by gene matrix stored in .h5 (default) or .txt file as input to MICA. # Prepare MICA input generateMICAinput(d = exp.log2 , filename = \"./PBMC14k_MICA_input.h5ad\") # (optional) Clean working environment rm(exp.log2) rm(exp.norm) Run MICA from the command line Pick a MICA command to run in a command line environment based on the number of cells of your dataset. For dataset with less than 5k cells, MICA MDS mode is recommended. mica mds -i ./PBMC14k_MICA_input.h5ad -o ./outputs -pn PBMC14k -nc 8 9 10 Here, -pn specifies a project name for naming the output files; -nc is an array of integers delimited by a single space, where each integer specifies a k to perform a k-mean clustering; -dk can be an integer or an array of integers delimited by a single space (default is 19 ), it specifies the number of dimensions used in k-mean clusterings. Use mica mds -h to see more options of MICA MDS mode. For datasets with more than 5k cells, MICA GE mode is recommended. mica ge -i ./PBMC14k_MICA_input.h5ad -o ./outputs -ar 4.0 -ss 0.1 -nw 25 -nnm 80 Here, -ar determines the maximum size of the communities (default: 3.0 ); -ss is the step size to sweep resolutions in a range (default: 0.2 ); -nw specifies the number of workers to run in parallel (default: 1 ); -nnm is the number of neighbors to build mutual information-based nearest neighbor graph (default 80 ). Use mica ge -h to find more options of MICA GE mode. A more detailed description of output files and important parameters can be found in Mutual information-based clustering analysis (MICA) page. Read MICA output Function readMICAoutput() adds MICA clustering results to the SparseEset object created before, which will be the major data structure for downstream analysis. Note: All the functions for downstream analysis are compatible with both expressionSet and SparseExpressionSet . After choosing a clustering result based on known cell type signatures or silhouette scores (provided by GE mode). The clustering labels can be saved to eset$ClusterRes by setting load_ClusterRes as TRUE. # Load clustering results pbmc.14k.eset.log2 <- readMICAoutput(eset = pbmc.14k.eset.log2, load_ClusterRes = TRUE, output_file = \"MICA/clustering_UMAP_euclidean_24_1.82212.txt\") Note in clustering_UMAP_euclidean_24_1.82212.txt , 24 is the number of reduced dimensions, 1.82212 is the resolution used for Louvain clustering. MICAplot() function can be used to visualize MICA clustering results using ggplot . # X, Y, color_by specify coordinate and clustering label entries in the eset phenoData; # pct is the size of the point MICAplot(input_eset = pbmc.14k.eset.log2, X = \"X\", Y = \"Y\", color_by = \"ClusterRes\", pct = 0.5) Cell type annotation after clustering Marker gene visualization To help with identifing the optimal number of clusters and annotating the clusters, selected marker genes can be visualized with UMAP/t-SNE scatterplots, violin plots or heatmap plots via function feature_highlighting() , feature_vlnplot() and feature_heatmap() respectively. genes_of_interest <-c(\"CD3D\", \"CD27\", \"IL7R\", \"SELL\", \"CCR7\", \"IL32\", \"GZMA\", \"GZMK\", \"DUSP2\", \"CD8A\", \"GZMH\", \"GZMB\", \"CD79A\", \"CD79B\", \"CD86\", \"CD14\") # UMAP scatter plot feature_highlighting(input_eset = pbmc.14k.eset.log2, target = genes_of_interest, feature = \"geneSymbol\", ylabel = \"log2Exp\", x = \"X\", y = \"Y\", pct.size = 0.5) # Violoin plot feature_vlnplot(input_eset = pbmc.14k.eset.log2, target = genes_of_interest, feature = \"geneSymbol\", group_by = \"ClusterRes\", ylabel = \"log2Exp\", ncol = 4) # Heatmap plot feature_heatmap(input_eset = pbmc.14k.eset.log2, target = genes_of_interest, group_name = \"ClusterRes\", save_plot = FALSE, width = 6, height = 6, name = \"log2Exp\") Cell type annotation With a pre-defined marker gene list, marker_bbplot() function calculates a cell type signature score (weighted mean using the given weights in the marker list) for each cluster, and visualize all the signature scores using a bubble plot. Here, we curated a list of well-known marker genes of 9 common immune cell types and use these genes to calculate a marker score for each of the predicted PBMC clusters. Note: the pre-defined marker gene list has a required format. See head(makers) below . # Read marker genes from an excel file markers <- read.xlsx(\"Immune_signatures.xlsx\") # Maker gene file has 3 required columns head(markers) celltype markers weight 1 Monocyte CD14 1 2 Monocyte FCGR3A 1 3 Monocyte FCGR3B 1 4 Monocyte PTPRC 1 5 Monocyte S100A8 1 6 Monocyte S100A9 1 # Draw a bubble plot draw.marker.bbp(ref = markers, input_eset = pbmc.14k.eset.log2, width = 6, height = 4, feature = \"geneSymbol\", group_name = \"ClusterRes\", save_plot = FALSE) Before diving into network generation section, assign the annotated cell types as factors in your expression set for keeping the current order of the clusters in following visualizations. Please do not include \"_\" in your cell type names as it would cause mis-parsing in the following analysis. . indx <- factor(x=c(\"Monocyte\", \"CD8NaiveCTL\", \"NK\", \"Bcell\", \"CD4TReg\", \"CD4TCM\", \"CD4NaiveT\"), levels=c(\"Monocyte\", \"CD8NaiveCTL\", \"NK\", \"Bcell\", \"CD4TReg\", \"CD4TCM\", \"CD4NaiveT\")) pbmc.14k.eset.log2$celltype <- indx[pbmc.14k.eset.log2$ClusterRes] Network generation via SJARACNe Generate SJARACNe input generateSJAracneInput() functions uses the annotated cell type information stored in pData([your_expressionSet]) to generate inputs for running SJARACNe from the command line. The function partitions the input expression matrix and performs essential filtering (filter out not expressed genes in a cluster) to ensure a reliable network construction. funcType is required to specify the type of the network. If set funcType=\"TF\" , a reference transcription factor list will be loaded automatically without manual input. However, you do need to define species information for your data using under ref . This function creates one directory containing the required inputs (filtered expression matrix in .exp format and filtered TF list in .txt format) for each cell type. generateSJARACNeInput( input_eset = pbmc.14k.eset.log2, funcType = \"TF\", ref = \"hg\", #human wd.src = \"SJARACNe\", #Output directory group_tag = \"celltype\") generateSJARACNeInput( input_eset = pbmc.14k.eset.log2, funcType = \"SIG\", ref = \"hg\", #human wd.src = \"SJARACNe\", #Output directory group_tag = \"celltype\") Run SJARACNe from the command line SJARACNe works as a separate module which was implemented in python and C++, refer to SJARACNe github page for installation and basic usage. Please save your working directory before running SJARACNe. Here we provide an example to print SJARACNe commands for IBM LSF platform. indir = ./SJARACNe cd $indir for i in $(ls -d */ | cut -f1 -d'/'); do echo sjaracne lsf -j $indir/config_cwlexec.json -e $indir/${i}/*.exp -g $indir/${i}/tf/*.txt -n 100 -o $indir/${i}/tf -pc 0.01; done Identify cell-type-specific hidden drivers via MINIE Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight. Calculate activity Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are integrated via function GetActivityFromSJARACNe() . This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set save_network_files=TRUE . Please note that this function could only work if you used generateSJARACNeInput() to create SJARACNe input directory and files. Since scRNA-seq data is extremely sparse and noisy, please set activity.method as 'unweighted' . acs.14k.tf <- GetActivityFromSJARACNe( SJARACNe_output_path =\"SJARACNE/\", SJARACNe_input_eset = pbmc.14k.eset.log2, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"celltype\", # which group was used to partition expression profiles save_network_file=TRUE, # whether or not save network for each group functype=\"tf\",# whether or not save network for each group save_path=\"./networks_tf/\") #default as false, but recommended to be TRUE acs.14k.sig <- GetActivityFromSJARACNe( SJARACNe_output_path =\"SJARACNE/\", SJARACNe_input_eset = pbmc.14k.eset.log2, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"celltype\", # which group was used to partition expression profiles save_network_file=TRUE, # whether or not save network for each group functype=\"tf\",# whether or not save network for each group save_path=\"./networks_sig/\") #default as false, but recommended to be TRUE Driver estimation by differential activity analysis The function get.DA() was designed to perform differential activity analysis from SJARACNe inferred activity matrix. In this function, two-sided student's t-test will be performed to compare mean activity from one cell type V.S. the others. It will return a data frame that includes all TF occurred in original data. Statistics such as t.statistics, p-value, 95%CI, etc. are output to help identify hidden drivers. You can save it to file in order to check them manually. DAG_result_tf <- get.DA(input_eset = acs.14k.tf, group_tag = \"celltype\") DAG_result_sig <- get.DA(input_eset = acs.14k.sig, group_tag = \"celltype\") We also offer a function called get.Topdrivers() to help picking top drivers for each cell type. You can specify n as maximum number of top drivers to pick, and degree_filter to restrict number of targets. TF_list <- get.Topdrivers(DAG_result = DAG_result_tf, celltype = levels(acs.14k$genotype), # ensure cluster order n = 5, degree_filter = c(50, 600)) # check postive controls p <- feature_vlnplot(input_eset = acs.14k, feature = \"geneSymbol\", target=c(\"IL7R\", \"CD14\"), ylabel = \"Activity\", group_by = \"genotype\", ncol=2) To perform more advanced network analysis utilizing SJARACNe generated cell type specific networks, please refer to pages Network visualization and Driver target function analysis .","title":"Basic analysis on PBMC (14k)"},{"location":"tutorials/PBMC-14k/#scminer-guided-analysis-on-14k-pbmcs-from-10x-genomics","text":"This tutorial introduce you scMINER's basic analysis using a PBMC dataset with 10 sorted populations of 2k cells per population [ Zheng et al., 2017 ]. We remove CD34+ cells, CD4+ helper T cells, and total CD8+ cytotoxic cells from the dataset because of low sorting purity or a significant overlap with other immune cells based on the sorting strategy, which creates a new dataset with seven known cell types and 14k cells in total. The original dataset is freely available under accession number SRP073767 and Zenodo .","title":"scMINER Guided Analysis on 14k PBMCs from 10x Genomics"},{"location":"tutorials/PBMC-14k/#data-loading-and-preprocessing","text":"","title":"Data loading and preprocessing"},{"location":"tutorials/PBMC-14k/#read-10x-genomics-data","text":"We start by reading the downsampled 10x genomics data with function readscRNAseqData() . This function reads data from either 10x genomics standard output files (usually contains three individual files: matrix.mtx, barcodes.tsv, features.tsv) or other text files by passing arguments to read.delim() . The function creates a SparseExpressionSet object adapted from ExpressionSet class if set CreateSparseEset=T ; otherwise, it creates a list object that stores expression data, feature data and sample data under three separate slots. If add.meta=T , then additional sample info such as total number of UMI will be calculated and stored in the object. The following command sets is.10x=T , CreateSparseEset = T , and add.meta=T . To load data from standard 10x genomics files, creating a SparseEset directly is recommended. # Create a SparseExpressionSet object with meta info pbmc.14k.eset <- readscRNAseqData(file = \"./PBMC14k_input/\", is.10x = T, CreateSparseEset = T, add.meta = T) The following code loads data that are not from standard 10x genomics files. # Read the data as a data.frame (not create SparseExpressionSet object or add meta info) pbmc.14k <- readscRNAseqData(file=\"./PBMC14k_input/PBMC_20k_MICA_input_filter_14k.txt\", is.10x = F, CreateSparseEset = F, add.meta = F, sep='\\t') Then a SparseEset object can be created by using CreateSparseEset() function. # Set add.meta=T to run the quality control and store the info in the object pbmc.14k.eset <- CreateSparseEset(data = t(as.matrix(pbmc.14k)), add.meta = T) # (Optional) Define your group information. If there is no additional sample info available, # just put a character here pbmc.14k.eset$group <- sapply(strsplit(pbmc.14k.eset$cellName, \"-\"), \"[\",2)","title":"Read 10x genomics data"},{"location":"tutorials/PBMC-14k/#quality-control-and-data-filtering","text":"Quality control assessments can be performed using draw.scRNAseq.QC() function, which outputs a html report generated through Rmarkdown PBMC14K_QC_report.html . The report includes three essential quality control figures at both gene and cell levels. Suggested cutoffs will be returned as a list if set output.cutoff=TRUE . cutoffs <- draw.scRNAseq.QC(SparseEset = eset.14k, project.name = \"PBMC14k\", plot.dir = \"./QC/\", group = \"group\", # the meta info to group violin plots output.cutoff = TRUE) # Output suggested cutoffs The histogram plot visualizes a distribution of expressed genes among each cells. The blue vertical line shows the recommended cutoff (0.5% * number of cells) to filter lowly expressed cells. The violin plot visualizes the total UMI count and the total number of genes expressed in violin plots. Horizontal blue line indicates suggested high/low cutoffs. Suggested thresholds were computed based on Median \u00b1 3 * MAD (maximum absolute deviance). Suggested threshold numbers are also printed right above blue lines in labels. The scatter plot shows mitochondrial gene expression percentage, and spike-in genes expression percentage (if spike-in genes exist) for each cell vs. the total number of UMIs. Cells with a high percentage of mitochondrial gene expression but a low total number of UMI counts are often considered as low quality cells (above the horizontal line). We recommend using the thresholds in cutoffs list returned by draw.scRNAseq.QC() function. However, users can adjust the thresholds manually, e.g., cutoffs$umi_cf_hi <- Inf will not filter on outliers caused by a high total UMI values. # Perform the actual filtering pbmc.14k.eset.filter <- preMICA.filtering(SparseEset = pbmc.14k.eset, cutoffs = cutoffs)","title":"Quality control and data filtering"},{"location":"tutorials/PBMC-14k/#normalization-and-transformation","text":"We recommend count per million reads (CPM) normalization and log2 transformation (required) for performing MICA clustering analysis. norm = 1e6 exp.norm <- sweep(exprs(pbmc.14k.eset.filter), 2, norm/unname(Matrix::colSums(exprs(pbmc.14k.eset.filter))), '*') # log transformation (required by MICA) exp.log2 <- log(exp.norm + 1, base = 2) # save as SparseEset pbmc.14k.eset.log2 <- CreateSparseEset(data = exp.log2, meta.data = pData(pbmc.14k.eset.filter), feature.data = fData(pbmc.14k.eset.filter), add.meta = F)","title":"Normalization and transformation"},{"location":"tutorials/PBMC-14k/#perform-clustering-analysis-via-mica","text":"After reviewing all the QC plots and finishing filtering, it is ready to perform clustering analysis. MICA is implemented in Python as a standalone command line tool. Thus we suggest saving your working directory and R session prior to running MICA.","title":"Perform clustering analysis via MICA"},{"location":"tutorials/PBMC-14k/#generate-mica-input","text":"generateMICAinput() function takes a log transformed expression matrix as input, and outputs a cell by gene matrix stored in .h5 (default) or .txt file as input to MICA. # Prepare MICA input generateMICAinput(d = exp.log2 , filename = \"./PBMC14k_MICA_input.h5ad\") # (optional) Clean working environment rm(exp.log2) rm(exp.norm)","title":"Generate MICA input"},{"location":"tutorials/PBMC-14k/#run-mica-from-the-command-line","text":"Pick a MICA command to run in a command line environment based on the number of cells of your dataset. For dataset with less than 5k cells, MICA MDS mode is recommended. mica mds -i ./PBMC14k_MICA_input.h5ad -o ./outputs -pn PBMC14k -nc 8 9 10 Here, -pn specifies a project name for naming the output files; -nc is an array of integers delimited by a single space, where each integer specifies a k to perform a k-mean clustering; -dk can be an integer or an array of integers delimited by a single space (default is 19 ), it specifies the number of dimensions used in k-mean clusterings. Use mica mds -h to see more options of MICA MDS mode. For datasets with more than 5k cells, MICA GE mode is recommended. mica ge -i ./PBMC14k_MICA_input.h5ad -o ./outputs -ar 4.0 -ss 0.1 -nw 25 -nnm 80 Here, -ar determines the maximum size of the communities (default: 3.0 ); -ss is the step size to sweep resolutions in a range (default: 0.2 ); -nw specifies the number of workers to run in parallel (default: 1 ); -nnm is the number of neighbors to build mutual information-based nearest neighbor graph (default 80 ). Use mica ge -h to find more options of MICA GE mode. A more detailed description of output files and important parameters can be found in Mutual information-based clustering analysis (MICA) page.","title":"Run MICA from the command line"},{"location":"tutorials/PBMC-14k/#read-mica-output","text":"Function readMICAoutput() adds MICA clustering results to the SparseEset object created before, which will be the major data structure for downstream analysis. Note: All the functions for downstream analysis are compatible with both expressionSet and SparseExpressionSet . After choosing a clustering result based on known cell type signatures or silhouette scores (provided by GE mode). The clustering labels can be saved to eset$ClusterRes by setting load_ClusterRes as TRUE. # Load clustering results pbmc.14k.eset.log2 <- readMICAoutput(eset = pbmc.14k.eset.log2, load_ClusterRes = TRUE, output_file = \"MICA/clustering_UMAP_euclidean_24_1.82212.txt\") Note in clustering_UMAP_euclidean_24_1.82212.txt , 24 is the number of reduced dimensions, 1.82212 is the resolution used for Louvain clustering. MICAplot() function can be used to visualize MICA clustering results using ggplot . # X, Y, color_by specify coordinate and clustering label entries in the eset phenoData; # pct is the size of the point MICAplot(input_eset = pbmc.14k.eset.log2, X = \"X\", Y = \"Y\", color_by = \"ClusterRes\", pct = 0.5)","title":"Read MICA output"},{"location":"tutorials/PBMC-14k/#cell-type-annotation-after-clustering","text":"","title":"Cell type annotation after clustering"},{"location":"tutorials/PBMC-14k/#marker-gene-visualization","text":"To help with identifing the optimal number of clusters and annotating the clusters, selected marker genes can be visualized with UMAP/t-SNE scatterplots, violin plots or heatmap plots via function feature_highlighting() , feature_vlnplot() and feature_heatmap() respectively. genes_of_interest <-c(\"CD3D\", \"CD27\", \"IL7R\", \"SELL\", \"CCR7\", \"IL32\", \"GZMA\", \"GZMK\", \"DUSP2\", \"CD8A\", \"GZMH\", \"GZMB\", \"CD79A\", \"CD79B\", \"CD86\", \"CD14\") # UMAP scatter plot feature_highlighting(input_eset = pbmc.14k.eset.log2, target = genes_of_interest, feature = \"geneSymbol\", ylabel = \"log2Exp\", x = \"X\", y = \"Y\", pct.size = 0.5) # Violoin plot feature_vlnplot(input_eset = pbmc.14k.eset.log2, target = genes_of_interest, feature = \"geneSymbol\", group_by = \"ClusterRes\", ylabel = \"log2Exp\", ncol = 4) # Heatmap plot feature_heatmap(input_eset = pbmc.14k.eset.log2, target = genes_of_interest, group_name = \"ClusterRes\", save_plot = FALSE, width = 6, height = 6, name = \"log2Exp\")","title":"Marker gene visualization"},{"location":"tutorials/PBMC-14k/#cell-type-annotation","text":"With a pre-defined marker gene list, marker_bbplot() function calculates a cell type signature score (weighted mean using the given weights in the marker list) for each cluster, and visualize all the signature scores using a bubble plot. Here, we curated a list of well-known marker genes of 9 common immune cell types and use these genes to calculate a marker score for each of the predicted PBMC clusters. Note: the pre-defined marker gene list has a required format. See head(makers) below . # Read marker genes from an excel file markers <- read.xlsx(\"Immune_signatures.xlsx\") # Maker gene file has 3 required columns head(markers) celltype markers weight 1 Monocyte CD14 1 2 Monocyte FCGR3A 1 3 Monocyte FCGR3B 1 4 Monocyte PTPRC 1 5 Monocyte S100A8 1 6 Monocyte S100A9 1 # Draw a bubble plot draw.marker.bbp(ref = markers, input_eset = pbmc.14k.eset.log2, width = 6, height = 4, feature = \"geneSymbol\", group_name = \"ClusterRes\", save_plot = FALSE) Before diving into network generation section, assign the annotated cell types as factors in your expression set for keeping the current order of the clusters in following visualizations. Please do not include \"_\" in your cell type names as it would cause mis-parsing in the following analysis. . indx <- factor(x=c(\"Monocyte\", \"CD8NaiveCTL\", \"NK\", \"Bcell\", \"CD4TReg\", \"CD4TCM\", \"CD4NaiveT\"), levels=c(\"Monocyte\", \"CD8NaiveCTL\", \"NK\", \"Bcell\", \"CD4TReg\", \"CD4TCM\", \"CD4NaiveT\")) pbmc.14k.eset.log2$celltype <- indx[pbmc.14k.eset.log2$ClusterRes]","title":"Cell type annotation"},{"location":"tutorials/PBMC-14k/#network-generation-via-sjaracne","text":"","title":"Network generation via SJARACNe"},{"location":"tutorials/PBMC-14k/#generate-sjaracne-input","text":"generateSJAracneInput() functions uses the annotated cell type information stored in pData([your_expressionSet]) to generate inputs for running SJARACNe from the command line. The function partitions the input expression matrix and performs essential filtering (filter out not expressed genes in a cluster) to ensure a reliable network construction. funcType is required to specify the type of the network. If set funcType=\"TF\" , a reference transcription factor list will be loaded automatically without manual input. However, you do need to define species information for your data using under ref . This function creates one directory containing the required inputs (filtered expression matrix in .exp format and filtered TF list in .txt format) for each cell type. generateSJARACNeInput( input_eset = pbmc.14k.eset.log2, funcType = \"TF\", ref = \"hg\", #human wd.src = \"SJARACNe\", #Output directory group_tag = \"celltype\") generateSJARACNeInput( input_eset = pbmc.14k.eset.log2, funcType = \"SIG\", ref = \"hg\", #human wd.src = \"SJARACNe\", #Output directory group_tag = \"celltype\")","title":"Generate SJARACNe input"},{"location":"tutorials/PBMC-14k/#run-sjaracne-from-the-command-line","text":"SJARACNe works as a separate module which was implemented in python and C++, refer to SJARACNe github page for installation and basic usage. Please save your working directory before running SJARACNe. Here we provide an example to print SJARACNe commands for IBM LSF platform. indir = ./SJARACNe cd $indir for i in $(ls -d */ | cut -f1 -d'/'); do echo sjaracne lsf -j $indir/config_cwlexec.json -e $indir/${i}/*.exp -g $indir/${i}/tf/*.txt -n 100 -o $indir/${i}/tf -pc 0.01; done","title":"Run SJARACNe from the command line"},{"location":"tutorials/PBMC-14k/#identify-cell-type-specific-hidden-drivers-via-minie","text":"Identify hidden driver from content-based network is the key step in scMINER to help understand your scRNA-seq data, and provide biological insight.","title":"Identify cell-type-specific hidden drivers via MINIE"},{"location":"tutorials/PBMC-14k/#calculate-activity","text":"Activity calculation is the basis of driver estimation in scMINER. To infer driver activity, expression profile of their targets are integrated via function GetActivityFromSJARACNe() . This function takes SJARACNe output path and expression set as input, and return an activity set as well as structured network files if set save_network_files=TRUE . Please note that this function could only work if you used generateSJARACNeInput() to create SJARACNe input directory and files. Since scRNA-seq data is extremely sparse and noisy, please set activity.method as 'unweighted' . acs.14k.tf <- GetActivityFromSJARACNe( SJARACNe_output_path =\"SJARACNE/\", SJARACNe_input_eset = pbmc.14k.eset.log2, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"celltype\", # which group was used to partition expression profiles save_network_file=TRUE, # whether or not save network for each group functype=\"tf\",# whether or not save network for each group save_path=\"./networks_tf/\") #default as false, but recommended to be TRUE acs.14k.sig <- GetActivityFromSJARACNe( SJARACNe_output_path =\"SJARACNE/\", SJARACNe_input_eset = pbmc.14k.eset.log2, activity.method=\"unweighted\", # we highly recommend using 'unweighted' as activity calculation method activity.norm=TRUE, group_tag = \"celltype\", # which group was used to partition expression profiles save_network_file=TRUE, # whether or not save network for each group functype=\"tf\",# whether or not save network for each group save_path=\"./networks_sig/\") #default as false, but recommended to be TRUE","title":"Calculate activity"},{"location":"tutorials/PBMC-14k/#driver-estimation-by-differential-activity-analysis","text":"The function get.DA() was designed to perform differential activity analysis from SJARACNe inferred activity matrix. In this function, two-sided student's t-test will be performed to compare mean activity from one cell type V.S. the others. It will return a data frame that includes all TF occurred in original data. Statistics such as t.statistics, p-value, 95%CI, etc. are output to help identify hidden drivers. You can save it to file in order to check them manually. DAG_result_tf <- get.DA(input_eset = acs.14k.tf, group_tag = \"celltype\") DAG_result_sig <- get.DA(input_eset = acs.14k.sig, group_tag = \"celltype\") We also offer a function called get.Topdrivers() to help picking top drivers for each cell type. You can specify n as maximum number of top drivers to pick, and degree_filter to restrict number of targets. TF_list <- get.Topdrivers(DAG_result = DAG_result_tf, celltype = levels(acs.14k$genotype), # ensure cluster order n = 5, degree_filter = c(50, 600)) # check postive controls p <- feature_vlnplot(input_eset = acs.14k, feature = \"geneSymbol\", target=c(\"IL7R\", \"CD14\"), ylabel = \"Activity\", group_by = \"genotype\", ncol=2) To perform more advanced network analysis utilizing SJARACNe generated cell type specific networks, please refer to pages Network visualization and Driver target function analysis .","title":"Driver estimation by differential activity analysis"},{"location":"tutorials/activity-based-clustering/","text":"scMINER Guided Analysis on activity-based clustering Generate bulk network by using MetaCell To overcome the sparcity of scRNA-seq data and facilitate unbiased activity-based clustering, We start generating pseudo-bulk network. # Create a MetaCell object with raw count matrix of scRNA-seq (gene x cells) library(metacell) if(!dir.exists(\"testdb\")) dir.create(\"testdb/\") scdb_init(\"testdb/\", force_reinit=T) mcell_import_scmat_tsv(\"test\", fn=\"correctPBMC.csv\",dset_nm = \"pbmc20K\") mat = scdb_mat(\"test\") Create membership for each cell based on metacell ## Examine QC, remove unwanted genes and lowly expressed genes ## if(!dir.exists(\"figs1\")) dir.create(\"figs1/\") scfigs_init(\"figs1/\") mcell_plot_umis_per_cell(\"test\") mat = scdb_mat(\"test\") nms = c(rownames(mat@mat), rownames(mat@ignore_gmat)) ig_genes = c(grep(\"^IGJ\", nms, v=T), grep(\"^IGH\",nms,v=T), grep(\"^IGK\", nms, v=T), grep(\"^IGL\", nms, v=T)) bad_genes = unique(c(grep(\"^MT-\", nms, v=T), grep(\"^MT-MR\", nms, v=T), grep(\"^MT-ND\", nms, v=T),\"NEAT1\",\"TMSB4X\", \"TMSB10\", ig_genes)) mcell_mat_ignore_genes(new_mat_id=\"test\", mat_id=\"test\", bad_genes, reverse=F) mcell_mat_ignore_small_cells(\"test\", \"test\",200) mcell_add_gene_stat(gstat_id=\"test\", mat_id=\"test\", force=T) mcell_gset_filter_varmean(gset_id=\"test_feats\", gstat_id=\"test\", T_vm=0.08, force_new=T) mcell_gset_filter_cov(gset_id = \"test_feats\", gstat_id=\"test\", T_tot=100, T_top3=2) mcell_plot_gstats(gstat_id=\"test\", gset_id=\"test_feats\") ## Clustering into metacells ## mcell_coclust_from_graph_resamp( coc_id=\"test_coc500\", graph_id=\"test_graph\", min_mc_size=20, p_resamp=0.75, n_resamp=500) mcell_mc_from_coclust_balanced( coc_id=\"test_coc500\", mat_id= \"test\", mc_id= \"test_mc\", K=30, min_mc_size=30, alpha=2) mcell_mc_split_filt(new_mc_id=\"test_mc_f\", mc_id=\"test_mc\", mat_id=\"test\", T_lfc=10, plot_mats=F) The membership is stored in mc_f object. Generate eset object for network construction countmat<-read.csv(\"correctPBMC.csv\") esetNet <- CreateSparseEset(data=countmat,add.meta = T) norm = 1e6 exp.norm <- sweep(exprs(esetNet), 2, norm/unname(Matrix::colSums(exprs(esetNet))), '*') exp.log2 <- log(exp.norm+1,base=2) eset.log2 <- CreateSparseEset(data=exp.log2, meta.data = pData(esetNet), feature.data = fData(esetNet), add.meta = F) eset.log2<-eset.log2[,names(mc_f@mc)] eset.log2$group<-mc_f@mc Create Pseudobulk eset countmat<-read.csv(\"correctPBMC.csv\") esetNet <- CreateSparseEset(data=countmat,add.meta = T) norm = 1e6 exp.norm <- sweep(exprs(esetNet), 2, norm/unname(Matrix::colSums(exprs(esetNet))), '*') exp.log2 <- log(exp.norm+1,base=2) eset.log2 <- CreateSparseEset(data=exp.log2, meta.data = pData(esetNet), feature.data = fData(esetNet), add.meta = F) eset.log2<-eset.log2[,names(mc_f@mc)] eset.log2$group<-mc_f@mc CreatePseudobulkEset<-function(eset.log2, group){ cpmdf<-data.frame(t(exprs(eset.log2))) cpmdf$grp<-group cpmdf2<-aggregate(. ~ grp, data = cpmdf, FUN = mean) rownames(cpmdf2)<-cpmdf2$grp cpmdf2$grp<-NULL cpmdf2<-t(as.matrix(cpmdf2)) eset<-CreateSparseEset(data=cpmdf2,add.meta = F) return(eset) } esetPseudobulkNet<-CreatePseudobulkEset(eset.log2 = eset.log2,group = eset.log2$group) Generate Network esetPseudobulkNet$group<-\"metacell\" generateSJARACNeInput1( eset =esetPseudobulkNet, funcType = \"SIG\", ref = \"hg\", wd.src = \"SJAR/SJAR_SIG\", #Output directory group_tag = \"group\") generateSJARACNeInput1( eset = esetPseudobulkNet, funcType = \"TF\", ref = \"hg\", wd.src = \"SJAR/SJAR_TF\", #Output directory group_tag = \"group\")","title":"Activity based clustering"},{"location":"tutorials/activity-based-clustering/#scminer-guided-analysis-on-activity-based-clustering","text":"","title":"scMINER Guided Analysis on activity-based clustering"},{"location":"tutorials/activity-based-clustering/#generate-bulk-network-by-using-metacell","text":"To overcome the sparcity of scRNA-seq data and facilitate unbiased activity-based clustering, We start generating pseudo-bulk network. # Create a MetaCell object with raw count matrix of scRNA-seq (gene x cells) library(metacell) if(!dir.exists(\"testdb\")) dir.create(\"testdb/\") scdb_init(\"testdb/\", force_reinit=T) mcell_import_scmat_tsv(\"test\", fn=\"correctPBMC.csv\",dset_nm = \"pbmc20K\") mat = scdb_mat(\"test\")","title":"Generate bulk network by using MetaCell"},{"location":"tutorials/activity-based-clustering/#create-membership-for-each-cell-based-on-metacell","text":"## Examine QC, remove unwanted genes and lowly expressed genes ## if(!dir.exists(\"figs1\")) dir.create(\"figs1/\") scfigs_init(\"figs1/\") mcell_plot_umis_per_cell(\"test\") mat = scdb_mat(\"test\") nms = c(rownames(mat@mat), rownames(mat@ignore_gmat)) ig_genes = c(grep(\"^IGJ\", nms, v=T), grep(\"^IGH\",nms,v=T), grep(\"^IGK\", nms, v=T), grep(\"^IGL\", nms, v=T)) bad_genes = unique(c(grep(\"^MT-\", nms, v=T), grep(\"^MT-MR\", nms, v=T), grep(\"^MT-ND\", nms, v=T),\"NEAT1\",\"TMSB4X\", \"TMSB10\", ig_genes)) mcell_mat_ignore_genes(new_mat_id=\"test\", mat_id=\"test\", bad_genes, reverse=F) mcell_mat_ignore_small_cells(\"test\", \"test\",200) mcell_add_gene_stat(gstat_id=\"test\", mat_id=\"test\", force=T) mcell_gset_filter_varmean(gset_id=\"test_feats\", gstat_id=\"test\", T_vm=0.08, force_new=T) mcell_gset_filter_cov(gset_id = \"test_feats\", gstat_id=\"test\", T_tot=100, T_top3=2) mcell_plot_gstats(gstat_id=\"test\", gset_id=\"test_feats\") ## Clustering into metacells ## mcell_coclust_from_graph_resamp( coc_id=\"test_coc500\", graph_id=\"test_graph\", min_mc_size=20, p_resamp=0.75, n_resamp=500) mcell_mc_from_coclust_balanced( coc_id=\"test_coc500\", mat_id= \"test\", mc_id= \"test_mc\", K=30, min_mc_size=30, alpha=2) mcell_mc_split_filt(new_mc_id=\"test_mc_f\", mc_id=\"test_mc\", mat_id=\"test\", T_lfc=10, plot_mats=F) The membership is stored in mc_f object.","title":"Create membership for each cell based on metacell"},{"location":"tutorials/activity-based-clustering/#generate-eset-object-for-network-construction","text":"countmat<-read.csv(\"correctPBMC.csv\") esetNet <- CreateSparseEset(data=countmat,add.meta = T) norm = 1e6 exp.norm <- sweep(exprs(esetNet), 2, norm/unname(Matrix::colSums(exprs(esetNet))), '*') exp.log2 <- log(exp.norm+1,base=2) eset.log2 <- CreateSparseEset(data=exp.log2, meta.data = pData(esetNet), feature.data = fData(esetNet), add.meta = F) eset.log2<-eset.log2[,names(mc_f@mc)] eset.log2$group<-mc_f@mc","title":"Generate eset object for network construction"},{"location":"tutorials/activity-based-clustering/#create-pseudobulk-eset","text":"countmat<-read.csv(\"correctPBMC.csv\") esetNet <- CreateSparseEset(data=countmat,add.meta = T) norm = 1e6 exp.norm <- sweep(exprs(esetNet), 2, norm/unname(Matrix::colSums(exprs(esetNet))), '*') exp.log2 <- log(exp.norm+1,base=2) eset.log2 <- CreateSparseEset(data=exp.log2, meta.data = pData(esetNet), feature.data = fData(esetNet), add.meta = F) eset.log2<-eset.log2[,names(mc_f@mc)] eset.log2$group<-mc_f@mc CreatePseudobulkEset<-function(eset.log2, group){ cpmdf<-data.frame(t(exprs(eset.log2))) cpmdf$grp<-group cpmdf2<-aggregate(. ~ grp, data = cpmdf, FUN = mean) rownames(cpmdf2)<-cpmdf2$grp cpmdf2$grp<-NULL cpmdf2<-t(as.matrix(cpmdf2)) eset<-CreateSparseEset(data=cpmdf2,add.meta = F) return(eset) } esetPseudobulkNet<-CreatePseudobulkEset(eset.log2 = eset.log2,group = eset.log2$group)","title":"Create Pseudobulk eset"},{"location":"tutorials/activity-based-clustering/#generate-network","text":"esetPseudobulkNet$group<-\"metacell\" generateSJARACNeInput1( eset =esetPseudobulkNet, funcType = \"SIG\", ref = \"hg\", wd.src = \"SJAR/SJAR_SIG\", #Output directory group_tag = \"group\") generateSJARACNeInput1( eset = esetPseudobulkNet, funcType = \"TF\", ref = \"hg\", wd.src = \"SJAR/SJAR_TF\", #Output directory group_tag = \"group\")","title":"Generate Network"},{"location":"tutorials/data-reference/","text":"References [Zheng et al., 2017] Zheng, G. X. et al. Massively parallel digital transcriptional profiling of single cells. Nat Commun 8, 14049, doi:10.1038/ncomms14049 (2017). [Yao et al., Nat Immunol 2019] Yao, C., Sun, HW., Lacey, N.E. et al. Single-cell RNA-seq reveals TOX as a key regulator of CD8+ T cell persistence in chronic infection. Nat Immunol 20, 890\u2013901 (2019).","title":"References"},{"location":"tutorials/data-reference/#references","text":"","title":"References"},{"location":"tutorials/data-reference/#zheng-et-al-2017","text":"Zheng, G. X. et al. Massively parallel digital transcriptional profiling of single cells. Nat Commun 8, 14049, doi:10.1038/ncomms14049 (2017).","title":"[Zheng et al., 2017]"},{"location":"tutorials/data-reference/#yao-et-al-nat-immunol-2019","text":"Yao, C., Sun, HW., Lacey, N.E. et al. Single-cell RNA-seq reveals TOX as a key regulator of CD8+ T cell persistence in chronic infection. Nat Immunol 20, 890\u2013901 (2019).","title":"[Yao et al., Nat Immunol 2019]"},{"location":"tutorials/function-analysis/","text":"scMINER Guided Analysis on functional enrichment Visualization of functional enrichment of the regulons. Pathway enrichment Read in database # Read in database library(NetBID2) gs.preload(use_spe='Mus musculus',update=FALSE) print(all_gs2gene_info) Fisher exact test # Get the Regulons of Batf in each cell states driver_list <- rownames(Batftarget1) Batftarget12<-intersect(Batftarget1$target,Batftarget2$target) ## overlapped Batf targets in Tpex and Teff-like Tex res_up12 <- funcEnrich.Fisher(input_list=Batftarget12,use_gs=c('H',\"CP:KEGG\"), Pv_thre=0.05,Pv_adj = 'none',min_gs_size = 30, max_gs_size = 500) draw.funcEnrich.bar(funcEnrich_res= res_up12,top_number=30,main='Function Enrichment for Top drivers',pdf_file=sprintf('%s/funcEnrich_bar_Batf.pdf','target/'),display_genes = TRUE) Visualize pathway enrichment in multiple conditions # Get the regulons of Batf in each cell state res_up1 <- funcEnrich.Fisher(input_list=Batftarget1,use_gs=c('H',\"CP:KEGG\"), Pv_thre=0.05,Pv_adj = 'none',min_gs_size = 30, max_gs_size = 500) res_up2 <- funcEnrich.Fisher(input_list=Batftarget2,use_gs=c('H',\"CP:KEGG\"), Pv_thre=0.05,Pv_adj = 'none',min_gs_size = 30, max_gs_size = 500) res_up12$Cluster_ID<-'Overlap' res_up1$Cluster_ID<-'Tpex' res_up2$Cluster_ID<-'Teff-like' rest_all1<-rbind(res_up12,res_up1,res_up2) ggplot(rest_all1, aes(y = factor(reorder(`#Name`,Odds_Ratio)), x = Cluster_ID))+ geom_point(aes(colour = Odds_Ratio, size = -log10(Adj_P))) + scale_color_gradient2(low = \"blue\", mid = \"white\",high = \"red\") + labs(x=\"Odds_Ratio\",y=\"Pathways\")+ scale_size(range = c(1, 6)) + theme_bw() + theme(axis.text.x=element_text(angle=45,hjust=1))","title":"Driver target function analysis"},{"location":"tutorials/function-analysis/#scminer-guided-analysis-on-functional-enrichment","text":"Visualization of functional enrichment of the regulons.","title":"scMINER Guided Analysis on functional enrichment"},{"location":"tutorials/function-analysis/#pathway-enrichment","text":"","title":"Pathway enrichment"},{"location":"tutorials/function-analysis/#read-in-database","text":"# Read in database library(NetBID2) gs.preload(use_spe='Mus musculus',update=FALSE) print(all_gs2gene_info)","title":"Read in database"},{"location":"tutorials/function-analysis/#fisher-exact-test","text":"# Get the Regulons of Batf in each cell states driver_list <- rownames(Batftarget1) Batftarget12<-intersect(Batftarget1$target,Batftarget2$target) ## overlapped Batf targets in Tpex and Teff-like Tex res_up12 <- funcEnrich.Fisher(input_list=Batftarget12,use_gs=c('H',\"CP:KEGG\"), Pv_thre=0.05,Pv_adj = 'none',min_gs_size = 30, max_gs_size = 500) draw.funcEnrich.bar(funcEnrich_res= res_up12,top_number=30,main='Function Enrichment for Top drivers',pdf_file=sprintf('%s/funcEnrich_bar_Batf.pdf','target/'),display_genes = TRUE)","title":"Fisher exact test"},{"location":"tutorials/function-analysis/#visualize-pathway-enrichment-in-multiple-conditions","text":"# Get the regulons of Batf in each cell state res_up1 <- funcEnrich.Fisher(input_list=Batftarget1,use_gs=c('H',\"CP:KEGG\"), Pv_thre=0.05,Pv_adj = 'none',min_gs_size = 30, max_gs_size = 500) res_up2 <- funcEnrich.Fisher(input_list=Batftarget2,use_gs=c('H',\"CP:KEGG\"), Pv_thre=0.05,Pv_adj = 'none',min_gs_size = 30, max_gs_size = 500) res_up12$Cluster_ID<-'Overlap' res_up1$Cluster_ID<-'Tpex' res_up2$Cluster_ID<-'Teff-like' rest_all1<-rbind(res_up12,res_up1,res_up2) ggplot(rest_all1, aes(y = factor(reorder(`#Name`,Odds_Ratio)), x = Cluster_ID))+ geom_point(aes(colour = Odds_Ratio, size = -log10(Adj_P))) + scale_color_gradient2(low = \"blue\", mid = \"white\",high = \"red\") + labs(x=\"Odds_Ratio\",y=\"Pathways\")+ scale_size(range = c(1, 6)) + theme_bw() + theme(axis.text.x=element_text(angle=45,hjust=1))","title":"Visualize pathway enrichment in multiple conditions"},{"location":"tutorials/interoperability/","text":"Interoperability between SparseEset, Seurat, SingleCellExperiment, and anndata SC data type Conversion SparseEset Seurat SingleCellExperiment anndata SparseEset x SparseEset Seurat SparseEset SingleCellExperiment SparseEset SingleCellExperiment anndata2ri Seurat Seurat SparseEset x Seurat SingleCellExperiment https://mojaveazure.github.io/seurat-disk/articles/convert-anndata.html SingleCellExperiment SingleCellExperiment SparseEset SingleCellExperiment Seurat x anndata2ri anndata anndata2ri SingleCellExperiment SparseEset anndata2ri SingleCellExperiment Seurat anndata2ri SingleCellExperiment x Seurat https://cran.r-project.org/web/packages/Seurat/index.html SingleCellExperiment https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html anndata https://cran.r-project.org/web/packages/anndata/index.html anndata2ri https://github.com/theislab/anndata2ri And this is an alternative package that helps easy conversion of different single-cell data formats to each other. https://github.com/cellgeni/sceasy SparseEset to Seurat # eset.log2 is the SparseEset with log2 normalized matrix; # eset.sel is the SparseEset with raw count matrix scMINER2Seurat<-function(eset.log2,eset.sel){ library(Seurat) library(SingleCellExperiment) library(scMINER) dup_inx<-which(duplicated(fData(eset.log2)$geneSymbol)) if(length(dup_inx)>0){ eset.log2<-eset.log2[-dup_inx,] eset.sel<-eset.sel[-dup_inx,] counts = as.matrix(exprs(eset.sel)) rownames(counts)<-fData(eset.sel)$geneSymbol logcounts = as.matrix(exprs(eset.log2)) rownames(logcounts)<-fData(eset.log2)$geneSymbol sce<-SingleCellExperiment( assays = list(counts = counts,data = logcounts), colData = pData(eset.log2) ) SeuratObj <- as.Seurat(sce, counts = \"counts\", data = \"data\") return(SeuratObj) } SeuratObject<-scMINER2Seurat(eset.log2,eset.sel) Seurat to SparseEset # Create SparseEset with log2 normalized matrix library(scMINER) meta.data<-SeuratObject@meta.data feature.data<-data.frame(rownames(SeuratObject@assays$RNA@data)) colnames(feature.data)<-\"geneSymbol\" rownames(feature.data)<-feature.data$geneSymbol eset<-CreateSparseEset(data=SeuratObject@assays$RNA@data,meta.data = meta.data,feature.data = feature.data,add.meta = F)","title":"Interoperability between SparseEset, Seurat, and anndata"},{"location":"tutorials/interoperability/#interoperability-between-sparseeset-seurat-singlecellexperiment-and-anndata","text":"","title":"Interoperability between SparseEset, Seurat, SingleCellExperiment, and anndata"},{"location":"tutorials/interoperability/#sc-data-type-conversion","text":"SparseEset Seurat SingleCellExperiment anndata SparseEset x SparseEset Seurat SparseEset SingleCellExperiment SparseEset SingleCellExperiment anndata2ri Seurat Seurat SparseEset x Seurat SingleCellExperiment https://mojaveazure.github.io/seurat-disk/articles/convert-anndata.html SingleCellExperiment SingleCellExperiment SparseEset SingleCellExperiment Seurat x anndata2ri anndata anndata2ri SingleCellExperiment SparseEset anndata2ri SingleCellExperiment Seurat anndata2ri SingleCellExperiment x","title":"SC data type Conversion"},{"location":"tutorials/interoperability/#seurat","text":"https://cran.r-project.org/web/packages/Seurat/index.html","title":"Seurat"},{"location":"tutorials/interoperability/#singlecellexperiment","text":"https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html","title":"SingleCellExperiment"},{"location":"tutorials/interoperability/#anndata","text":"https://cran.r-project.org/web/packages/anndata/index.html","title":"anndata"},{"location":"tutorials/interoperability/#anndata2ri","text":"https://github.com/theislab/anndata2ri","title":"anndata2ri"},{"location":"tutorials/interoperability/#and-this-is-an-alternative-package-that-helps-easy-conversion-of-different-single-cell-data-formats-to-each-other","text":"https://github.com/cellgeni/sceasy","title":"And this is an alternative package that helps easy conversion of different single-cell data formats to each other."},{"location":"tutorials/interoperability/#sparseeset-to-seurat","text":"# eset.log2 is the SparseEset with log2 normalized matrix; # eset.sel is the SparseEset with raw count matrix scMINER2Seurat<-function(eset.log2,eset.sel){ library(Seurat) library(SingleCellExperiment) library(scMINER) dup_inx<-which(duplicated(fData(eset.log2)$geneSymbol)) if(length(dup_inx)>0){ eset.log2<-eset.log2[-dup_inx,] eset.sel<-eset.sel[-dup_inx,] counts = as.matrix(exprs(eset.sel)) rownames(counts)<-fData(eset.sel)$geneSymbol logcounts = as.matrix(exprs(eset.log2)) rownames(logcounts)<-fData(eset.log2)$geneSymbol sce<-SingleCellExperiment( assays = list(counts = counts,data = logcounts), colData = pData(eset.log2) ) SeuratObj <- as.Seurat(sce, counts = \"counts\", data = \"data\") return(SeuratObj) } SeuratObject<-scMINER2Seurat(eset.log2,eset.sel)","title":"SparseEset to Seurat"},{"location":"tutorials/interoperability/#seurat-to-sparseeset","text":"# Create SparseEset with log2 normalized matrix library(scMINER) meta.data<-SeuratObject@meta.data feature.data<-data.frame(rownames(SeuratObject@assays$RNA@data)) colnames(feature.data)<-\"geneSymbol\" rownames(feature.data)<-feature.data$geneSymbol eset<-CreateSparseEset(data=SeuratObject@assays$RNA@data,meta.data = meta.data,feature.data = feature.data,add.meta = F)","title":"Seurat to SparseEset"},{"location":"tutorials/network-visualize/","text":"scMINER Guided Analysis on network visualization Visualization of regulon rewiring between different cell states. Read in network We start by reading SJARACNE output with function get.SJAracne.network() . # Create a SparseExpressionSet object with meta info net2 <- NetBID2::get.SJAracne.network('TEXeff_13218_13218_3394/tf/TEXeff_13218_13218_3394SJARACNE_TF/SJARACNE_out.final/consensus_network_ncol_.txt') Then a plot with regulon of a specific TF can be created by using draw.targetNet() function. ### Calculate edge score for each target use_driver='Batf' celltype=\"t_TEXeff\" edge_score <-net2$target_list[[use_driver]]$MI*sign(net1$target_list[[use_driver]]$spearman) ### DAG_result_tf is the TF DA master table ########## NetBID2::draw.targetNet(source_label=use_driver,source_z=DAG_result_tf[DAG_result_tf$geneSymbol==use_driver,celltype], edge_score = edge_score,pdf_file=sprintf('./targetNet_out_%s.pdf',use_driver),label_cex = 1,n_layer=2,source_cex = 1, alphabetical_order=TRUE) The rewiring of a specific TF can be output to CytoScape. ## combine all the target into a master table for CytoScape input Batf_target1<-net1$target_list[[use_driver]] Batf_target2<-net2$target_list[[use_driver]] Batf_target3<-net3$target_list[[use_driver]] Batf_target_all<-rbind(Batf_target,Batf_target2,Batf_target3) write.table(Batf_target_all,file = \"Batf_network_rewiring.txt\",row.names = F,sep = \"\\t\",quote = F)","title":"Network visualization"},{"location":"tutorials/network-visualize/#scminer-guided-analysis-on-network-visualization","text":"Visualization of regulon rewiring between different cell states.","title":"scMINER Guided Analysis on network visualization"},{"location":"tutorials/network-visualize/#read-in-network","text":"We start by reading SJARACNE output with function get.SJAracne.network() . # Create a SparseExpressionSet object with meta info net2 <- NetBID2::get.SJAracne.network('TEXeff_13218_13218_3394/tf/TEXeff_13218_13218_3394SJARACNE_TF/SJARACNE_out.final/consensus_network_ncol_.txt') Then a plot with regulon of a specific TF can be created by using draw.targetNet() function. ### Calculate edge score for each target use_driver='Batf' celltype=\"t_TEXeff\" edge_score <-net2$target_list[[use_driver]]$MI*sign(net1$target_list[[use_driver]]$spearman) ### DAG_result_tf is the TF DA master table ########## NetBID2::draw.targetNet(source_label=use_driver,source_z=DAG_result_tf[DAG_result_tf$geneSymbol==use_driver,celltype], edge_score = edge_score,pdf_file=sprintf('./targetNet_out_%s.pdf',use_driver),label_cex = 1,n_layer=2,source_cex = 1, alphabetical_order=TRUE)","title":"Read in network"},{"location":"tutorials/network-visualize/#the-rewiring-of-a-specific-tf-can-be-output-to-cytoscape","text":"## combine all the target into a master table for CytoScape input Batf_target1<-net1$target_list[[use_driver]] Batf_target2<-net2$target_list[[use_driver]] Batf_target3<-net3$target_list[[use_driver]] Batf_target_all<-rbind(Batf_target,Batf_target2,Batf_target3) write.table(Batf_target_all,file = \"Batf_network_rewiring.txt\",row.names = F,sep = \"\\t\",quote = F)","title":"The rewiring of a specific TF can be output to CytoScape."}]}