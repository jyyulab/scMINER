
#' Extract the pre-defined driver lists of human or mouse
#'
#' @description
#' This function is used to extract the pre-defined driver lists of human or mouse.
#'
#' @param species_type Character, species of the driver lists to be extracted: "`hg`" for human, "`mm`" for mouse. Default: "`hg`".
#' @param driver_type Character, type of drivers to be extracted: "`TF`" for transcriptional factor, "`SIG`" for signaling genes, and "`TF_SIG`" for both. Default: "`TF`".
#'
#' @return A vector of pre-defined driver genes
#' @importFrom dplyr filter
#' @export
#'
#' @examples
#' ## 1. Get the TF driver list of human
#' hg_tf <- getDriverList(species_type = "hg", driver_type = "TF")
#'
#' ## 2. Get the total driver list, including both TF and SIG, of mouse
#' mm_driver <- getDriverList(species_type = "mm", driver_type = "TF_SIG")
getDriverList <- function(species_type = "hg",
                          driver_type = "TF")
{
  if (species_type %in% c("hg", "mm")) {
    ref_file <- system.file("RData", paste0("tf_sigs_", species_type, ".RData"), package = "scMINER")
    load(ref_file)

    driverList = NULL
    if (driver_type == "TF") {
      driverList <- unique(dplyr::filter(tf_sigs, isTF == TRUE)$geneSymbol)
    } else if (driver_type == "SIG") {
      driverList <- unique(dplyr::filter(tf_sigs, isSIG == TRUE)$geneSymbol)
    } else if (driver_type == "TF_SIG") {
      driverList <- unique(dplyr::filter(tf_sigs, isTF == TRUE | isSIG == TRUE)$geneSymbol)
    } else {
      stop('The driver_type can not be recognized. Should be [TF | SIG].')
    }
  } else {
    stop('The species_type can not be recognized. Should be [hg | mm].')
  }
  return(driverList)
}


#' Generate the standard input files for SJARACNe from sparse eset object
#'
#' @description
#' This function is used to generate the standard input files for SJARACNe, a scalable software tool for gene network reverse engineering from big data.
#'
#' @param input_eset The expression set object that filtered, normalized and log-transformed
#' @param group_name Character, name of the column for grouping, usually the column of cell types or clusters. Default: "`clusterID`".
#' @param group_name.refine Logical, whether to replace the non-word characters in group names with underscore symbol ("_"). The improper
#' filename characters may cause troubles, since scMINER creates a folder for each group using the group names. Set this argument to `TRUE` can help avoid this issue. Default: `FALSE`.
#' @param sjaracne_dir The path to the folder for SJARACNe runs. Both the inputs and outputs will be saved here.
#' @param species_type Character, species of the pre-defined driver list to use: "`hg`" for human or "`mm`" for mouse. Default: `hg`.
#' @param driver_type Character, type of the pre-defined driver list to use: "`TF`" for transcriptional factors only, "`SIG`" for signaling genes only, or "`TF_SIG`" for both. Default: "`TF_SIG`".
#' @param customDriver_TF A character vector or `NULL`, genes used to replace the pre-defined transcriptional factor driver list. This allows the user to customize the TF driver list. Default: `NULL`.
#' @param customDriver_SIG A character vector or `NULL`, genes used to replace the pre-defined signaling gene driver list. This allows the user to customize the SIG driver list. Default: `NULL`.
#' @param downSample_N Integer or `NULL`, if an integer is given, the groups with more cells than this integer will be down-sampled to this integer. A number between 500 to 3000 gives a good balance
#' between robustness and computational efficiency. If `NULL`, the downsampling would be skipped. Default: 1000.
#' @param seed Non-negative integer, seed of random sampling. Default: 123.
#' @param superCell_N Integer or `NULL`, if an integer is given, the metacell method would be performed by SuperCell package to the groups with more cells than this integer. If NULL, no metacell method would be done. Default: `NULL`.
#' @param superCell_count Integer, number of metacells to generate by SuperCell. Default: 100. Ignored if `superCell_N` = `NULL`.
#' @param superCell_gamma Integer, graining level of data by SuperCell (proportion of number of single cells in the initial dataset to the number of metacells in the final dataset). Default: 10. Ignored if `superCell_N` = `NULL`.
#' @param superCell_knn Integer, the k value to compute single-cell kNN network by SuperCell. Default: 5. Ignored if `superCell_N` = `NULL`.
#' @param superCell_nHVG Integer, number of genes with the largest variation to use by SuperCell. Default: 1000. Ignored if `superCell_N` = `NULL`.
#' @param superCell_nPC Integer, number of principal components to use for construction of single-cell kNN network by SuperCell.Default: 10. Ignored if `superCell_N` = `NULL`.
#' @param superCell_save Logical, whether to save the results generated by SuperCell, including membership and other components. Default: TRUE. Ignored if `superCell_N` = `NULL`.
#' @param print_command Logical, whether to print the command to run SJARACNe to screen. Default: `FALSE`.
#' @param save_command Logical, whether to save the command to run SJARACNe. Default: `TRUE`.
#'
#' @return This function will generate several folders and files in the directory specified by "`sjaracne_dir`":
#'  1. a folder for each group in the column specified by "`group_name`";
#'  2. In each folder:
#'      - a "**`.exp.txt`**" file: expression matrix, features by cells.
#'      - a "**`TF`**" folder containing a "**`.tf.txt`**" file: this file contains the TF driver list.
#'      - a "**`SIG`**" folder containing a "**`.sig.txt`**" file: this file contains the SIG driver list.
#'      - a bash script (**`runSJARACNe.sh`**) to run SJARACNe. Further modification is needed to run it.
#'      - a json file (**`config_cwlexec.json`**) containing parameters to run SJARACNe.
#' @importFrom dplyr filter
#' @export
#'
#' @examples
#' \dontrun{
#' data(pbmc14k_expression.eset)
#' ## 1. The most commonly used command: pre-defined driver lists, automatic down-sampling, no metacell method
#' generateSJARACNeInput(input_eset = pbmc14k_expression.eset,
#'                       group_name = "cell_type",
#'                       sjaracne_dir = "./SJARACNe",
#'                       species_type = "hg",
#'                       driver_type = "TF_SIG")
#'
#' ## 2. to disable the downsampling
#' generateSJARACNeInput(input_eset = pbmc14k_expression.eset,
#'                       group_name = "cell_type",
#'                       sjaracne_dir = "./SJARACNe",
#'                       species_type = "hg",
#'                       driver_type = "TF_SIG",
#'                       downSample_N = NULL)
#'
#' ## 3. Use the customized driver list: (add TUBB4A is the gene of interest but currently not in the pre-defined driver list)
#'
#' # when the driver-to-add is known as a transcription factor
#' generateSJARACNeInput(input_eset = pbmc14k_expression.eset, group_name = "trueLabel", sjaracne_dir = "./SJARACNe", species_type = "hg", driver_type = "TF_SIG",
#'                       customDriver_TF = c(getDriverList(species_type = "hg", driver_type = "TF"), "TUBB4A"))
#'
#' # when the driver-to-add is known as a non-transcription factor
#' generateSJARACNeInput(input_eset = pbmc14k_expression.eset, group_name = "trueLabel", sjaracne_dir = "./SJARACNe", species_type = "hg", driver_type = "TF_SIG",
#'                       customDriver_SIG = c(getDriverList(species_type = "hg", driver_type = "SIG"), "TUBB4A"))
#'
#' # when it's ambiguous to tell if the driver-to-add is a transcriptional factor
#' generateSJARACNeInput(input_eset = pbmc14k_expression.eset, group_name = "trueLabel", sjaracne_dir = "./SJARACNe", species_type = "hg", driver_type = "TF_SIG",
#'                       customDriver_TF = c(getDriverList(species_type = "hg", driver_type = "TF"), "TUBB4A"),
#'                       customDriver_SIG = c(getDriverList(species_type = "hg", driver_type = "SIG"), "TUBB4A"))
#'
#' ## 4. Use the metacell method
#' generateSJARACNeInput(input_eset = pbmc14k_expression.eset, group_name = "trueLabel", sjaracne_dir = "./SJARACNe", species_type = "hg", driver_type = "TF_SIG",
#'                       superCell_N = 1000, superCell_count = 100, seed = 123)
#' }
#'
generateSJARACNeInput <- function(input_eset,
                                  group_name = "clusterID",
                                  group_name.refine = FALSE,
                                  sjaracne_dir,
                                  species_type = "hg", driver_type = "TF_SIG", customDriver_TF = NULL, customDriver_SIG = NULL,
                                  downSample_N = 1000, seed = 123,
                                  superCell_N = NULL, superCell_count = 100, superCell_gamma = 10, superCell_knn = 5, superCell_nHVG = 1000, superCell_nPC = 10, superCell_save = TRUE,
                                  print_command = FALSE, save_command = TRUE)
{
  ## output dir
  if (!dir.exists(sjaracne_dir)) {dir.create(sjaracne_dir, recursive = TRUE)}

  ## group info
  if (!group_name %in% colnames(Biobase::pData(input_eset))) {
    stop('The group_name can not be found in the input_eset.')
  } else {
    element_before <- unique(Biobase::pData(input_eset)[, group_name])
    if (any(unlist(lapply(element_before, function(x) {grepl("\\W", x)})))) {
      cat("Non-word characters (any character other than [a-zA-Z0-9_] ) were found in the group_name elements. scMINER doesn't accept them in group names.\n")
      if (group_name.refine) {
        cat("scMINER will refine the group_name by replacing the non-word characters with underscore symbol.\n")
        element_after <- unlist(lapply(element_before, function(x) {gsub("\\W", "_", x)}))
        if (any(duplicated(element_after))) {
          element_after.dupl <- element_after[duplicated(element_after)]
          element_before.dupl <- element_before[which(element_after %in% element_after.dupl)]
          stop('These group names, ', paste0(element_before.dupl, collapse = ", "), ', will duplcate after the automatic refining.\nPlease manually remove the non-word characters and re-try.')
        } else {
          Biobase::pData(input_eset)[, group_name] <- unlist(lapply(Biobase::pData(input_eset)[, group_name], function(x) {gsub("\\W", "_", x)}))
          cat("scMINER has successfully refined the group_name!\n")
        }
      } else {
        stop('Please set group_name.refine = TRUE to fix it automatically by scMINER, or manually fix it and re-try.')
      }
    } else {
      cat("No non-word characters (any character other than [a-zA-Z0-9_] ) were found in the group_name elements. group_name check passed...\n")
    }
  }

  ## TF and SIG list
  if (length(driver_type) == 1) {
    if (!driver_type %in% c("TF_SIG", "TF", "SIG")) {
      stop('The driver_type can not be recognized. Should be [TF_SIG | TF | SIG].')
    }
  } else {
    stop('The length of driver_type much be 1. Please check and re-try.')
  }

  if (driver_type %in% c("TF_SIG", "TF")) {
    driverlist_tf <- NULL
    if (is.null(customDriver_TF) == FALSE & length(customDriver_TF) >= 1) {
      cat("Extracting TF drivers from the customized list...\n")
      driverlist_tf <- customDriver_TF
    } else {
      if (species_type %in% c("hg", "mm")) {
        ref_file <- system.file("RData", paste0("tf_sigs_", species_type, ".RData"), package = "scMINER")
        load(ref_file)
        cat("Extracting TF drivers from the reference list...\n")
        driverlist_tf <- unique(dplyr::filter(tf_sigs, isTF==TRUE)$geneSymbol)
        cat("A TF driver list of", paste0(length(driverlist_tf), " genes was generated!\n"))
      } else {
        stop('The species_type can not be recognized. Should be [hg | mm].')
      }
    }
  }

  if (driver_type %in% c("TF_SIG", "SIG")) {
    driverlist_sig <- NULL
    if (is.null(customDriver_SIG) == FALSE & length(customDriver_SIG) >= 1) {
      cat("Extracting SIG drivers from the customized list...\n")
      driverlist_sig <- customDriver_SIG
    } else {
      if (species_type %in% c("hg", "mm")) {
        ref_file <- system.file("RData", paste0("tf_sigs_", species_type, ".RData"), package = "scMINER")
        load(ref_file)
        cat("Extracting SIG drivers from the reference list...\n")
        driverlist_sig <- unique(dplyr::filter(tf_sigs, isSIG==TRUE)$geneSymbol)
        cat("A SIG driver list of", paste0(length(driverlist_sig), " genes was generated!\n"))
      } else {
        stop('The species_type can not be recognized. Should be [hg | mm].')
      }
    }
  }

  ## expression matrix
  grps <- unique(Biobase::pData(input_eset)[,group_name])
  cat(paste0(length(grps), " groups were found from the input eset.\n"))

  for (i in 1:length(grps)) {
    grp_tag <- grps[i]
    cat(paste0(i, "/", length(grps), ": Generating SJARACNe inputs for group: ", grp_tag, "\n"))
    grp_dir <- paste0(sjaracne_dir, "/", grp_tag)
    cat(paste0("\tCreating the output dirctory...\n"))
    if(!dir.exists(grp_dir)) {dir.create(grp_dir, recursive = T)}

    if (driver_type %in% c("TF_SIG", "TF")) {
      grp_dir.tf <- paste0(grp_dir, "/TF")
      if(!dir.exists(grp_dir.tf)) {dir.create(grp_dir.tf, recursive = T)}
    }

    if (driver_type %in% c("TF_SIG", "SIG")) {
      grp_dir.sig <- paste0(grp_dir, "/SIG")
      if(!dir.exists(grp_dir.sig)) {dir.create(grp_dir.sig, recursive = T)}
    }

    eset.sel <- input_eset[, which(Biobase::pData(input_eset)[, group_name] == grp_tag)]
    sample_size <- ncol(Biobase::exprs(eset.sel))
    cat(paste0("\t", sample_size, " cells were found in this group...\n"))

    set.seed(seed = seed)
    do.supercell = FALSE; do.downsample = FALSE
    ## metacell detection by SuperCell
    if (is.null(superCell_N) == FALSE) {
      if (sample_size > superCell_N) {
        avail_SuperCell <- require(package = "SuperCell", quietly = TRUE)
        if (avail_SuperCell == FALSE) {stop('The package, SuperCell, is required but not installed. Please install it and re-try!\nTo install SuperCell, please see https://github.com/GfellerLab/SuperCell/tree/master')}

        if (sample_size < 1000) {warning('\tThe SuperCell analysis is only recommended for the datasets with >=1000 cells. Only ', sample_size, " cells are founded in this group.")}

        if (is.null(superCell_count) == FALSE) {
          superCell_gamma <- floor(sample_size / superCell_count)
        }

        sc <- SuperCell::SCimplify(exprs(eset.sel), gamma = superCell_gamma, k.knn = superCell_knn, n.var.genes = min(superCell_nHVG, nrow(eset.sel)), n.pc = superCell_nPC, seed = seed)
        if (superCell_save == TRUE) {saveRDS(sc, paste0(grp_dir, "/metacells_bySuperCell.rds"))}
        gex.supercell <- SuperCell::supercell_GE(exprs(eset.sel), sc$membership, mode = "average")
        colnames(gex.supercell) <- paste0("supercell_", 1:ncol(gex.supercell))

        if (is.null(superCell_count) == FALSE) {
          if (ncol(gex.supercell) > superCell_count) {
            ds_supercell <- sample(1:ncol(gex.supercell), size = superCell_count, replace = FALSE)
            gex.supercell <- gex.supercell[, ds_supercell]
          }
        }
        cat(paste0("\t", ncol(gex.supercell), " meta cells were generated by SuperCell...\n"))
        do.supercell = TRUE
      } else {
        gex.supercell <- exprs(eset.sel)
        cat(paste0('\tThe metacell analysis was skipped, since the cell number (', sample_size, ') is smaller than the cutoff (', superCell_N, ').\n'))
      }
    } else {
      gex.supercell <- Biobase::exprs(eset.sel)
      cat(paste0('\tThe metacell analysis by was skipped, since the superCell_N is null.\n'))
    }

    ## downsampling
    if (is.null(downSample_N) == FALSE) {
      if (ncol(gex.supercell) > downSample_N) {
        ds_singlecell <- sample(1:ncol(gex.supercell), size = downSample_N, replace = FALSE)
        gex.final <- gex.supercell[,ds_singlecell]
        do.downsample = TRUE
        cat(paste0("\t", length(ds_singlecell), " cells left after down-sampling...\n"))
      } else {
        gex.final <- gex.supercell
        cat(paste0('\tThe downsampling was skipped, since the cell number (', ncol(gex.supercell), ') is smaller than the cutoff (', downSample_N, ').\n'))
      }
    } else {
      gex.final <- gex.supercell
      cat(paste0('\tThe downsampling was skipped, since the downSample_N is null.\n'))
    }

    if (do.supercell) {
      if (ncol(gex.final) < 50) {warning('\tSJARACNe requires >=50 metacells to generate high-quality network. Only ', ncol(gex.final), " meta cells are founded in this group.")}
    } else {
      if (ncol(gex.final) < 100) {warning('\tSJARACNe requires >=100 single cells to generate high-quality network. Only ', ncol(gex.final), " single cells are founded in this group.")}
    }

    ## writing output
    gex.final <- gex.final[rowSums(as.matrix(gex.final), na.rm = T) > 0,] # remove rows of 0'
    nGene.final <- nrow(gex.final)
    nCell.final <- ncol(gex.final)

    gex.df <- data.frame(cbind(isoformId = rownames(gex.final), geneSymbol = rownames(gex.final), as.matrix(gex.final)), stringsAsFactors = FALSE)
    gex.file <- paste0(grp_dir, "/", grp_tag, ".", nGene.final, "_", nCell.final, ".exp.txt")
    cat(paste0("\tWriting gene expression matrix into ", gex.file, "...\n"))
    write.table(gex.df, file = gex.file, sep = "\t", row.names = FALSE, quote = FALSE, col.names = TRUE)

    if (driver_type %in% c("TF_SIG", "TF")) {
      tf.final <- driverlist_tf[driverlist_tf %in% rownames(gex.final)]
      tf.df <- data.frame(tf_drivers = tf.final)
      tf.file <- paste0(grp_dir.tf, "/", grp_tag, ".", length(tf.final), "_", nCell.final, ".tf.txt")
      cat(paste0("\tWriting TF driver list into ", tf.file, "...\n"))
      write.table(tf.df, file = tf.file, sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
    }

    if (driver_type %in% c("TF_SIG", "SIG")) {
      sig.final <- driverlist_sig[driverlist_sig %in% rownames(gex.final)]
      sig.df <- data.frame(sig_drivers = sig.final)
      sig.file <- paste0(grp_dir.sig, "/", grp_tag, ".", length(sig.final), "_", nCell.final, ".sig.txt")
      cat(paste0("\tWriting SIG driver list into ", sig.file, "...\n"))
      write.table(sig.df, file = sig.file, sep = "\t", row.names = FALSE, quote = FALSE, col.names = FALSE)
    }

    ## print command line
    # copy configure file
    if (file.exists(system.file("config_template", "config_cwlexec.json", package = "scMINER")) == TRUE) {
      file.copy(from = system.file("config_template", "config_cwlexec.json", package = "scMINER"), to = paste0(grp_dir, "/config_cwlexec.json"))
    } else {
      stop("The configure file was not found:", system.file("config_template", "config_cwlexec.json", package = "scMINER"), ".")
    }

    # command line
    if (do.supercell) {
      if (driver_type %in% c("TF_SIG", "TF")) {
        sjaracne_cmd.lsf_tf <- sprintf('sjaracne lsf -e %s -g %s -o %s -n 100 -pc 1e-3 -j %s/config_cwlexec.json -tmp %s/tmp', gex.file, tf.file, grp_dir.tf, grp_dir, grp_dir.tf)
        sjaracne_cmd.local_tf <- sprintf('sjaracne local -e %s -g %s -o %s -n 100 -pc 1e-3 -tmp %s/tmp', gex.file, tf.file, grp_dir.tf, grp_dir.tf)
      }

      if (driver_type %in% c("TF_SIG", "SIG")) {
        sjaracne_cmd.lsf_sig <- sprintf('sjaracne lsf -e %s -g %s -o %s -n 100 -pc 1e-3 -j %s/config_cwlexec.json -tmp %s/tmp', gex.file, sig.file, grp_dir.sig, grp_dir, grp_dir.sig)
        sjaracne_cmd.local_sig <- sprintf('sjaracne local -e %s -g %s -o %s -n 100 -pc 1e-3 -tmp %s/tmp', gex.file, sig.file, grp_dir.sig, grp_dir.sig)
      }
    } else {
      if (driver_type %in% c("TF_SIG", "TF")) {
        sjaracne_cmd.lsf_tf <- sprintf('sjaracne lsf -e %s -g %s -o %s -n 100 -pc 1e-2 -j %s/config_cwlexec.json -tmp %s/tmp', gex.file, tf.file, grp_dir.tf, grp_dir, grp_dir.tf)
        sjaracne_cmd.local_tf <- sprintf('sjaracne local -e %s -g %s -o %s -n 100 -pc 1e-2 -tmp %s/tmp', gex.file, tf.file, grp_dir.tf, grp_dir.tf)
      }

      if (driver_type %in% c("TF_SIG", "SIG")) {
        sjaracne_cmd.lsf_sig <- sprintf('sjaracne lsf -e %s -g %s -o %s -n 100 -pc 1e-2 -j %s/config_cwlexec.json -tmp %s/tmp', gex.file, sig.file, grp_dir.sig, grp_dir, grp_dir.sig)
        sjaracne_cmd.local_sig <- sprintf('sjaracne local -e %s -g %s -o %s -n 100 -pc 1e-2 -tmp %s/tmp', gex.file, sig.file, grp_dir.sig, grp_dir.sig)
      }
    }
    # command line parameters
    cmd_paras <- sprintf('-e: input expression file;
                          -g: input candidate driver file;
                          -o: output directory;
                          -n: the number of bootstraps;
                          -pc: the consensus p-value threshold;
                          -j: json config file.')

    if (save_command) {
      cmd_file <- paste0(grp_dir, "/runSJARACNe.sh")
      cmd_file.conn <- file(cmd_file)
      if (driver_type == "TF_SIG") {
        writeLines(c(sjaracne_cmd.lsf_tf, sjaracne_cmd.lsf_sig, sjaracne_cmd.local_tf, sjaracne_cmd.local_sig), cmd_file.conn)
      } else if (driver_type == "TF") {
        writeLines(c(sjaracne_cmd.lsf_tf, sjaracne_cmd.local_tf), cmd_file.conn)
      } else if (driver_type == "SIG") {
        writeLines(c(sjaracne_cmd.lsf_sig, sjaracne_cmd.local_sig), cmd_file.conn)
      }
      close(cmd_file.conn)
      cat(paste0('\tWriting command lines to run SJARACNe to ', cmd_file, "...\n"))
    }

    if (print_command) {
      if (driver_type == "TF_SIG") {
        cat(sprintf("Suggested command line for lsf is:\n\n\t%s\n\t%s\nSuggested command line for local is:\n\n\t%s\n\t%s\n\nWhere options represent:%s", sjaracne_cmd.lsf_tf, sjaracne_cmd.lsf_sig, sjaracne_cmd.local_tf, sjaracne_cmd.local_sig, cmd_paras))
      } else if (driver_type == "TF") {
        cat(sprintf("Suggested command line for lsf is:\n\n\t%s\nSuggested command line for local is:\n\n\t%s\n\nWhere options represent:%s", sjaracne_cmd.lsf_tf, sjaracne_cmd.local_tf, cmd_paras))
      } else if (driver_type == "SIG") {
        cat(sprintf("Suggested command line for lsf is:\n\n\t%s\nSuggested command line for local is:\n\n\t%s\n\nWhere options represent:%s", sjaracne_cmd.lsf_sig, sjaracne_cmd.local_sig, cmd_paras))
      }
    }
    cat("\tDone.\n")
  }
  return(input_eset)
}


#' Assess the quality of each network generated by SJARACNe
#'
#' @description
#' This function is used to assess the quality of networks generated by SJARACNe. It returns a summary table of key statistics of networks. The users can also generate the html quality control report by turning `generate_html` = `TRUE`.
#'
#' @param network_file The path to the network file (**`consensus_network_ncol_.txt`**) for quality control
#' @param sjaracne_dir The path to the folder of SJARACNe runs. When this argument is given, scMINER will automatically retrieve all network files (**`consensus_network_ncol_.txt`**) in this folder and generate quality control report for all of them.
#' @param directed Logical, whether the network is directed or not. All networks generated by SJARACNe are directed. Default: `TRUE`.
#' @param weighted Logical, whether the edges of the network is weighted or not. All networks generated by SJARACNe are weighted by mutual information ("`MI`" column). Default: `TRUE`.
#' @param generate_html Logical, whether to generate a html report. Default: `TRUE`.
#' @param outdir Character or `NULL`, the path to save the html report. If `NULL`, the html report will be saved in the same folder of the network file. Default: NULL. Ignored if `generate_html` = `FALSE`.
#' @param prefix Character or `NULL`, the character string to add in front of the html report file name. Default: `NULL`. Ignored if `generate_html` = `FALSE`.
#'
#' @return This function will print the statistics of several key quality metrics of network(s). If `generate_html` is set `TRUE`, it also generates a html file of quality control report and save it to the same folder of the network file (by default) or the folder specified by "`outdir`".
#' @import igraph
#' @import rmarkdown
#' @export
#'
#' @examples
#' \dontrun{
#' ## 1. Assess the quality of network from network files
#' drawNetworkQC(network_file = "/project_space/SJARACNE/B/SIG/b100/consensus_network_ncol_.txt", generate_html = TRUE,
#'               outdir = "/folder-to-save-report_file", prefix = "PBMC14")
#'
#' ## 2. Assess the quality of network from the directory of network files
#' drawNetworkQC(sjaracne_dir = "/project_space/SJARACNE", generate_html = TRUE)
#' }
#'
drawNetworkQC <- function(network_file = NULL,
                          sjaracne_dir = NULL,
                          directed = TRUE, weighted = TRUE,
                          generate_html = TRUE, outdir = NULL, prefix = NULL)
{
  ## check inputs: sjaracne_dir or network_file
  from_directory <- FALSE; from_file <- FALSE
  if (is.null(network_file)) {
    if (is.null(sjaracne_dir)) {
      stop('No input information found. Please specify either network_file or sjaracne_dir, and re-try.')
    } else {
      if (dir.exists(sjaracne_dir)) {
        cat('The network QC will be performed for this directory:', sjaracne_dir, '.\n')
        from_directory <- TRUE
      } else {
        stop('The sjaracne_dir specified was not found.')
      }
    }
  } else {
    if (is.null(sjaracne_dir)) {
      if (file.exists(network_file)) {
        cat('The network QC will be performed for this file:', network_file, '.')
        from_file <- TRUE
      } else {
        stop('The network_file specified was not found.')
      }
    } else {
      stop('Please specifiy ONLY ONE of these two inputs: network_file, sjaracne_dir.')
    }
  }

  ## generate QC reports from dir
  if (from_directory) {
    ## check network files
    network_file.path <- list.files(path = sjaracne_dir, pattern = "consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
    if (length(network_file.path) > 0) {
      network_file.tag <- gsub(paste0(sjaracne_dir,"\\/"), "", network_file.path)
      network_file.tag <- gsub("\\/sjaracne_workflow.+consensus_network_ncol_\\.txt$", "", network_file.tag)
      if (any(duplicated(network_file.tag))) {
        network_file.tag.duplicated <- network_file.tag[duplicated(network_file.tag)]
        stop('Duplicated network files were found for: ', paste0(network_file.tag.duplicated, collapse = ", "), '.\nPlease remove the duplicates and re-try.')
      } else {
        cat(length(network_file.tag), 'network files were found in the directory:', sjaracne_dir, '.\n')
      }
    } else {
      stop('No network file (consensus_network_ncol_.txt) was found in this directory: ', sjaracne_dir, '.')
    }

    #stats_table <- c("network_tag", "network_node", "network_edge", "driver_count", "targetSize_mean", "targetSize_median", "targetSize_minimum", "targetSize_maximum", "network_path")
    stats_table <- data.frame(network_tag=NA, network_node=NA, network_edge=NA, driver_count=NA, targetSize_mean=NA, targetSize_median=NA, targetSize_minimum=NA, targetSize_maximum=NA, network_path=NA)
    for (i in 1:length(network_file.path)) {
      file.path <- network_file.path[i]
      cat('\tProcessing file', i, '/', length(network_file.tag), ':', file.path, '...\n')
      file.tag <- gsub(paste0(sjaracne_dir,"\\/"), "", file.path)
      file.tag <- gsub("\\/sjaracne_workflow.+consensus_network_ncol_\\.txt$", "", file.tag)
      file.tag <- gsub("\\/", "\\.", file.tag)

      ## generate igraph obj from network file
      df_network <- read.delim(file = file.path, stringsAsFactors = FALSE)
      igraph_obj <- igraph::graph_from_data_frame(df_network, directed = directed)
      if (directed == TRUE) {
        if ('spearman' %in% colnames(df_network)) {
          igraph_obj <- igraph::set_edge_attr(igraph_obj, 'sign', index = igraph::E(igraph_obj), value = sign(df_network[, 'MI']))
        } else {
          stop('The sign of Spearman correlation coefficient [column "spearman"] is used for derecting by default, but this column is not found in the network file: ', file.path, '.\nPlease check the network file for "spearman" column, or set directed == FALSE.\n')
        }
      }

      if (weighted == TRUE) {
        if ('MI' %in% colnames(df_network)) {
          igraph_obj <- igraph::set_edge_attr(igraph_obj, 'weight', index = igraph::E(igraph_obj), value = df_network[, 'MI'])
        } else {
          stop('The mutual information [column "MI"] is used for weighting by default, but this column is not found in the network file: ', file.path, '.\nPlease check the network file for "MI" column, or set weighted == FALSE.\n')
        }
      }

      num_node <- length(igraph::V(igraph_obj)) # number of vertices/nodes
      num_edge <- length(igraph::E(igraph_obj)) # number of edges

      out_degree <- igraph::degree(igraph_obj, mode = "out")
      driver_list <- unique(names(out_degree)[which(out_degree > 0)])
      num_driver <- length(driver_list) # number of drivers
      out_degree.driver <- out_degree[driver_list]
      targetSize_mean <- mean(out_degree.driver) # mean of target size
      targetSize_median <- median(out_degree.driver) # median of target size
      targetSize_min <- min(out_degree.driver) # min of target size
      targetSize_max <- max(out_degree.driver) # max of target size

      stats_table[i,1] <- file.tag; stats_table[i,2] <- num_node; stats_table[i,3] <- num_edge; stats_table[i,4] <- num_driver;
      stats_table[i,5] <- targetSize_mean; stats_table[i,6] <- targetSize_median; stats_table[i,7] <- targetSize_min; stats_table[i,8] <- targetSize_max;
      stats_table[i,9] <- file.path;

      ## generate html report
      if (generate_html == TRUE) {
        ## package
        if(rmarkdown::pandoc_available() == FALSE){
          stop('pandoc not available, please set Sys.setenv(RSTUDIO_PANDOC=$pandoc_installed_path), or set generate_html = FALSE')
        }
        ## output dir
        file.outdir <- dirname(file.path)
        if (!is.null(outdir)) {
          if (dir.exists(outdir)) {
            file.outdir <- outdir
          } else {
            dir.create(outdir, recursive = TRUE)
            message('The outdir is created: ', outdir, '.')
          }

        }

        ## prefix
        if (is.null(prefix)) {
          file.out_name <- paste0(file.outdir, "/NetworkQC.", file.tag)
        } else {
          file.out_name <- paste0(file.outdir, "/", prefix, ".NetworkQC.", file.tag)
        }

        ## generate the html QC report
        rmarkdown::render(input = system.file("rmd", "Network_QC.Rmd", package = "scMINER"), output_file = paste0(file.out_name, ".html"), clean = TRUE, quiet = TRUE, params = list(obj = igraph_obj))
      }
    }
    return(stats_table)
  }

  if (from_file == TRUE) {
    ## check network file
    if (!file.exists(network_file)) {
      stop('The input network file was not found:', network_file, '.')
    }

    stats_table <- data.frame(network_tag=NA, network_node=NA, network_edge=NA, driver_count=NA, targetSize_mean=NA, targetSize_median=NA, targetSize_minimum=NA, targetSize_maximum=NA, network_path=NA)
    file.path <- network_file
    file.tag <- basename(file.path)

    ## generate igraph obj from network file
    df_network <- read.delim(file = file.path, stringsAsFactors = FALSE)
    igraph_obj <- igraph::graph_from_data_frame(df_network, directed = directed)
    if (directed == TRUE) {
      if ('spearman' %in% colnames(df_network)) {
        igraph_obj <- igraph::set_edge_attr(igraph_obj, 'sign', index = igraph::E(igraph_obj), value = sign(df_network[, 'MI']))
      } else {
        stop('The sign of Spearman correlation coefficient [column "spearman"] is used for derecting by default, but this column is not found in the network file: ', file.path, '.\nPlease check the network file for "spearman" column, or set directed == FALSE.\n')
      }
    }

    if (weighted == TRUE) {
      if ('MI' %in% colnames(df_network)) {
        igraph_obj <- igraph::set_edge_attr(igraph_obj, 'weight', index = igraph::E(igraph_obj), value = df_network[, 'MI'])
      } else {
        stop('The mutual information [column "MI"] is used for weighting by default, but this column is not found in the network file: ', file.path, '.\nPlease check the network file for "MI" column, or set weighted == FALSE.\n')
      }
    }

    num_node <- length(igraph::V(igraph_obj)) # number of vertices/nodes
    num_edge <- length(igraph::E(igraph_obj)) # number of edges

    out_degree <- igraph::degree(igraph_obj, mode = "out")
    driver_list <- unique(names(out_degree)[which(out_degree > 0)])
    num_driver <- length(driver_list) # number of drivers
    out_degree.driver <- out_degree[driver_list]
    targetSize_mean <- mean(out_degree.driver) # mean of target size
    targetSize_median <- median(out_degree.driver) # median of target size
    targetSize_min <- min(out_degree.driver) # min of target size
    targetSize_max <- max(out_degree.driver) # max of target size

    stats_table[1,1] <- file.tag; stats_table[1,2] <- num_node; stats_table[1,3] <- num_edge; stats_table[1,4] <- num_driver;
    stats_table[1,5] <- targetSize_mean; stats_table[1,6] <- targetSize_median; stats_table[1,7] <- targetSize_min; stats_table[1,8] <- targetSize_max;
    stats_table[1,9] <- file.path;

    ## generate html report
    if (generate_html == TRUE) {
      ## package
      if(rmarkdown::pandoc_available() == FALSE){
        stop('pandoc not available, please set Sys.setenv(RSTUDIO_PANDOC=$pandoc_installed_path), or set generate_html = FALSE')
      }
      ## output dir
      file.outdir <- dirname(file.path)
      if (!is.null(outdir)) {
        if (dir.exists(outdir)) {
          file.outdir <- outdir
        } else {
          dir.create(outdir, recursive = TRUE)
          message('The outdir is created: ', outdir, '.')
        }

      }

      ## prefix
      if (is.null(prefix)) {
        file.out_name <- paste0(file.outdir, "/NetworkQC.", file.tag)
      } else {
        file.out_name <- paste0(file.outdir, "/", prefix, ".NetworkQC.", file.tag)
      }

      ## generate the html QC report
      rmarkdown::render(input = system.file("rmd", "Network_QC.Rmd", package = "scMINER"), output_file = paste0(file.out_name, ".html"), clean = TRUE, quiet = TRUE, params = list(obj = igraph_obj))
    }
    return(stats_table)
  }
}


#' Scale a numeric vector using Z-normalization
#'
#' @description
#' This function is used to scale a numeric vector using Z-normalization. `NA` would be ignored. This is an internal function for `cal_Activity()`, `getActivity_individual()`, `getActivity_inBatch()`.
#'
#' @param x a vector of numbers for z-normalization
#'
#' @return a vector of numbers with z-normalized
#' @export
#'
#' @examples z_normalization(c(1,2,3,4,5,NA,6,7,8,9))
z_normalization <- function(x) {
  x <- x[!is.na(x)]
  (x - base::mean(x, na.rm = TRUE)) / stats::sd(x, na.rm = TRUE)
}


#' Convert a txt network file to a list
#'
#' @description
#' This function is used to convert a data frame generated from the SJARACNe network file (by `read.delim()` or others) to a list that the names are the source genes and the values are
#' a data frame of target information of each source gene. This is an Iinternal function for `cal_Activity()`, `getActivity_individual()`, `getActivity_inBatch()`.
#'
#' @param net_dat a data frame generated from SJARANCe network file. These columns are needed: "`source`", "`target`", "`MI`" and "`spearman`".
#'
#' @return A list of source genes, for each source gene, the value is a data frame with "`target`", "`MI`" and "`spearman`" as the columns
#' @export
#'
#' @examples
#' net_data <-  read.table(system.file("extdata/demo_pbmc14k/SJARACNe/B/TF/bt100_pc001/consensus_network_ncol_.txt", package = "scMINER"),
#'                         header = TRUE, sep = "\t", stringsAsFactors = FALSE, quote = "",
#'                         colClasses = c("character", "character", "character", "character", "numeric", "numeric", "numeric", "numeric", "numeric"))
#' target_list <- get_net2target_list(net_data)
#'
get_net2target_list <- function(net_dat = NULL) {
  all_source <- base::unique(net_dat$source)
  all_target <- base::lapply(all_source, function(x) {
    n1 <- net_dat[which(net_dat$source == x), base::intersect(c('target', 'MI', 'spearman'), colnames(net_dat))]
    if (class(n1) =='character') {n1 <- data.frame('target' = n1, 'MI' = 1, 'spearman' = 1, stringsAsFactors = F)}
    n1 <- unique(n1)
    if (length(unique(n1$target)) != length(n1$target)) {
      t1 <- table(n1$target)
      w1 <- names(which(t1 == 1)); w2 <- names(which(t1 > 1))
      w21 <- n1[which(n1$target %in% w1),]
      w22 <- do.call(rbind, base::lapply(w2, function(x) {
        x1 <- n1[which(n1$target == x),]
        x1 <- x1[which.max(x1$MI),]
      }))
      n1 <- rbind(w21, w22)
    }
    rownames(n1) <- n1$target
    return(n1)
  })
  names(all_target) <- all_source
  return(all_target)
}


#' Convert ther list generated by `get_net2target_list()` to a matrix of signed mutual information
#'
#' @description
#' This function is used to conver the list generated by `get_net2target_list()` to a matrix of mutual information signed by Spearman correlation coefficient, sources by targets. This is an
#' internal function for c`al_Activity()`, `getActivity_individual()`, `getActivity_inBatch()`.
#'
#' @param target_list a list of source genes returned by `get_net2target_list()`, for each source gene, the value if a data frame with "`target`", "`MI`" and "`spearman`" as the columns,
#' @param activity_method Character, method used to calculate the activity: "`mean`" (the default), "`weightedmean`", "`absmean`" or "`maxmean`".
#'
#' @return If "`weightedmean`" is given, it returns a matrix of signed (by Spearman correlation coefficient) mutual information, the sign of which will be used for activity calculation. For
#' all the other methods ("`mean`", "`absmean`" or "`maxmean`"), it returns a matrix of 1.
#' @export
#'
#' @examples
#' net_data <-  read.table(system.file("extdata/demo_pbmc14k/SJARACNe/B/TF/bt100_pc001/consensus_network_ncol_.txt", package = "scMINER"),
#'                         header = TRUE, sep = "\t", stringsAsFactors = FALSE, quote = "",
#'                         colClasses = c("character", "character", "character", "character", "numeric", "numeric", "numeric", "numeric", "numeric"))
#' target_list <- get_net2target_list(net_data)
#'
#' weight_matrix <- get_target_list2matrix(target_list)
#'
get_target_list2matrix <- function(target_list = NULL, activity_method = 'mean') {
  all_source <- names(target_list)
  all_target <- base::unique(unlist(base::lapply(target_list, function(x) rownames(x))))
  mat_sign <- matrix(0, nrow = base::length(all_source), ncol = base::length(all_target))
  rownames(mat_sign) <- all_source;
  colnames(mat_sign) <- all_target;
  for (i in all_source) {
    if (activity_method != 'weightedmean') {mat_sign[i, rownames(target_list[[i]])] <- 1}
    if (activity_method == 'weightedmean') {mat_sign[i, rownames(target_list[[i]])] <- target_list[[i]]$MI*sign(target_list[[i]]$spearman)}
  }
  return(mat_sign)
}


#' Calculate driver activities from gene expression matrix and networks
#'
#' @description
#' This function is used to calculate activities from gene expression matrix and networks. This is an internal function for `cal_Activity()`, `getActivity_individual()`, `getActivity_inBatch()`.
#'
#' @param target_list a list of source genes returned by `get_net2target_list()`, for each source gene, the value if a data frame with "`target`", "`MI`" and "`spearman`" as the columns.
#' @param cal_mat a matrix of normalized and log-transformed gene expression values
#' @param activity_method Character, method used to calculate the activity: "`mean`" (the default), "`weightedmean`", "`absmean`" or "`maxmean`".
#' @param do.std Logical, whether to do the z-normalization on the gene expression values in each sample. Default: `TRUE`.
#'
#' @return a matrix of activities, drivers by cells
#' @export
#'
#' @examples
#' net_data <-  read.table(system.file("extdata/demo_pbmc14k/SJARACNe/B/TF/bt100_pc001/consensus_network_ncol_.txt", package = "scMINER"),
#'                         header = TRUE, sep = "\t", stringsAsFactors = FALSE, quote = "",
#'                         colClasses = c("character", "character", "character", "character", "numeric", "numeric", "numeric", "numeric", "numeric"))
#' target_list <- get_net2target_list(net_data)
#'
#' data(pbmc14k_expression.eset)
#'
#' act_mat <- cal_Activity(target_list = target_list, cal_mat = exprs(pbmc14k_expression.eset), activity_method = 'mean', do.std = TRUE)
cal_Activity <- function(target_list = NULL, cal_mat = NULL, activity_method = 'mean', do.std = TRUE) {
  ## check parameters
  if (is.null(target_list) == TRUE) {
    message('The target_list is not specified.'); return(FALSE)
  }

  if (is.null(cal_mat) == FALSE) {
    if (nrow(cal_mat) == 0) {
      message('No gene was found in cal_mat.'); return(FALSE)
    }
  } else {
    message('The cal_mat is not specified.'); return(FALSE)
  }

  ## prepare matrices
  mat_weight <- get_target_list2matrix(target_list, activity_method = activity_method) # matrix contains 0 (no edge) and signed MI
  mat_binary <- get_target_list2matrix(target_list, activity_method = 'mean') # matrix contains 0 (no edge) and 1 (with edge) only

  ## scale the data
  if (do.std == TRUE) {cal_mat <- base::apply(cal_mat, 2, z_normalization)}
  overlap_target <- base::intersect(row.names(cal_mat), colnames(mat_weight))
  if (base::length(overlap_target) == 0) {message('No intersected genes found for the cal_mat and target in the network, please check and re-try!'); return(FALSE)}

  mat_weight <- mat_weight[, overlap_target, drop = FALSE] # network info
  mat_binary <- mat_binary[, overlap_target, drop = FALSE] # network binary info
  cal_mat <- cal_mat[overlap_target, , drop = FALSE] # expression info

  ## weighted mean + mean
  if (activity_method %in% c('weightedmean', 'mean')) {
    out_mat <- mat_weight %*% cal_mat
    out_mat <- out_mat/Matrix::rowSums(mat_binary) # get mean
  }
  ## absmean
  if (activity_method == 'absmean') {
    out_mat <- mat_weight %*% abs(cal_mat) # get the absolute values of all expression measurements it's same as the "mean" if all expression values are >= 0
    out_mat <- out_mat/Matrix::rowSums(mat_binary) # get mean
  }
  ## maxmean
  if (activity_method == 'maxmean') {
    cal_mat_pos <- cal_mat; cal_mat_pos[which(cal_mat_pos < 0)] <- 0;
    cal_mat_neg <- cal_mat; cal_mat_neg[which(cal_mat_neg > 0)] <- 0;
    out_mat_pos  <- mat_weight %*% cal_mat_pos
    out_mat_pos  <- out_mat_pos/Matrix::rowSums(mat_binary) ## get mean
    out_mat_neg  <- mat_weight %*% cal_mat_neg
    out_mat_neg  <- out_mat_neg/Matrix::rowSums(mat_binary) ## get mean
    out_mat_sign <- sign(abs(out_mat_pos) - abs(out_mat_neg))
    out_mat_sign_pos <- out_mat_sign; out_mat_sign_pos[out_mat_sign_pos != 1] <- 0;
    out_mat_sign_neg <- out_mat_sign; out_mat_sign_neg[out_mat_sign_neg != -1] <- 0;
    out_mat <- out_mat_pos*out_mat_sign_pos - out_mat_neg*out_mat_sign_neg
  }

  ## output
  ac_mat <- as.matrix(out_mat)
  w1 <- which(is.na(ac_mat[,1]) == FALSE)
  if (base::length(w1) == 0) {message('Fail in calculating activity, please check the ID type in cal_mat and target_list and try again !')}
  ac_mat <- ac_mat[w1, , drop = FALSE]
  return(ac_mat)
}


#' Calculate driver activities per group from network files
#'
#' @description
#' This function is used to calculate the driver activities of one single group from the sparse eset obj and networks generated by SJARACNe. To calculate driver activities of multiple groups from a scMINER directory, please use `getActivity_inBatch()`.
#'
#' @param input_eset The group-specific expression set object which has been filtered, normalized and log-transformed
#' @param network_file.tf The path to the TF network file generated by SJARACNe
#' @param network_file.sig The path to the SIG network file generated by SJARACNe
#' @param driver_type Character, type of the pre-defined driver list to use: "`TF`" for transcriptional factors only, "`SIG`" for signaling genes only, or "`TF_SIG`" for both. Default: "`TF_SIG`".
#' @param activity_method Character, method used to calculate the activity: "`mean`" (the default), "`weightedmean`", "`absmean`" or "`maxmean`".
#' @param do.z_normalization Logical, whether to do the z-normalization on the gene expression values in each sample. Set if to `FALSE` only when the expression values has been scaled in each cell. Default: `TRUE`.
#'
#' @return A expression set object of the group-of-interest. The `assayData` is the activity matrix of all cells of all groups, drivers by cells. The `phenoData` and `featureData` are exactly save with the input eset.
#' @export
#'
#' @examples
#' data(pbmc14k_expression.eset)
#' activity_group.eset <- getActivity_individual(input_eset = pbmc14k_expression.eset[, pbmc14k_expression.eset$trueLabel == "B"],
#'                                               network_file.tf = system.file("extdata/demo_pbmc14k/SJARACNe/B/TF/bt100_pc001/consensus_network_ncol_.txt", package = "scMINER"),
#'                                               network_file.sig = system.file("extdata/demo_pbmc14k/SJARACNe/B/SIG/bt100_pc001/consensus_network_ncol_.txt", package = "scMINER"),
#'                                               driver_type = "TF_SIG")
getActivity_individual <- function(input_eset,
                                   network_file.tf = NULL,
                                   network_file.sig = NULL,
                                   driver_type = "TF_SIG",
                                   activity_method = "mean", do.z_normalization = TRUE)
{
  ## check activity_method
  if (length(activity_method) == 1) {
    if ((activity_method %in% c("mean", "weightedmean", "absmean", "maxmean")) == FALSE) {
      stop('The activity_method can not be recognized. Should be [mean | weightedmean | absmean | maxmean].')
    }
  } else {
    stop('The length of activity_method much be 1. Please check and re-try.')
  }

  ## check driver_type and networks
  if (length(driver_type) == 1) {
    if (driver_type == "TF_SIG") {
      if (is.null(network_file.tf)|is.null(network_file.sig)) {stop('Both network_file.tf and network_file.sig are required when driver_type = "TF_SIG".')}
    } else if (driver_type == "TF") {
      if (is.null(network_file.tf) == TRUE) {stop('The network_file.tf is required when driver_type = "TF".')}
    } else if (driver_type == "SIG") {
        if (is.null(network_file.sig) == TRUE) {stop('The network_file.sig is required when driver_type = "SIG".')}
    } else {
        stop('The driver_type can not be recognized. Should be [TF_SIG | TF | SIG].')
    }
  } else {
    stop('The length of driver_type much be 1. Please check and re-try.')
  }

  ## calculate activity
  if (driver_type %in% c("TF_SIG", "TF")) {
    network.tf <- read.delim(file=network_file.tf, stringsAsFactors = FALSE)
    target_list.tf <- get_net2target_list(network.tf)
    names(target_list.tf) <- paste0(names(target_list.tf), "_TF")
  }

  if (driver_type %in% c("TF_SIG", "SIG")) {
    network.sig <- read.delim(file=network_file.sig, stringsAsFactors = FALSE)
    target_list.sig <- get_net2target_list(network.sig)
    names(target_list.sig) <- paste0(names(target_list.sig), "_SIG")
  }

  if (driver_type == "TF_SIG") {target_list = c(target_list.tf, target_list.sig)
  } else if (driver_type == "TF") {target_list = target_list.tf
  } else if (driver_type == "SIG") {target_list = target_list.sig}

  acs <- cal_Activity(target_list = target_list, cal_mat = exprs(input_eset), activity_method = activity_method, do.std = do.z_normalization)

  ## prepare activity eset
  acs_mtx <- data.frame(acs, check.names = FALSE)
  acs_mtx <- acs_mtx[!is.na(row.names(acs_mtx)),]

  if (any(is.na(acs_mtx))) {
    min_v <- min(acs_mtx, na.rm = T)
    acs_mtx[is.na(acs_mtx)] <- min_v
    cat('NAs were found in the activity matrix and have been replaced by the minimum value: ', min_v, '.\n')
  }

  if (any(is.na(acs_mtx))) {
    min_v <- min(acs_mtx, na.rm = T)
    acs_mtx[is.na(acs_mtx)] <- min_v
    cat('NAs were found in the activity matrix and have been replaced by the minimum value: ', min_v, '.\n')
  }

  acs_pd <- Biobase::pData(input_eset)
  acs_pd <- acs_pd[colnames(acs_mtx),]

  acs_fd <- data.frame(row.names = row.names(acs_mtx), driver_id = row.names(acs_mtx), gene_symbol = gsub("_TF$|_SIG$", "", row.names(acs_mtx)))
  acs_fd <- acs_fd[row.names(acs_mtx),]

  acs.eset <- new("ExpressionSet",
                  phenoData = new("AnnotatedDataFrame", acs_pd),
                  featureData = new("AnnotatedDataFrame", acs_fd),
                  annotation = "",
                  exprs = as.matrix(acs_mtx))

  return(acs.eset)
}


#' Calculate driver activities in batch from the SJARACNe directory
#'
#' @description
#' This function is used to calculate the driver activities of multiple groups from a scMINER directory. To calculate driver activities of one single group, please use `getActivity_individual()`.
#'
#' @param input_eset The expression set object which has been filtered, normalized and log-transformed
#' @param sjaracne_dir The path to the SJARACNe directory
#' @param group_name Character, name of the column for grouping, usually the column of cell types or clusters
#' @param group_exclude A vector of group names to exclude in activity calculation
#' @param network_tag.tf Character or `NULL`, the tag used to distinguish different SJARACNe runs from the same input files. This is usually the name of the folder(s) in "`TF`" folder of each group. Default: `NULL`.
#' @param network_tag.sig Character or `NULL`, the tag used to distinguish different SJARACNe runs from the same input files. This is usually the name of the folder(s) in "`SIG`" folder of each group. Default: `NULL`.
#' @param driver_type Character, type of the pre-defined driver list to use. Should be one of: "`TF`" for transcriptional factors only, "`SIG`" for signaling genes only, or "`TF_SIG`" for both. Default: "`TF_SIG`".
#' @param activity_method Character, method used to calculate the activity: "`mean`" (the default), "`weightedmean`", "`absmean`" or "`maxmean`".
#' @param do.z_normalization Logical, whether to do the z-normalization on the gene expression values in each sample. Set if to `FALSE` only when the expression values has been scaled in each cell. Default: `TRUE`.
#'
#' @return A expression set object. The `assayData` is the activity matrix of all cells of all groups, drivers by cells. The `phenoData` and `featureData` are exactly save with the input eset.
#' @export
#'
#' @examples
#' data(pbmc14k_expression.eset)
#'
#' ## 1. when no tag was used in running SJARACNE: the network file folder ("sjaracne_workflow-*") is directly under TF/SIG folder of each group.
#' activity.eset <- getActivity_inBatch(input_eset = pbmc14k_expression.eset,
#'                                      sjaracne_dir = system.file("extdata/demo_pbmc14k/SJARACNe", package = "scMINER"),
#'                                      group_name = "trueLabel",
#'                                      driver_type = "TF_SIG",
#'                                      activity_method = "mean",
#'                                      do.z_normalization = TRUE)
#'
#' ## 2. when tag (e.g. "bt100_pc001" ) was used: the network file folder ("sjaracne_workflow-*") is directly under a subfolder "bs_100" of the TF/SIG folder of each group.
#' activity.eset <- getActivity_inBatch(input_eset = pbmc14k_expression.eset,
#'                                      sjaracne_dir = system.file("extdata/demo_pbmc14k/SJARACNe", package = "scMINER"),
#'                                      group_name = "trueLabel",
#'                                      network_tag.tf = "bt100_pc001",
#'                                      network_tag.sig = "bt100_pc001",
#'                                      driver_type = "TF_SIG",
#'                                      activity_method = "mean",
#'                                      do.z_normalization = TRUE)
#'
#' ## 3. to calculate the activities of TF only
#' activity.eset <- getActivity_inBatch(input_eset = pbmc14k_expression.eset,
#'                                      sjaracne_dir = system.file("extdata/demo_pbmc14k/SJARACNe", package = "scMINER"),
#'                                      group_name = "trueLabel",
#'                                      network_tag.tf = "bt100_pc001",
#'                                      network_tag.sig = "bt100_pc001",
#'                                      driver_type = "TF",
#'                                      activity_method = "mean",
#'                                      do.z_normalization = TRUE)
#'
#' ## 4. to exclude some groups in the activity calculation (e.g. "NK" and "Monocyte")
#' activity.eset <- getActivity_inBatch(input_eset = pbmc14k_expression.eset,
#'                                      sjaracne_dir = system.file("extdata/demo_pbmc14k/SJARACNe", package = "scMINER"),
#'                                      group_name = "trueLabel",
#'                                      group_exclude = c("NK", "Monocyte"),
#'                                      network_tag.tf = "bt100_pc001",
#'                                      network_tag.sig = "bt100_pc001",
#'                                      driver_type = "TF",
#'                                      activity_method = "mean",
#'                                      do.z_normalization = TRUE)
#'
#' ## 5. when calculate the activities from the gene expression values scaled by other methods (e.g. ScaleData() from Seurat package)
#' activity.eset <- getActivity_inBatch(input_eset = pbmc14k_expression.eset,
#'                                      sjaracne_dir = system.file("extdata/demo_pbmc14k/SJARACNe", package = "scMINER"),
#'                                      group_name = "trueLabel",
#'                                      network_tag.tf = "bt100_pc001",
#'                                      network_tag.sig = "bt100_pc001",
#'                                      driver_type = "TF_SIG",
#'                                      activity_method = "mean",
#'                                      do.z_normalization = FALSE)
#'
getActivity_inBatch <- function(input_eset,
                                sjaracne_dir,
                                group_name, group_exclude = NULL,
                                network_tag.tf = NULL, network_tag.sig = NULL,
                                driver_type = "TF_SIG",
                                activity_method = "mean", do.z_normalization = TRUE)
{
  ## check sjaracne_dir
  if (dir.exists(sjaracne_dir) == FALSE) {stop('The sjaracne_dir does not exsits. Please check and re-try.')}

  ## check driver_tag
  if (length(driver_type) == 1) {
    if ((driver_type %in% c("TF_SIG", "TF", "SIG")) == FALSE) {
      stop('The driver_type can not be recognized. Should be [TF_SIG | TF | SIG].')
    }
  } else {
    stop('The length of driver_type much be 1. Please check and re-try.')
  }

  ## check activity_method
  if (length(activity_method) == 1) {
    if ((activity_method %in% c("mean", "weightedmean", "absmean", "maxmean")) == FALSE) {
      stop('The activity_method can not be recognized. Should be [mean | weightedmean | absmean | maxmean].')
    }
  } else {
    stop('The length of activity_method much be 1. Please check and re-try.')
  }

  ## group info
  if ((group_name %in% colnames(Biobase::pData(input_eset))) == FALSE) {
    stop(group_name, ' was found in the input_eset.')
  } else {
    grps <- unique(Biobase::pData(input_eset)[, group_name])
    cat(length(grps), "groups were found in", group_name, "...\n")
  }

  ## group_exclude
  if (is.null(group_exclude) == FALSE & length(group_exclude) > 0) {
    group_exclude.notFound <- group_exclude[!group_exclude %in% grps]
    if (length(group_exclude.notFound) == 0) {
      grps <- grps[!grps %in% group_exclude]
      if (length(grps) == 0) {
        stop('No group left after excluding the groups specified by group_exclude ...\n')
      } else {
        cat(length(grps), "groups left after excluding the groups specified by group_exclude:", paste(grps, collapse = ", "), "...\n")
      }
    } else if (length(group_exclude.notFound) == 1) {
      stop(length(group_exclude.notFound), ' group specified in group_exclude was not found in group_name: ', paste(group_exclude.notFound, collapse = ", "), '.')
    } else if (length(group_exclude.notFound) > 1) {
      stop(length(group_exclude.notFound), ' groups specified in group_exclude were not found in group_name: ', paste(group_exclude.notFound, collapse = ", "), '.')
    }
  }

  ## check networks
  cat ("Checking network files for each group ...\n")
  for (i in 1:length(grps)) {
    cat ("\tGroup", i, "/", length(grps), ":", grps[i], "...\n")

    if (driver_type %in% c("TF_SIG", "TF")) {
      grp_dir.tf <- paste0(sjaracne_dir, "/", grps[i], "/TF")
      if (!dir.exists(grp_dir.tf)) {stop('The directory for TF network was not found: ', grp_dir.tf, '.\n')}

      if (is.null(network_tag.tf)) {
        network_file.tf <- list.files(path = grp_dir.tf, pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
        if (length(network_file.tf) == 0) {
          stop('No network file, consensus_network_ncol_.txt, was found in ', grp_dir.tf, '.')
        } else if (length(network_file.tf) == 1) {
          cat("\t\tTF network check passed!\n")
        } else if (length(network_file.tf) > 1) {
          stop('Multiple TF network files were found in ', grp_dir.tf, '. Please check and re-try.\nPlease use network_tag.tf to specify one if multiple folders found in ', grp_dir.tf, '.')
        }
      } else {
        if (length(network_tag.tf) == 1) {
          grp_dir.tf_tag <- paste0(grp_dir.tf, "/", network_tag.tf)
          if (!dir.exists(grp_dir.tf_tag)) {
            stop('The directory for TF network with tag "', network_tag.tf, '" was not found: ', grp_dir.tf_tag, '.\n')
          } else {
            network_file.tf <- list.files(path = grp_dir.tf_tag, pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
          }

          if (length(network_file.tf) == 0) {
            stop('No network file, consensus_network_ncol_.txt, was found in ', grp_dir.tf_tag, '.')
          } else if (length(network_file.tf) == 1) {
            cat("\t\tTF network check passed!\n")
          } else if (length(network_file.tf) > 1) {
            stop('Multiple TF network files were found in ', grp_dir.tf_tag, '. Please check and re-try.')
          }
        } else {
          stop('The length of network_tag.tf must be 1. Please check and re-try.')
        }
      }
    }

    if (driver_type %in% c("TF_SIG", "SIG")) {
      grp_dir.sig <- paste0(sjaracne_dir, "/", grps[i], "/SIG")
      if (!dir.exists(grp_dir.sig)) {stop('The directory for SIG network was not found: ', grp_dir.sig, '.\n')}

      if (is.null(network_tag.sig)) {
        network_file.sig <- list.files(path = grp_dir.sig, pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
        if (length(network_file.sig) == 0) {
          stop('No network file, consensus_network_ncol_.txt, was found in ', grp_dir.sig, '.')
        } else if (length(network_file.sig) == 1) {
          cat("\t\tSIG network check passed!\n")
        } else if (length(network_file.sig) > 1) {
          stop('Multiple SIG network files were found in ', grp_dir.sig, '. Please check and re-try.\nPlease use network_tag.tf to specify one if multiple folders found in ', grp_dir.sig, '.')
        }
      } else {
        if (length(network_tag.sig) == 1) {
          grp_dir.sig_tag <- paste0(grp_dir.sig, "/", network_tag.sig)
          if (!dir.exists(grp_dir.sig_tag)) {
            stop('The directory for SIG network with tag "', network_tag.sig, '" was not found: ', grp_dir.sig_tag, '.\n')
          } else {
            network_file.sig <- list.files(path = grp_dir.sig_tag, pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
          }

          if (length(network_file.sig) == 0) {
            stop('No network file, consensus_network_ncol_.txt, was found in ', grp_dir.sig_tag, '.')
          } else if (length(network_file.sig) == 1) {
            cat("\t\tSIG network check passed!\n")
          } else if (length(network_file.sig) > 1) {
            stop('Multiple SIG network files were found in ', grp_dir.sig_tag, '. Please check and re-try.')
          }
        } else {
          stop('The length of network_tag.sig must be 1. Please check and re-try.')
        }
      }
    }
  }

  ## calculate activity
  acs_master <- data.frame(driver_id = NA, stringsAsFactors = FALSE)
  cat("Calculating activity for each group ...\n")
  for (i in 1:length(grps)) {
    cat ("\tGroup", i, "/", length(grps), ":", grps[i], "...\n")

    ## sub eset of group
    eset.sel <- input_eset[,which(Biobase::pData(input_eset)[, group_name] == grps[i])]

    ## get the target list
    if (driver_type %in% c("TF_SIG", "TF")) {
      grp_dir.tf <- paste0(sjaracne_dir, "/", grps[i], "/TF")

      ## retrieve network file
      if (is.null(network_tag.tf)) {
        network_file.tf <- list.files(path = grp_dir.tf, pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
      } else {
        network_file.tf <- list.files(path = paste0(grp_dir.tf, "/", network_tag.tf), pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
      }

      network.tf <- read.delim(file=network_file.tf, stringsAsFactors = FALSE)
      target_list.tf <- get_net2target_list(network.tf)
      names(target_list.tf) <- paste0(names(target_list.tf), "_TF")
    }

    if (driver_type %in% c("TF_SIG", "SIG")) {
      grp_dir.sig <- paste0(sjaracne_dir, "/", grps[i], "/SIG")

      ## retrieve network file
      if (is.null(network_tag.sig)) {
        network_file.sig <- list.files(path = grp_dir.sig, pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
      } else {
        network_file.sig <- list.files(path = paste0(grp_dir.sig, "/", network_tag.sig), pattern="consensus_network_ncol_.txt", recursive = TRUE, full.names = TRUE)
      }

      network.sig <- read.delim(file=network_file.sig, stringsAsFactors = FALSE)
      target_list.sig <- get_net2target_list(network.sig)
      names(target_list.sig) <- paste0(names(target_list.sig), "_SIG")
    }

    if (driver_type == "TF_SIG") {
      target_list = c(target_list.tf, target_list.sig)
    } else if (driver_type == "TF") {
      target_list = target_list.tf
    } else if (driver_type == "SIG") {
      target_list = target_list.sig
    }

    acs <- cal_Activity(target_list = target_list, cal_mat = exprs(eset.sel), activity_method = activity_method, do.std = do.z_normalization)

    acs_master <- merge(acs_master, acs, by.x = "driver_id", by.y = "row.names", all = TRUE)
    cat("\tActivity calculation is completed successfully!\n")
    rm(acs)
  }

  ## prepare activity eset
  acs_mtx <- data.frame(acs_master, check.names = FALSE)
  acs_mtx <- acs_mtx[!is.na(acs_mtx$driver_id),]
  row.names(acs_mtx) <- acs_mtx$driver_id
  acs_mtx <- acs_mtx[,-1]

  if (any(is.na(acs_mtx))) {
    min_v <- min(acs_mtx, na.rm = T)
    acs_mtx[is.na(acs_mtx)] <- min_v
    cat('NAs were found in the activity matrix and have been replaced by the minimum value: ', min_v, '.\n')
  }

  acs_pd <- Biobase::pData(input_eset)
  acs_pd <- acs_pd[colnames(acs_mtx),]

  acs_fd <- data.frame(row.names = row.names(acs_mtx), driver_id = row.names(acs_mtx), gene_symbol = gsub("_TF$|_SIG$", "", row.names(acs_mtx)))
  acs_fd <- acs_fd[row.names(acs_mtx),]

  acs.eset <- new("ExpressionSet",
                  phenoData = new("AnnotatedDataFrame", acs_pd),
                  featureData = new("AnnotatedDataFrame", acs_fd),
                  annotation = "",
                  exprs = as.matrix(acs_mtx))

  return(acs.eset)
}



